Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(revision 1508686)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(revision 1508687)
@@ -24,13 +24,14 @@
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.transport.base.ParamUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.http.nio.NHttpClientEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
 import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
+import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;
 
 import javax.net.ssl.*;
 import javax.xml.namespace.QName;
@@ -48,7 +49,7 @@
 
 public class PassThroughHttpSSLSender extends PassThroughHttpSender {
 
-    private Log log = LogFactory.getLog(PassThroughHttpSSLSender.class);
+    private static final SynapseAdaptorForOcspCrl ocspCrl = new SynapseAdaptorForOcspCrl();
 
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler,
                                                SSLContext sslContext,
@@ -104,12 +105,12 @@
     protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)
             throws AxisFault {
 
-        final Parameter hostnameVerifier = transportOut.getParameter("HostnameVerifier");
-        if (hostnameVerifier != null) {
-            return createSSLSetupHandler(hostnameVerifier.getValue().toString());
-        } else {
-            return createSSLSetupHandler(null);
-        }
+        Parameter hostnameVerifier = transportOut.getParameter("HostnameVerifier");
+        String hostnameVerifierValue = hostnameVerifier != null ?
+                hostnameVerifier.getValue().toString() : null;
+        Parameter revocationVerifierParam = transportOut.getParameter("CertificateRevocationVerifier");
+        return createSSLSetupHandler(hostnameVerifierValue,
+                new CertificateVerificationConfig(revocationVerifierParam));
     }
 
     /**
@@ -280,8 +281,8 @@
         }
     }
 
-    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier)
-            throws AxisFault {
+    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier,
+                                                  final CertificateVerificationConfig cvConfig) throws AxisFault {
 
         return new SSLSetupHandler() {
 
@@ -298,6 +299,7 @@
                 }
 
                 boolean valid = false;
+                //Do HostName verification.
                 if (hostnameVerifier != null) {
                     if ("Strict".equals(hostnameVerifier)) {
                         valid = HostnameVerifier.STRICT.verify(address, session);
@@ -313,6 +315,17 @@
                 if (!valid) {
                     throw new SSLException("Host name verification failed for host : " + address);
                 }
+
+                if (cvConfig.isEnabled()) {
+                    //Do revocation verification of Certificates
+                    try {
+                        ocspCrl.verifyRevocationStatus(session.getPeerCertificateChain(),
+                                cvConfig.getCacheSize(), cvConfig.getCacheDuration());
+                    } catch (CertificateVerificationException e) {
+                        throw new SSLException("Certificate chain validation failed for host : " +
+                                address, e);
+                    }
+                }
             }
         };
     }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(revision 1508686)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(revision 1508687)
@@ -23,8 +23,6 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportInDescription;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.http.nio.NHttpServerEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
@@ -39,8 +37,6 @@
 import java.security.KeyStore;
 
 public class PassThroughHttpSSLListener extends PassThroughHttpListener {
-    
-    private Log log = LogFactory.getLog(PassThroughHttpSSLListener.class);
 
     @Override
     protected IOEventDispatch getEventDispatch(NHttpServerEventHandler handler, SSLContext sslContext,
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(revision 1508686)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(revision 1508687)
@@ -77,7 +77,7 @@
  */
 public class PassThroughHttpSender extends AbstractHandler implements TransportSender {
 
-    protected Log log;
+    protected Log log = LogFactory.getLog(this.getClass().getName());
 
     /** IOReactor used to create connections and manage them */
     private DefaultConnectingIOReactor ioReactor;
@@ -108,10 +108,6 @@
     /** The list of known hosts to go via proxy */
     private List<String> knownProxyHosts = new ArrayList<String>();
 
-    public PassThroughHttpSender() {
-        log = LogFactory.getLog(this.getClass().getName());
-    }
-
     public void init(ConfigurationContext configurationContext,
                      TransportOutDescription transportOutDescription) throws AxisFault {
 
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java	(revision 1508686)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java	(revision 1508687)
@@ -31,6 +31,9 @@
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.transport.base.ParamUtils;
 import org.apache.axiom.om.OMElement;
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
+import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;
 
 import javax.net.ssl.*;
 import javax.xml.namespace.QName;
@@ -44,10 +47,12 @@
 import java.net.SocketAddress;
 import java.net.InetSocketAddress;
 
-public class HttpCoreNIOSSLSender extends HttpCoreNIOSender{
+public class HttpCoreNIOSSLSender extends HttpCoreNIOSender {
 
     private static final Log log = LogFactory.getLog(HttpCoreNIOSSLSender.class);
 
+    private static final SynapseAdaptorForOcspCrl ocspCrl = new SynapseAdaptorForOcspCrl();
+
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler, SSLContext sslContext,
         SSLSetupHandler sslIOSessionHandler, HttpParams params,
         TransportOutDescription transportOut) throws AxisFault {
@@ -58,6 +63,7 @@
 
     /**
      * Create the SSLContext to be used by this sender
+     *
      * @param transportOut the Axis2 transport configuration
      * @return the SSLContext to be used
      */
@@ -98,12 +104,12 @@
     protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)
             throws AxisFault {
 
-        final Parameter hostnameVerifier = transportOut.getParameter("HostnameVerifier");
-        if (hostnameVerifier != null) {
-            return createSSLSetupHandler(hostnameVerifier.getValue().toString());
-        } else {
-            return createSSLSetupHandler(null);
-        }        
+        Parameter hostnameVerifier = transportOut.getParameter("HostnameVerifier");
+        String hostnameVerifierValue = hostnameVerifier != null ?
+                hostnameVerifier.getValue().toString() : null;
+        Parameter revocationVerifierParam = transportOut.getParameter("CertificateRevocationVerifier");
+        return createSSLSetupHandler(hostnameVerifierValue,
+                new CertificateVerificationConfig(revocationVerifierParam));
     }
 
     /**
@@ -274,8 +280,8 @@
         }
     }
 
-    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier)
-            throws AxisFault {
+    private SSLSetupHandler createSSLSetupHandler(final String hostnameVerifier,
+												  final CertificateVerificationConfig cvConfig) throws AxisFault {
 
         return new SSLSetupHandler() {
 
@@ -292,6 +298,7 @@
                 }
 
                 boolean valid = false;
+                //Do HostName verification.
                 if (hostnameVerifier != null) {
                     if ("Strict".equals(hostnameVerifier)) {
                         valid = HostnameVerifier.STRICT.verify(address, session);
@@ -307,6 +314,16 @@
                 if (!valid) {
                     throw new SSLException("Host name verification failed for host : " + address);
                 }
+
+                if (cvConfig.isEnabled()) {
+                    try {
+                        ocspCrl.verifyRevocationStatus(session.getPeerCertificateChain(),
+                                cvConfig.getCacheSize(), cvConfig.getCacheDuration());
+                    } catch (CertificateVerificationException e) {
+                        throw new SSLException("Certificate chain validation failed for host : " +
+                                address, e);
+                    }
+                }
             }
         };
     }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/ParentLastClassLoader.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/ParentLastClassLoader.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/ParentLastClassLoader.java	(revision 1508687)
@@ -0,0 +1,113 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.adaptor;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.InputStream;
+import java.util.Hashtable;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+/**
+ * The ParentLastClassLoader is needed because the OCSP/CRL feature for synapse uses a dependency
+ * jar from bouncyCastle version bcprov-jdk16-1.46.jar. Apache Rampart which is a synapse
+ * dependency for WS-Security also uses an older version of a bouncyCastle jar. The JVM loads the
+ * older version thus making OCSP/CRL feature fail to function. This is known as Jar Hell in java
+ * community. As a workaround, a Parent Last Class Loader is used to load the classes used by
+ * OCSP/CRL feature from the relevant jar files. The default class loader hierarchy in Java is
+ * Parent First. This custom ParentLastClassLoader overrides the default behaviour. If
+ * ParentLastClassLoader could not load a class it will delegate the job to the parent, the system
+ * class loader.
+ */
+public class ParentLastClassLoader extends ClassLoader {
+
+    //used to cache already defined classes
+    private static final Hashtable<String,Class> classes = new Hashtable<String,Class>();
+
+    private File[] jarFiles; // Jar files
+
+    public ParentLastClassLoader(ClassLoader parent) {
+        super(parent);
+        String libDir = System.getProperty("synapse.bcprov.lib");
+        if (libDir == null) {
+            libDir = "lib";
+        }
+
+        File dir = new File(libDir);
+        jarFiles = dir.listFiles(new FileFilter() {
+            public boolean accept(File f) {
+                return f.getName().startsWith("synapse-nhttp-transport") ||
+                        f.getName().equals("bcprov-jdk15on-1.49.jar");
+            }
+        });
+    }
+
+    @Override
+    public Class<?> findClass(String name) throws ClassNotFoundException {
+        throw new ClassNotFoundException();
+    }
+
+    @Override
+    protected synchronized Class<?> loadClass(String className,
+                                              boolean resolve) throws ClassNotFoundException {
+
+        try {
+            byte classByte[];
+            Class result;
+
+            //checks in cached classes
+            result = classes.get(className);
+            if (result != null) {
+                return result;
+            }
+
+            for (File jarFile : jarFiles) {
+                try {
+                    JarFile jar = new JarFile(jarFile);
+                    JarEntry entry = jar.getJarEntry(className.replace(".", "/") + ".class");
+                    InputStream is = jar.getInputStream(entry);
+                    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
+                    int nextValue = is.read();
+                    while (-1 != nextValue) {
+                        byteStream.write(nextValue);
+                        nextValue = is.read();
+                    }
+
+                    classByte = byteStream.toByteArray();
+                    result = defineClass(className, classByte, 0, classByte.length, null);
+                    classes.put(className, result);
+                    break;
+                } catch (Exception ignored) {}
+            }
+
+            if (result != null) {
+                return result;
+            } else {
+                throw new ClassNotFoundException("Not found " + className);
+            }
+        } catch (ClassNotFoundException e) {
+            // didn't find it, try the parent
+            return super.loadClass(className, resolve);
+        }
+    }
+}
+
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/SynapseAdaptorForOcspCrl.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/SynapseAdaptorForOcspCrl.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/adaptor/SynapseAdaptorForOcspCrl.java	(revision 1508687)
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.adaptor;
+
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
+import org.apache.synapse.transport.utils.sslcert.Constants;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import javax.security.cert.X509Certificate;
+
+/**
+ * This is the adaptor used to plug OCSP/CRL feature to synapse while solving the Jar Hell
+ * problem internally using ParentLastClassLoader. This adaptor is not needed if Apache Rampart
+ * and OCSP/CRL feature uses the same bouncyCastle dependency. At the time of this feature is
+ * made, Apache Rampart and OCSP/CRL feature use two different versions of bouncyCastle.
+ */
+public class SynapseAdaptorForOcspCrl {
+
+    private static final ClassLoader loader = new ParentLastClassLoader(
+            Thread.currentThread().getContextClassLoader());
+
+    public void verifyRevocationStatus(X509Certificate[] peerCertificates, Integer cacheSize,
+                                       Integer cacheDelay) throws CertificateVerificationException {
+
+        if (peerCertificates == null || cacheSize == null || cacheDelay == null) {
+            throw new IllegalArgumentException("Argument cannot be null");
+        }
+
+        try {
+            Class revocationManagerClass = loader.loadClass(Constants.REVOCATION_MANAGER);
+            Method method = revocationManagerClass.getMethod(Constants.VERIFY_METHOD,
+                    peerCertificates.getClass());
+            Constructor constructor = revocationManagerClass.getConstructor(cacheSize.getClass(),
+                    cacheDelay.getClass());
+            Object revocationManager = constructor.newInstance(cacheSize, cacheDelay);
+            method.invoke(revocationManager, new Object[] { peerCertificates });
+        } catch (Exception e) {
+            throw new CertificateVerificationException("Failed to load BouncyCastle classes for " +
+                    "certificate validation", e);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/TestConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/TestConstants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/TestConstants.java	(revision 1508687)
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.utils.sslcert;
+
+public interface TestConstants {
+
+    //Validity period of a fake certificate made. 1 day (in milliseconds)
+    final static int VALIDITY_PERIOD = 24 * 60 * 60 * 1000;
+    //Next update for OCSPResponse or X509CRL will be after Now + NEXT_UPDATE_PERIOD
+    final static int NEXT_UPDATE_PERIOD = 1000000;
+
+    /**
+     * The certificates in the resources folder will contain the certificates in the certificate chain from
+     * https://www.github.com
+     * These certificates are chosen because the certificate issuers support both CRL and OCSP. Read the certificates for
+     * more details.
+     *
+     * CAUTION: Replace the certificates if they expire or are marked as revoked by their issuers. At the moment they are
+     * valid. The expiry dates of the certificates are as follows:
+     *
+     * github.com                    : 09/02/2015
+     * DigiCertHighAssuranceEVCA-1   : 11/10/2021
+     * DigiCertHighAssuranceEVRootCA : 11/10/2031
+     */
+    final static String REAL_PEER_CERT = "/org/apache/synapse/transport/utils/sslcert" +
+            "/certificates/github/github.com";
+    final static String INTERMEDIATE_CERT = "/org/apache/synapse/transport/utils/sslcert" +
+            "/certificates/github/DigiCertHighAssuranceEVCA-1";
+    final static String ROOT_CERT = "/org/apache/synapse/transport/utils/sslcert" +
+            "/certificates/github/DigiCertHighAssuranceEVRootCA";
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/Utils.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/Utils.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/Utils.java	(revision 1508687)
@@ -0,0 +1,133 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.utils.sslcert;
+
+import org.bouncycastle.x509.X509V1CertificateGenerator;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import javax.security.auth.x500.X500Principal;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.math.BigInteger;
+import java.security.*;
+import java.security.cert.CertificateFactory;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+
+/**
+ * Contains utility methods used by the test classes.
+ */
+public class Utils {
+
+
+    public X509Certificate generateFakeRootCert(KeyPair pair) throws Exception {
+        
+        X509V1CertificateGenerator  certGen = new X509V1CertificateGenerator();
+        certGen.setSerialNumber(BigInteger.valueOf(1));
+        certGen.setIssuerDN(new X500Principal("CN=Test CA Certificate"));
+        certGen.setNotBefore(new Date(System.currentTimeMillis()));
+        certGen.setNotAfter(new Date(System.currentTimeMillis() + TestConstants.VALIDITY_PERIOD));
+        certGen.setSubjectDN(new X500Principal("CN=Test CA Certificate"));
+        certGen.setPublicKey(pair.getPublic());
+        certGen.setSignatureAlgorithm("SHA1WithRSAEncryption");
+
+        return certGen.generateX509Certificate(pair.getPrivate(), "BC");
+    }
+
+
+    public KeyPair generateRSAKeyPair() throws Exception {
+
+        KeyPairGenerator kpGen = KeyPairGenerator.getInstance("RSA", "BC");
+        kpGen.initialize(1024, new SecureRandom());
+        return kpGen.generateKeyPair();
+    }
+
+    /**
+     * CRLVerifierTest and OCSPVerifierTest both will use this method. This has common code for both test classes
+     * in creating fake peer certificates.
+     * @param caCert Certificate of CA which signs the peer certificate which will be generated.
+     * @param peerPublicKey public key of the peer certificate which will be generated.
+     * @param serialNumber  serial number of the peer certificate.
+     * @return
+     */
+    public X509V3CertificateGenerator getUsableCertificateGenerator(X509Certificate caCert,
+                                                                    PublicKey peerPublicKey, BigInteger serialNumber){
+        X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
+
+        certGen.setSerialNumber(serialNumber);
+        certGen.setIssuerDN(caCert.getSubjectX500Principal());
+        certGen.setNotBefore(new Date(System.currentTimeMillis()));
+        certGen.setNotAfter(new Date(System.currentTimeMillis() + TestConstants.VALIDITY_PERIOD));
+        certGen.setSubjectDN(new X500Principal("CN=Test End Certificate"));
+        certGen.setPublicKey(peerPublicKey);
+        certGen.setSignatureAlgorithm("SHA1WithRSAEncryption");
+
+        return certGen;
+    }
+
+    /**
+     * Generate X509Certificate object from the peer certificate file in resources directory.
+     * @return the created certificate object.
+     * @throws Exception
+     */
+    public X509Certificate getRealPeerCertificate()throws Exception {
+        return createCertificateFromResourceFile(TestConstants.REAL_PEER_CERT);
+    }
+
+    /**
+     * Create a certificate chain from the certificates in the resources directory.
+     * @return created array of certificates.
+     * @throws Exception
+     */
+    public X509Certificate[] getRealCertificateChain() throws Exception {
+
+        X509Certificate peerCert = createCertificateFromResourceFile(TestConstants.REAL_PEER_CERT);
+        X509Certificate intermediateCert = createCertificateFromResourceFile(TestConstants.INTERMEDIATE_CERT);
+        X509Certificate rootCert = createCertificateFromResourceFile(TestConstants.ROOT_CERT);
+
+        return new X509Certificate[]{ peerCert,intermediateCert,rootCert  };
+    }
+
+    /**
+     * Generates a fake certificate chain. The array will contain two certificates, the root and the peer.
+     * @return the created array of certificates.
+     * @throws Exception
+     */
+    public X509Certificate[] getFakeCertificateChain() throws Exception{
+
+        KeyPair rootKeyPair = generateRSAKeyPair();
+        X509Certificate rootCert = generateFakeRootCert(rootKeyPair);
+        KeyPair entityKeyPair = generateRSAKeyPair();
+        BigInteger entitySerialNum =BigInteger.valueOf(111);
+        X509V3CertificateGenerator certGen = getUsableCertificateGenerator(rootCert,
+                entityKeyPair.getPublic(), entitySerialNum);
+        X509Certificate entityCert = certGen.generateX509Certificate(rootKeyPair.getPrivate(), "BC");
+        return new X509Certificate[]{entityCert, rootCert};
+    }
+
+    private X509Certificate createCertificateFromResourceFile(String resourcePath) throws Exception{
+
+        CertificateFactory certFactory = CertificateFactory.getInstance("X.509", "BC");
+        File faceBookCertificateFile = new File(this.getClass().getResource(resourcePath).toURI());
+        InputStream in = new FileInputStream(faceBookCertificateFile);
+        X509Certificate certificate = (X509Certificate) certFactory.generateCertificate(in);
+        return certificate;
+    }
+}
Index: java/pom.xml
===================================================================
--- java/pom.xml	(revision 1508686)
+++ java/pom.xml	(revision 1508687)
@@ -738,6 +738,13 @@
                 <version>${httpcore.nio.version}</version>
             </dependency>
 
+            <!-- Bouncy Castle Library for OCSP/CRL Certificate Validation in HTTP Transports -->
+            <dependency>
+                <groupId>org.bouncycastle</groupId>
+                <artifactId>bcprov-jdk15on</artifactId>
+                <version>${bcprov.nhttp.version}</version>
+            </dependency>
+
             <!-- Testing -->
             <dependency>
                 <groupId>junit</groupId>
@@ -1124,6 +1131,7 @@
         <snmp4j.version>2.0.3</snmp4j.version>
         <snmp4j.agent.version>2.0.5</snmp4j.agent.version>
         <rabbitmq.version>3.1.2</rabbitmq.version>
+        <bcprov.nhttp.version>1.49</bcprov.nhttp.version>
 
         <!-- dependencies of Synapse extensions module -->
         <wso2commons.version>1.2</wso2commons.version>
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationConfig.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationConfig.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationConfig.java	(revision 1508687)
@@ -0,0 +1,64 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.util.JavaUtils;
+
+import javax.xml.namespace.QName;
+
+public class CertificateVerificationConfig {
+
+    private boolean enabled;
+    private Integer cacheSize = Constants.CACHE_DEFAULT_ALLOCATED_SIZE;
+    private Integer cacheDuration = Constants.CACHE_DEFAULT_DELAY_MINS;
+
+    public CertificateVerificationConfig(Parameter param) {
+        if (param == null) {
+            return;
+        }
+        OMElement element = param.getParameterElement();
+        OMElement enabledElement = element.getFirstChildWithName(new QName("Enabled"));
+        if (enabledElement != null && JavaUtils.isTrueExplicitly(enabledElement.getText())) {
+            enabled = true;
+        }
+        OMElement sizeElement = element.getFirstChildWithName(new QName("CacheSize"));
+        if (sizeElement != null) {
+            cacheSize = new Integer(sizeElement.getText());
+        }
+        OMElement delayElement = element.getFirstChildWithName(new QName("CacheDelayMins"));
+        if (delayElement != null) {
+            cacheSize = new Integer(delayElement.getText());
+        }
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public Integer getCacheSize() {
+        return cacheSize;
+    }
+
+    public Integer getCacheDuration() {
+        return cacheDuration;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/Constants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/Constants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/Constants.java	(revision 1508687)
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+public interface Constants {
+
+    public static final int CACHE_MAX_ALLOCATED_SIZE = 10000;
+    public static final int CACHE_MIN_ALLOCATED_SIZE = 50;
+    public static final int CACHE_DEFAULT_ALLOCATED_SIZE = 50;
+    public static final int CACHE_MAX_DELAY_MINS = 60 * 24;
+    public static final int CACHE_MIN_DELAY_MINS = 1;
+    public static final int CACHE_DEFAULT_DELAY_MINS = 15;
+
+    public static final String REVOCATION_MANAGER = "org.apache.synapse.transport.utils.sslcert." +
+            "RevocationVerificationManager";
+    public static final String VERIFY_METHOD = "verifyRevocationStatus";
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationStatus.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationStatus.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationStatus.java	(revision 1508687)
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+public enum RevocationStatus {
+
+    GOOD("Good"), UNKNOWN("Unknown"), REVOKED("Revoked");
+    private String message;
+
+    private RevocationStatus(String message) {
+        this.message = message;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLCache.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLCache.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLCache.java	(revision 1508687)
@@ -0,0 +1,212 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.crl;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import org.apache.synapse.commons.jmx.MBeanRegistrar;
+import org.apache.synapse.transport.utils.sslcert.cache.CacheController;
+import org.apache.synapse.transport.utils.sslcert.cache.CacheManager;
+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCache;
+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCacheValue;
+
+import java.security.cert.X509CRL;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Since a CRL maps to a CRL URL, the CRLCache should have x509CRL entries against CRL URLs.
+ * This cache is a Singleton since it is shared by any transport which needs SSL certificate
+ * validation and more than one CRLCache should not be allowed per system.
+ */
+public class CRLCache implements ManageableCache {
+
+    private static final Log log = LogFactory.getLog(CRLCache.class);
+
+    private static final CRLCache cache = new CRLCache();
+    private final Map<String, CRLCacheValue> hashMap;
+    private Iterator<Map.Entry<String, CRLCacheValue>> iterator;
+    private volatile CacheManager cacheManager;
+    private final CRLVerifier crlVerifier;
+
+    private CRLCache() {
+        hashMap = new ConcurrentHashMap<String, CRLCacheValue>();
+        iterator = hashMap.entrySet().iterator();
+        crlVerifier = new CRLVerifier(null);
+    }
+
+    public static CRLCache getCache() {
+        return cache;
+    }
+
+    /**
+     * This initialize the Cache with a CacheManager. If this method is not called, a cache manager
+     * will not be used.
+     *
+     * @param size max size of the cache
+     * @param delay defines how frequently the CacheManager will be started
+     */
+    public void init(int size, int delay) {
+        if (cacheManager == null) {
+            synchronized (CRLCache.class) {
+                if (cacheManager == null) {
+                    cacheManager = new CacheManager(cache, size, delay);
+                    CacheController mbean = new CacheController(cache,cacheManager);
+                    MBeanRegistrar.getInstance().registerMBean(mbean, "CacheController",
+                            "CRLCacheController");
+                }
+            }
+        }
+    }
+
+    /**
+     * This method is needed by the cache Manager to go through the cache entries to remove
+     * invalid values or to remove LRU cache values if the cache has reached its max size.
+     *
+     * @return next cache value of the cache.
+     */
+    public synchronized ManageableCacheValue getNextCacheValue() {
+        //changes to the map are reflected on the keySet. And its iterator is weakly consistent.
+        // so will never throw concurrent modification exception.
+        if (iterator.hasNext()) {
+            return hashMap.get(iterator.next().getKey());
+        } else {
+            resetIterator();
+            return null;
+        }
+    }
+
+    /**
+     * To get the current cache size (size of the hash map).
+     */
+    public synchronized int getCacheSize() {
+        return hashMap.size();
+    }
+
+    public void resetIterator() {
+        iterator = hashMap.entrySet().iterator();
+    }
+
+    private synchronized void replaceNewCacheValue(CRLCacheValue cacheValue) {
+        //If someone has updated with the new value before current Thread.
+        if (cacheValue.isValid()) {
+            return;
+        }
+
+        try {
+            String crlUrl = cacheValue.crlUrl;
+            X509CRL x509CRL = crlVerifier.downloadCRLFromWeb(crlUrl);
+            this.setCacheValue(crlUrl, x509CRL);
+        } catch (Exception e) {
+            log.debug("Cant replace old CacheValue with new CacheValue. So remove", e);
+            //If cant be replaced remove.
+            cacheValue.removeThisCacheValue();
+        }
+    }
+
+    public synchronized X509CRL getCacheValue(String crlUrl) {
+        CRLCacheValue cacheValue = hashMap.get(crlUrl);
+        if (cacheValue != null) {
+            //If who ever gets this cache value before Cache manager task found its invalid,
+            // update it and get the new value.
+            if (!cacheValue.isValid()) {
+                cacheValue.updateCacheWithNewValue();
+                CRLCacheValue crlCacheValue = hashMap.get(crlUrl);
+                return (crlCacheValue != null ? crlCacheValue.getValue() : null);
+            }
+
+            return cacheValue.getValue();
+        } else
+            return null;
+    }
+
+    public synchronized void setCacheValue(String crlUrl, X509CRL crl) {
+        CRLCacheValue cacheValue = new CRLCacheValue(crlUrl, crl);
+        if (log.isDebugEnabled()) {
+            log.debug("Before set- HashMap size " + hashMap.size());
+        }
+        hashMap.put(crlUrl, cacheValue);
+        if (log.isDebugEnabled()) {
+            log.debug("After set - HashMap size " + hashMap.size());
+        }
+    }
+
+    public synchronized void removeCacheValue(String crlUrl) {
+        if (log.isDebugEnabled()) {
+            log.debug("Before remove - HashMap size " + hashMap.size());
+        }
+        hashMap.remove(crlUrl);
+        if (log.isDebugEnabled()) {
+            log.debug("After remove - HashMap size " + hashMap.size());
+        }
+
+    }
+
+    /**
+     * This is the wrapper class of the actual cache value which is a X509CRL.
+     */
+    private class CRLCacheValue implements ManageableCacheValue {
+
+        private String crlUrl;
+        private X509CRL crl;
+        private long timeStamp = System.currentTimeMillis();
+
+        public CRLCacheValue(String crlUrl, X509CRL crl) {
+            this.crlUrl = crlUrl;
+            this.crl = crl;
+        }
+
+        public String getKey() {
+            return crlUrl;
+        }
+
+        public X509CRL getValue() {
+            timeStamp = System.currentTimeMillis();
+            return crl;
+        }
+
+        /**
+         * CRL has a validity period. We can reuse a downloaded CRL within that period.
+         */
+        public boolean isValid() {
+            Date today = new Date();
+            Date nextUpdate = crl.getNextUpdate();
+            return nextUpdate != null && nextUpdate.after(today);
+        }
+
+        public long getTimeStamp() {
+            return timeStamp;
+        }
+
+        /**
+         * Used by cacheManager to remove invalid entries.
+         */
+        public void removeThisCacheValue() {
+            removeCacheValue(crlUrl);
+        }
+
+        public void updateCacheWithNewValue() {
+            replaceNewCacheValue(this);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLVerifier.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLVerifier.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/crl/CRLVerifier.java	(revision 1508687)
@@ -0,0 +1,192 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.crl;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.bouncycastle.asn1.ASN1InputStream;
+import org.bouncycastle.asn1.ASN1Primitive;
+import org.bouncycastle.asn1.DERIA5String;
+import org.bouncycastle.asn1.DEROctetString;
+import org.bouncycastle.asn1.x509.*;
+import org.apache.synapse.transport.utils.sslcert.*;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.cert.*;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * This is used to verify a certificate is revoked or not by using the Certificate Revocation
+ * List published by the CA.
+ */
+public class CRLVerifier implements RevocationVerifier {
+
+    private CRLCache cache;
+    private static final Log log = LogFactory.getLog(CRLVerifier.class);
+
+    public CRLVerifier(CRLCache cache) {
+        this.cache = cache;
+    }
+
+    /**
+     * Checks revocation status (Good, Revoked) of the peer certificate.
+     *
+     * @param peerCert   peer certificate
+     * @param issuerCert issuer certificate of the peer. not used currently.
+     * @return revocation status of the peer certificate.
+     * @throws CertificateVerificationException
+     *
+     */
+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)
+            throws CertificateVerificationException {
+
+        List<String> list = getCrlDistributionPoints(peerCert);
+        //check with distributions points in the list one by one. if one fails go to the other.
+        for (String crlUrl : list) {
+            if (log.isDebugEnabled()) {
+                log.debug("Trying to get CRL for URL: " + crlUrl);
+            }
+
+            if (cache != null) {
+                X509CRL x509CRL = cache.getCacheValue(crlUrl);
+                if (x509CRL != null) {
+                    //If cant be casted, we have used the wrong cache.
+                    RevocationStatus status = getRevocationStatus(x509CRL, peerCert);
+                    log.debug("CRL taken from cache....");
+                    return status;
+                }
+            }
+
+            //todo: Do we need to check if URL has the same domain name as issuerCert?
+            try {
+                X509CRL x509CRL = downloadCRLFromWeb(crlUrl);
+                if (x509CRL != null) {
+                    if (cache != null)
+                        cache.setCacheValue(crlUrl, x509CRL);
+                    return getRevocationStatus(x509CRL, peerCert);
+                }
+            } catch (Exception e) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Either the url is bad or cannot build X509CRL. Check with the next " +
+                            "url in the list.", e);
+                }
+            }
+        }
+        throw new CertificateVerificationException("Cannot check revocation status with the " +
+                "certificate");
+    }
+
+    private RevocationStatus getRevocationStatus(X509CRL x509CRL, X509Certificate peerCert) {
+        if (x509CRL.isRevoked(peerCert)) {
+            return RevocationStatus.REVOKED;
+        } else {
+            return RevocationStatus.GOOD;
+        }
+    }
+
+    /**
+     * Downloads CRL from the crlUrl. Does not support HTTPS
+     */
+    protected X509CRL downloadCRLFromWeb(String crlURL)
+            throws IOException, CertificateVerificationException {
+        InputStream crlStream = null;
+        try {
+            URL url = new URL(crlURL);
+            crlStream = url.openStream();
+            CertificateFactory cf = CertificateFactory.getInstance("X.509");
+            return (X509CRL) cf.generateCRL(crlStream);
+        } catch (MalformedURLException e) {
+            throw new CertificateVerificationException("CRL Url is malformed", e);
+        } catch (IOException e) {
+            throw new CertificateVerificationException("Cant reach URI: " + crlURL +
+                    " - only support HTTP", e);
+        } catch (CertificateException e) {
+            throw new CertificateVerificationException(e);
+        } catch (CRLException e) {
+            throw new CertificateVerificationException("Cannot generate X509CRL from the " +
+                    "stream data", e);
+        } finally {
+            if (crlStream != null)
+                crlStream.close();
+        }
+    }
+
+    /**
+     * Extracts all CRL distribution point URLs from the "CRL Distribution Point"
+     * extension in a X.509 certificate. If CRL distribution point extension is
+     * unavailable, returns an empty list.
+     */
+    private List<String> getCrlDistributionPoints(X509Certificate cert)
+            throws CertificateVerificationException {
+
+        //Gets the DER-encoded OCTET string for the extension value for CRLDistributionPoints
+        byte[] crlDPExtensionValue = cert.getExtensionValue(
+                X509Extensions.CRLDistributionPoints.getId());
+        if (crlDPExtensionValue == null)
+            throw new CertificateVerificationException("Certificate doesn't have CRL " +
+                    "distribution points");
+        //crlDPExtensionValue is encoded in ASN.1 format.
+        ASN1InputStream asn1In = new ASN1InputStream(crlDPExtensionValue);
+        // DER (Distinguished Encoding Rules) is one of ASN.1 encoding rules defined in ITU-T X.690,
+        // 2002, specification. ASN.1 encoding rules can be used to encode any data object into a
+        // binary file. Read the object in octets.
+        CRLDistPoint distPoint;
+        try {
+            DEROctetString crlDEROctetString = (DEROctetString) asn1In.readObject();
+            //Get Input stream in octets
+            ASN1InputStream asn1InOctets = new ASN1InputStream(crlDEROctetString.getOctets());
+            ASN1Primitive asn1Primitive = asn1InOctets.readObject();
+            distPoint = CRLDistPoint.getInstance(asn1Primitive);
+        } catch (IOException e) {
+            throw new CertificateVerificationException("Cannot read certificate to get CRL urls", e);
+        }
+
+        List<String> crlUrls = new ArrayList<String>();
+        //Loop through ASN1Encodable DistributionPoints
+        for (DistributionPoint dp : distPoint.getDistributionPoints()) {
+            //get ASN1Encodable DistributionPointName
+            DistributionPointName dpn = dp.getDistributionPoint();
+            if (dpn != null && dpn.getType() == DistributionPointName.FULL_NAME) {
+                //Create ASN1Encodable General Names
+                GeneralName[] genNames = GeneralNames.getInstance(dpn.getName()).getNames();
+                // Look for a URI
+                //todo: May be able to check for OCSP url specifically.
+                for (GeneralName genName : genNames) {
+                    if (genName.getTagNo() == GeneralName.uniformResourceIdentifier) {
+                        //DERIA5String contains an ascii string.
+                        //A IA5String is a restricted character string type in the ASN.1 notation
+                        String url = DERIA5String.getInstance(genName.getName()).getString().trim();
+                        crlUrls.add(url);
+                    }
+                }
+            }
+        }
+
+        if (crlUrls.isEmpty()) {
+            throw new CertificateVerificationException("Cant get CRL urls from certificate");
+        }
+
+        return crlUrls;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCache.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCache.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCache.java	(revision 1508687)
@@ -0,0 +1,32 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.cache;
+
+/**
+ * A cache which needs to be managed by CacheManager needs to implement this interface.
+ */
+public interface ManageableCache {
+
+    public ManageableCacheValue getNextCacheValue();
+
+    public int getCacheSize();
+
+    public void resetIterator();
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheController.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheController.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheController.java	(revision 1508687)
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.cache;
+
+public class CacheController implements CacheControllerMBean{
+
+    private ManageableCache cache;
+    private CacheManager cacheManager;
+
+    public CacheController(ManageableCache cache, CacheManager cacheManager){
+        this.cache = cache;
+        this.cacheManager = cacheManager;
+    }
+
+    public boolean stopCacheManager() {
+        return cacheManager.stop();
+    }
+
+    public boolean wakeUpCacheManager() {
+        return cacheManager.wakeUpNow();
+    }
+
+    public boolean changeCacheManagerDelayMins(int delay){
+        return cacheManager.changeDelay(delay);
+    }
+
+    public boolean isCacheManagerRunning() {
+        return cacheManager.isRunning();
+    }
+
+    public int getCacheSize() {
+        return cache.getCacheSize();
+    }
+
+    public int getCacheManagerDelayMins(){
+        return cacheManager.getDelay();
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheControllerMBean.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheControllerMBean.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheControllerMBean.java	(revision 1508687)
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.cache;
+
+public interface CacheControllerMBean {
+
+    /**
+     * Gracefully stops a cacheManager scheduled thread.
+     * @return true if successfully stopped. False otherwise.
+     */
+    public boolean stopCacheManager();
+
+    /**
+     * Wakes up a stopped cacheManager thread.
+     * @return true if cacheManager is waken up. False otherwise.
+     */
+    public boolean wakeUpCacheManager();
+
+    /**
+     * Changes cacheManager task scheduled period.
+     * @param delay Delay which cacheManager thread waits to start its task again.
+     * @return true if successfully changed delay. False otherwise.
+     */
+    public boolean changeCacheManagerDelayMins(int delay);
+
+    /**
+     * @return true if CacheManager is running. False if its stopped.
+     */
+    public boolean isCacheManagerRunning();
+
+    /**
+     * @return Number of cacheEntries in the cache.
+     */
+    public int getCacheSize();
+
+    /**
+     * @return cacheManager delay in minutes.
+     */
+    public int getCacheManagerDelayMins();
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCacheValue.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCacheValue.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/ManageableCacheValue.java	(revision 1508687)
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.cache;
+
+/**
+ * A cache which needs to be managed by a CacheManager should have values which implement
+ * this interface.
+ */
+public interface ManageableCacheValue {
+
+    //To remove invalid entries from the cache.
+    public boolean isValid();
+
+    //To decide LRU value to replace.
+    public long getTimeStamp();
+
+    public void removeThisCacheValue();
+
+    public void updateCacheWithNewValue();
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheManager.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheManager.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/cache/CacheManager.java	(revision 1508687)
@@ -0,0 +1,233 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.cache;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.utils.sslcert.Constants;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Cache Manager takes care of and maintains an LRU cache which implements ManageableCache Interface.
+ * Delay should be configured such that cacheManager is not too much involved with the cache,
+ * but manages it optimally.
+ */
+
+public class CacheManager {
+
+    private static final Log log = LogFactory.getLog(CacheManager.class);
+
+    private final boolean DO_NOT_INTERRUPT_IF_RUNNING = false;
+    private ScheduledExecutorService scheduler;
+    private ScheduledFuture scheduledFuture = null;
+    private ManageableCache cache;
+    private int cacheMaxSize;
+    private int delay;
+    private CacheManagingTask cacheManagingTask;
+
+    /**
+     * A new cacheManager will be started on the given ManageableCache object.
+     *
+     * @param cache        a Manageable Cache which could be managed by this cache manager.
+     * @param cacheMaxSize Maximum size of the cache. If the cache exceeds this size, LRU values
+     *                     will be removed
+     */
+    public CacheManager(ManageableCache cache, int cacheMaxSize, int delay) {
+        int NUM_THREADS = 1;
+        scheduler = Executors.newScheduledThreadPool(NUM_THREADS);
+        this.cache = cache;
+        this.cacheMaxSize = cacheMaxSize;
+        this.cacheManagingTask = new CacheManagingTask();
+        this.delay = delay;
+        start();
+    }
+
+    /**
+     * To Start the CacheManager. Should be called only once per CacheManager so called in
+     * constructor. CacheManager will run its scheduled task every "delay" number of minutes.
+     */
+    private boolean start() {
+        if(scheduledFuture == null || (scheduledFuture.isCancelled())) {
+            scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask,
+                    delay, delay, TimeUnit.MINUTES);
+            log.info(cache.getClass().getSimpleName()+" Cache Manager Started");
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * To wake cacheManager up at will. If this method is called while its task is running, it
+     * will run its task again soon after its done. CacheManagerTask will be rescheduled as before.
+     * @return true if successfully waken up. false otherwise.
+     */
+    public boolean wakeUpNow(){
+        if(scheduledFuture !=null) {
+            if(!scheduledFuture.isCancelled()) {
+                scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);
+            }
+            scheduledFuture = scheduler.scheduleWithFixedDelay(cacheManagingTask,
+                    0, delay,TimeUnit.MINUTES);
+            log.info(cache.getClass().getSimpleName()+" Cache Manager Wakened Up.....");
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Change the cacheManager delay (schedule period) to given value.
+     * @param delay new delay to which the cacheManager schedule period should change.
+     * @return true if successfully changed. false otherwise.
+     * @throws IllegalArgumentException if given delay is not between the allowed limit.
+     */
+    public boolean changeDelay(int delay) throws IllegalArgumentException {
+        int min = Constants.CACHE_MIN_DELAY_MINS;
+        int max = Constants.CACHE_MAX_DELAY_MINS;
+        if(delay < min || delay > max) {
+            throw new IllegalArgumentException("Delay time should should be between " + min +
+                    " and " + max + " minutes");
+        }
+        this.delay = delay;
+        return wakeUpNow();
+    }
+
+    public int getDelay(){
+        return delay;
+    }
+
+    /**
+     * Gracefully stop cacheManager.
+     */
+    public boolean stop(){
+        if(scheduledFuture !=null && !scheduledFuture.isCancelled()){
+            scheduledFuture.cancel(DO_NOT_INTERRUPT_IF_RUNNING);
+            log.info(cache.getClass().getSimpleName()+" Cache Manager Stopped.....");
+            return true;
+        }
+        return false;
+    }
+
+    public boolean isRunning() {
+        return !scheduledFuture.isCancelled();
+    }
+
+    /**
+     * This is the Scheduled Task the CacheManager uses in order to remove invalid cache values and
+     * to remove LRU values if the cache reaches cacheMaxSize.
+     */
+    private class CacheManagingTask implements Runnable {
+
+        public void run() {
+            long start = System.currentTimeMillis();
+            if (log.isDebugEnabled()) {
+                log.debug(cache.getClass().getSimpleName() + " Cache Manager Task Started.");
+            }
+
+            ManageableCacheValue nextCacheValue;
+            //cache.getCacheSize() can vary when new entries are added. So get cache size at this point
+            int cacheSize = cache.getCacheSize();
+            int numberToRemove = (cacheSize>cacheMaxSize)?  cacheSize - cacheMaxSize: 0;
+
+            List<ManageableCacheValue> entriesToRemove = new ArrayList<ManageableCacheValue>();
+            LRUEntryCollector lruEntryCollector = new LRUEntryCollector(entriesToRemove, numberToRemove);
+
+            //Start looking at cache entries from the beginning.
+            cache.resetIterator();
+            //Iteration through the cache entries.
+            while ((cacheSize--)>0) {
+
+                nextCacheValue = cache.getNextCacheValue();
+                if (nextCacheValue == null) {
+                    log.debug("Cache manager iteration through Cache values done");
+                    break;
+                }
+
+                //Updating invalid cache values
+                if (!nextCacheValue.isValid()) {
+                    log.debug("Updating Invalid Cache Value by Manager");
+                    nextCacheValue.updateCacheWithNewValue();
+                }
+
+                //There are LRU entries to be removed since cacheSize > maxCacheSize. So collect them.
+                if(numberToRemove>0) {
+                    lruEntryCollector.collectEntriesToRemove(nextCacheValue);
+                }
+            }
+
+            //LRU entries removing
+            for(ManageableCacheValue oldCacheValue: entriesToRemove) {
+                log.debug("Removing LRU value from cache");
+                oldCacheValue.removeThisCacheValue();
+            }
+
+            if (log.isDebugEnabled()) {
+                log.debug(cache.getClass().getSimpleName()+" Cache Manager Task Done. Took " +
+                        (System.currentTimeMillis() - start) + " ms.");
+            }
+        }
+
+        private class LRUEntryCollector {
+
+            private List<ManageableCacheValue> entriesToRemove;
+            private int listMaxSize;
+
+            LRUEntryCollector(List<ManageableCacheValue> entriesToRemove, int numberToRemove){
+                this.entriesToRemove = entriesToRemove;
+                this.listMaxSize = numberToRemove;
+            }
+
+            /**
+             * This method collects the listMaxSize number of LRU values from the Cache. This is
+             * called for all the entries in the cache. But only listMaxSize number of LRU entries
+             * will be collected in entriesToRemove list. These collected values will be removed from
+             * the cache. This uses a part of the Logic in Insertion Sort.
+             *
+             * @param value to be collected if LRU.
+             */
+            private void collectEntriesToRemove(ManageableCacheValue value) {
+
+                entriesToRemove.add(value);
+                int i = entriesToRemove.size()-1;
+
+                for(; i>0 && (value.getTimeStamp() < entriesToRemove.get(i-1).getTimeStamp()); i--) {
+                    entriesToRemove.remove(i);
+                    entriesToRemove.add(i,(entriesToRemove.get(i-1)));
+                }
+                entriesToRemove.remove(i);
+                entriesToRemove.add(i,value);
+                /**
+                 * First entry in the list will be the oldest. Last will be the earliest in the list.
+                 * So remove the earliest since we need to collect the old (LRU) values to remove
+                 * from cache later
+                 */
+                if(entriesToRemove.size() > listMaxSize) {
+                    entriesToRemove.remove(entriesToRemove.size() -1);
+                }
+            }
+
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationException.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationException.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/CertificateVerificationException.java	(revision 1508687)
@@ -0,0 +1,35 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+public class CertificateVerificationException extends Exception {
+
+    public CertificateVerificationException(String message) {
+        super(message);
+    }
+
+    public CertificateVerificationException(Throwable throwable) {
+        super(throwable);
+    }
+
+    public CertificateVerificationException(String message, Throwable throwable) {
+        super(message, throwable);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPVerifier.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPVerifier.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPVerifier.java	(revision 1508687)
@@ -0,0 +1,252 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.ocsp;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.bouncycastle.asn1.*;
+import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;
+import org.bouncycastle.asn1.x509.*;
+import org.bouncycastle.ocsp.*;
+import org.apache.synapse.transport.utils.sslcert.*;
+
+import java.io.*;
+import java.math.BigInteger;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.security.Security;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+
+/**
+ * Used to check if a Certificate is revoked or not by its CA using Online Certificate
+ * Status Protocol (OCSP).
+ */
+public class OCSPVerifier implements RevocationVerifier {
+
+    private OCSPCache cache;
+    private static final Log log = LogFactory.getLog(OCSPVerifier.class);
+
+    public OCSPVerifier(OCSPCache cache) {
+        this.cache = cache;
+    }
+
+    /**
+     * Gets the revocation status (Good, Revoked or Unknown) of the given peer certificate.
+     *
+     * @param peerCert   The certificate we want to check if revoked.
+     * @param issuerCert Needed to create OCSP request.
+     * @return revocation status of the peer certificate.
+     * @throws CertificateVerificationException
+     *
+     */
+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)
+            throws CertificateVerificationException {
+
+        //check cache
+        if (cache != null) {
+            SingleResp resp = cache.getCacheValue(peerCert.getSerialNumber());
+            if (resp != null) {
+                //If cant be casted, we have used the wrong cache.
+                RevocationStatus status = getRevocationStatus(resp);
+                log.debug("OCSP response taken from cache....");
+                return status;
+            }
+        }
+
+        OCSPReq request = generateOCSPRequest(issuerCert, peerCert.getSerialNumber());
+        //This list will sometimes have non ocsp urls as well.
+        List<String> locations = getAIALocations(peerCert);
+
+        for (String serviceUrl : locations) {
+
+            SingleResp[] responses;
+            try {
+                OCSPResp ocspResponse = getOCSPResponce(serviceUrl, request);
+                if (OCSPRespStatus.SUCCESSFUL != ocspResponse.getStatus()) {
+                    continue; // Server didn't give the response right.
+                }
+
+                BasicOCSPResp basicResponse = (BasicOCSPResp) ocspResponse.getResponseObject();
+                responses = (basicResponse == null) ? null : basicResponse.getResponses();
+                //todo use the super exception
+            } catch (Exception e) {
+                continue;
+            }
+
+            if (responses != null && responses.length == 1) {
+                SingleResp resp = responses[0];
+                RevocationStatus status = getRevocationStatus(resp);
+                if (cache != null)
+                    cache.setCacheValue(peerCert.getSerialNumber(), resp, request, serviceUrl);
+                return status;
+            }
+        }
+        throw new CertificateVerificationException("Cant get Revocation Status from OCSP.");
+    }
+
+    private RevocationStatus getRevocationStatus(SingleResp resp) throws CertificateVerificationException {
+        Object status = resp.getCertStatus();
+        if (status == CertificateStatus.GOOD) {
+            return RevocationStatus.GOOD;
+        } else if (status instanceof org.bouncycastle.ocsp.RevokedStatus) {
+            return RevocationStatus.REVOKED;
+        } else if (status instanceof org.bouncycastle.ocsp.UnknownStatus) {
+            return RevocationStatus.UNKNOWN;
+        }
+        throw new CertificateVerificationException("Cant recognize Certificate Status");
+    }
+
+    /**
+     * Gets an ASN.1 encoded OCSP response (as defined in RFC 2560) from the given service URL. Currently supports
+     * only HTTP.
+     *
+     * @param serviceUrl URL of the OCSP endpoint.
+     * @param request    an OCSP request object.
+     * @return OCSP response encoded in ASN.1 structure.
+     * @throws CertificateVerificationException
+     *
+     */
+    protected OCSPResp getOCSPResponce(String serviceUrl, OCSPReq request) throws CertificateVerificationException {
+
+        try {
+            //Todo: Use http client.
+            byte[] array = request.getEncoded();
+            if (serviceUrl.startsWith("http")) {
+                HttpURLConnection con;
+                URL url = new URL(serviceUrl);
+                con = (HttpURLConnection) url.openConnection();
+                con.setRequestProperty("Content-Type", "application/ocsp-request");
+                con.setRequestProperty("Accept", "application/ocsp-response");
+                con.setDoOutput(true);
+                OutputStream out = con.getOutputStream();
+                DataOutputStream dataOut = new DataOutputStream(new BufferedOutputStream(out));
+                dataOut.write(array);
+
+                dataOut.flush();
+                dataOut.close();
+
+                //Check errors in response:
+                if (con.getResponseCode() / 100 != 2) {
+                    throw new CertificateVerificationException("Error getting ocsp response." +
+                            "Response code is " + con.getResponseCode());
+                }
+
+                //Get Response
+                InputStream in = (InputStream) con.getContent();
+                return new OCSPResp(in);
+            } else {
+                throw new CertificateVerificationException("Only http is supported for ocsp calls");
+            }
+        } catch (IOException e) {
+            throw new CertificateVerificationException("Cannot get ocspResponse from url: " + serviceUrl, e);
+        }
+    }
+
+    /**
+     * This method generates an OCSP Request to be sent to an OCSP endpoint.
+     *
+     * @param issuerCert   is the Certificate of the Issuer of the peer certificate we are interested in.
+     * @param serialNumber of the peer certificate.
+     * @return generated OCSP request.
+     * @throws CertificateVerificationException
+     */
+    private OCSPReq generateOCSPRequest(X509Certificate issuerCert, BigInteger serialNumber)
+            throws CertificateVerificationException {
+
+        //TODO: Have to check if this is OK with synapse implementation.
+        //Add provider BC
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        try {
+            //  CertID structure is used to uniquely identify certificates that are the subject of
+            // an OCSP request or response and has an ASN.1 definition. CertID structure is defined in RFC 2560
+            CertificateID id = new CertificateID(CertificateID.HASH_SHA1, issuerCert, serialNumber);
+
+            // basic request generation with nonce
+            OCSPReqGenerator generator = new OCSPReqGenerator();
+            generator.addRequest(id);
+
+            // create details for nonce extension. The nonce extension is used to bind
+            // a request to a response to prevent replay attacks. As the name implies,
+            // the nonce value is something that the client should only use once within a reasonably small period.
+            BigInteger nonce = BigInteger.valueOf(System.currentTimeMillis());
+            Vector<ASN1ObjectIdentifier> objectIdentifiers = new Vector<ASN1ObjectIdentifier>();
+            Vector<X509Extension> values = new Vector<X509Extension>();
+
+            //to create the request Extension
+            objectIdentifiers.add(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);
+            values.add(new X509Extension(false, new DEROctetString(nonce.toByteArray())));
+            generator.setRequestExtensions(new X509Extensions(objectIdentifiers, values));
+
+            return generator.generate();
+        } catch (OCSPException e) {
+            throw new CertificateVerificationException("Cannot generate OSCP Request with the given certificate", e);
+        }
+    }
+
+    /**
+     * Authority Information Access (AIA) is a non-critical extension in an X509 Certificate. This contains the
+     * URL of the OCSP endpoint if one is available.
+     * TODO: This might contain non OCSP urls as well. Handle this.
+     *
+     * @param cert is the certificate
+     * @return a lit of URLs in AIA extension of the certificate which will hopefully contain an OCSP endpoint.
+     * @throws CertificateVerificationException
+     *
+     */
+    private List<String> getAIALocations(X509Certificate cert) throws CertificateVerificationException {
+
+        //Gets the DER-encoded OCTET string for the extension value for Authority information access Points
+        byte[] aiaExtensionValue = cert.getExtensionValue(X509Extensions.AuthorityInfoAccess.getId());
+        if (aiaExtensionValue == null)
+            throw new CertificateVerificationException("Certificate Doesnt have Authority Information Access points");
+        //might have to pass an ByteArrayInputStream(aiaExtensionValue)
+        ASN1InputStream asn1In = new ASN1InputStream(aiaExtensionValue);
+        AuthorityInformationAccess authorityInformationAccess;
+
+        try {
+            DEROctetString aiaDEROctetString = (DEROctetString) (asn1In.readObject());
+            ASN1InputStream asn1Inoctets = new ASN1InputStream(aiaDEROctetString.getOctets());
+            ASN1Sequence aiaASN1Sequence = (ASN1Sequence) asn1Inoctets.readObject();
+            authorityInformationAccess = AuthorityInformationAccess.getInstance(aiaASN1Sequence);//new AuthorityInformationAccess(aiaASN1Sequence);
+        } catch (IOException e) {
+            throw new CertificateVerificationException("Cannot read certificate to get OSCP urls", e);
+        }
+
+        List<String> ocspUrlList = new ArrayList<String>();
+        AccessDescription[] accessDescriptions = authorityInformationAccess.getAccessDescriptions();
+        for (AccessDescription accessDescription : accessDescriptions) {
+
+            GeneralName gn = accessDescription.getAccessLocation();
+            if (gn.getTagNo() == GeneralName.uniformResourceIdentifier) {
+                DERIA5String str = DERIA5String.getInstance(gn.getName());
+                String accessLocation = str.getString();
+                ocspUrlList.add(accessLocation);
+            }
+        }
+        if(ocspUrlList.isEmpty())
+            throw new CertificateVerificationException("Cant get OCSP urls from certificate");
+
+        return ocspUrlList;
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPCache.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPCache.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/ocsp/OCSPCache.java	(revision 1508687)
@@ -0,0 +1,231 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.ocsp;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.commons.jmx.MBeanRegistrar;
+import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
+import org.apache.synapse.transport.utils.sslcert.cache.CacheController;
+import org.apache.synapse.transport.utils.sslcert.cache.CacheManager;
+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCache;
+import org.apache.synapse.transport.utils.sslcert.cache.ManageableCacheValue;
+import org.bouncycastle.ocsp.*;
+
+import java.math.BigInteger;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * This is a cache to store OCSP responses against Certificate Serial Number since an OCSP
+ * response depends on the certificate. This is a singleton since more than one cache of this
+ * kind should not be allowed. This cache can be shared by many transports which need SSL
+ * validation through OCSP.
+ */
+public class OCSPCache implements ManageableCache {
+
+    private static final Log log = LogFactory.getLog(OCSPCache.class);
+
+    private static final OCSPCache cache = new OCSPCache();
+    private final Map<BigInteger,OCSPCacheValue> hashMap;
+    private Iterator<Map.Entry<BigInteger,OCSPCacheValue>> iterator;
+    private volatile CacheManager cacheManager;
+    private final OCSPVerifier ocspVerifier;
+
+    private OCSPCache() {
+        this.hashMap = new ConcurrentHashMap<BigInteger, OCSPCacheValue>();
+        this.iterator = hashMap.entrySet().iterator();
+        this.ocspVerifier = new OCSPVerifier(null);
+    }
+
+    public static OCSPCache getCache() {
+        return cache;
+    }
+
+    /**
+     * This lazy initializes the Cache with a CacheManager. If this method is not called, a cache manager will not be used.
+     * @param size max size of the cache
+     * @param delay defines how frequently the CacheManager will be started
+     */
+    public void init(int size, int delay) {
+        if (cacheManager == null) {
+            synchronized (OCSPCache.class) {
+                if (cacheManager == null) {
+                    cacheManager = new CacheManager(cache, size, delay);
+                    CacheController mbean = new CacheController(cache,cacheManager);
+                    MBeanRegistrar.getInstance().registerMBean(mbean, "CacheController", "OCSPCacheController");
+                }
+            }
+        }
+    }
+
+    /**
+     * This method is needed by the cache Manager to go through the cache entries to remove invalid values or
+     * to remove LRU cache values if the cache has reached its max size.
+     * Todo: Can move to an abstract class.
+     * @return next cache value of the cache.
+     */
+    public ManageableCacheValue getNextCacheValue() {
+        //Changes to the hash map are reflected on the keySet. And its iterator is weakly consistent. so will never
+        //throw concurrent modification exception.
+        if (iterator.hasNext()) {
+            return hashMap.get(iterator.next().getKey());
+        } else {
+            resetIterator();
+            return null;
+        }
+    }
+
+    /**
+     * @return the current cache size (size of the hash map)
+     */
+    public int getCacheSize() {
+        return hashMap.size();
+    }
+
+    public void resetIterator(){
+        iterator = hashMap.entrySet().iterator();
+    }
+
+    // This has to be synchronized coz several threads will try to replace cache value
+    // (cacheManager and Reactor thread)
+    private synchronized void replaceNewCacheValue(OCSPCacheValue cacheValue){
+        //If someone has updated with the new value before current Thread.
+        if (cacheValue.isValid()) {
+            return;
+        }
+
+        try {
+            String serviceUrl = cacheValue.serviceUrl;
+            OCSPReq request = cacheValue.request;
+            OCSPResp response= ocspVerifier.getOCSPResponce(serviceUrl, request);
+
+            if (OCSPRespStatus.SUCCESSFUL != response.getStatus())
+                throw new CertificateVerificationException("OCSP response status not SUCCESSFUL");
+
+            BasicOCSPResp basicResponse = (BasicOCSPResp) response.getResponseObject();
+            SingleResp[] responses = (basicResponse == null) ? null : basicResponse.getResponses();
+
+            if (responses == null)
+                throw new CertificateVerificationException("Cant get OCSP response");
+
+            SingleResp resp = responses[0];
+            this.setCacheValue(cacheValue.serialNumber, resp, request, serviceUrl);
+
+        } catch (Exception e){
+            log.debug("Cant replace old CacheValue with new CacheValue. So remove", e);
+            //If cant be replaced remove.
+            cacheValue.removeThisCacheValue();
+        }
+    }
+
+    public synchronized SingleResp getCacheValue(BigInteger serialNumber) {
+        OCSPCacheValue cacheValue = hashMap.get(serialNumber);
+        if(cacheValue != null) {
+            //If who ever gets this cache value before Cache manager task found its invalid, update it and get the
+            // new value.
+            if (!cacheValue.isValid()) {
+                cacheValue.updateCacheWithNewValue();
+                OCSPCacheValue ocspCacheValue = hashMap.get(serialNumber);
+                return (ocspCacheValue!=null? ocspCacheValue.getValue(): null);
+            }
+
+            return cacheValue.getValue();
+        }
+        else
+            return null;
+    }
+
+    public synchronized void setCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {
+        OCSPCacheValue cacheValue = new OCSPCacheValue(serialNumber, singleResp, request, serviceUrl);
+        if (log.isDebugEnabled()) {
+            log.debug("Before set - HashMap size " + hashMap.size());
+        }
+        hashMap.put(serialNumber, cacheValue);
+        if (log.isDebugEnabled()) {
+            log.debug("After set - HashMap size " + hashMap.size());
+        }
+    }
+
+    public synchronized void removeCacheValue(BigInteger serialNumber) {
+        if (log.isDebugEnabled()) {
+            log.debug("Before remove - HashMap size " + hashMap.size());
+        }
+        hashMap.remove(serialNumber);
+        if (log.isDebugEnabled()) {
+            log.debug("After remove - HashMap size " + hashMap.size());
+        }
+    }
+
+    /**
+     * This is the wrapper class of the actual cache value which is a SingleResp.
+     */
+    private class OCSPCacheValue implements ManageableCacheValue {
+
+        private BigInteger serialNumber;
+        private SingleResp singleResp;
+        private OCSPReq request;
+        private String serviceUrl;
+        private long timeStamp = System.currentTimeMillis();
+
+        public OCSPCacheValue(BigInteger serialNumber, SingleResp singleResp, OCSPReq request, String serviceUrl) {
+            this.serialNumber = serialNumber;
+            this.singleResp = singleResp;
+            //request and serviceUrl are needed to update the cache with new values.
+            this.request = request;
+            this.serviceUrl = serviceUrl;
+        }
+
+        public BigInteger getKey() {
+            return serialNumber;
+        }
+
+        public SingleResp getValue() {
+            timeStamp = System.currentTimeMillis();
+            return singleResp;
+        }
+
+        /**
+         * An OCSP response is valid during its validity period.
+         */
+        public boolean isValid() {
+            Date now = new Date();
+            Date nextUpdate = singleResp.getNextUpdate();
+            return nextUpdate != null && nextUpdate.after(now);
+        }
+
+        public long getTimeStamp() {
+            return timeStamp;
+        }
+
+        /**
+         * Used by cacheManager to remove invalid entries.
+         */
+        public void removeThisCacheValue() {
+            removeCacheValue(serialNumber);
+        }
+
+        public void updateCacheWithNewValue() {
+            replaceNewCacheValue(this);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerifier.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerifier.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerifier.java	(revision 1508687)
@@ -0,0 +1,31 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+import java.security.cert.X509Certificate;
+
+/**
+ * All the revocation verifiers should implement this interface.
+ */
+public interface RevocationVerifier {
+
+    public RevocationStatus checkRevocationStatus(X509Certificate peerCert, X509Certificate issuerCert)
+            throws CertificateVerificationException;
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationManager.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationManager.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationManager.java	(revision 1508687)
@@ -0,0 +1,124 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;
+import org.apache.synapse.transport.utils.sslcert.pathvalidation.CertificatePathValidator;
+
+import java.io.ByteArrayInputStream;
+import java.security.cert.X509Certificate;
+
+/**
+ * Manager class responsible for verifying certificates. This class will use the available
+ * verifiers according to a predefined policy.
+ */
+public class RevocationVerificationManager {
+
+    private int cacheSize = Constants.CACHE_DEFAULT_ALLOCATED_SIZE;
+    private int cacheDelayMins = Constants.CACHE_DEFAULT_DELAY_MINS;
+    private static final Log log = LogFactory.getLog(RevocationVerificationManager.class);
+
+    public RevocationVerificationManager(Integer cacheAllocatedSize, Integer cacheDelayMins) {
+
+        if (cacheAllocatedSize != null && cacheAllocatedSize > Constants.CACHE_MIN_ALLOCATED_SIZE
+                && cacheAllocatedSize < Constants.CACHE_MAX_ALLOCATED_SIZE) {
+            this.cacheSize = cacheAllocatedSize;
+        }
+        if (cacheDelayMins != null && cacheDelayMins > Constants.CACHE_MIN_DELAY_MINS
+                && cacheDelayMins < Constants.CACHE_MAX_DELAY_MINS) {
+            this.cacheDelayMins = cacheDelayMins;
+        }
+    }
+
+    /**
+     * This method first tries to verify the given certificate chain using OCSP since OCSP
+     * verification is faster. If that fails it tries to do the verification using CRL.
+     *
+     * @param peerCertificates  javax.security.cert.X509Certificate[] array of peer
+     *                          certificate chain from peer/client.
+     * @throws CertificateVerificationException
+     */
+    public void verifyRevocationStatus(javax.security.cert.X509Certificate[] peerCertificates)
+            throws CertificateVerificationException {
+
+        X509Certificate[] convertedCertificates = convert(peerCertificates);
+
+        long start = System.currentTimeMillis();
+
+        OCSPCache ocspCache = OCSPCache.getCache();
+        ocspCache.init(cacheSize, cacheDelayMins);
+        CRLCache crlCache = CRLCache.getCache();
+        crlCache.init(cacheSize, cacheDelayMins);
+
+        RevocationVerifier[] verifiers = {new OCSPVerifier(ocspCache), new CRLVerifier(crlCache)};
+
+        for (RevocationVerifier verifier : verifiers) {
+            try {
+                CertificatePathValidator pathValidator = new CertificatePathValidator(
+                        convertedCertificates, verifier);
+                pathValidator.validatePath();
+                log.info("Path verification Successful with " + verifier.getClass().getSimpleName() +
+                        ". Took " + (System.currentTimeMillis() - start) + " ms.");
+                return;
+            } catch (Exception e) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Certificate verification with " + verifier.getClass().getSimpleName() +
+                            " failed. ", e);
+                }
+            }
+        }
+        throw new CertificateVerificationException("Path Verification Failed for both OCSP and CRL");
+    }
+
+    /**
+     * @param certs array of javax.security.cert.X509Certificate[] s.
+     * @return the converted array of java.security.cert.X509Certificate[] s.
+     * @throws CertificateVerificationException
+     */
+    private X509Certificate[] convert(javax.security.cert.X509Certificate[] certs)
+            throws CertificateVerificationException {
+        X509Certificate[] certChain = new X509Certificate[certs.length];
+        Throwable exceptionThrown;
+        for (int i = 0; i < certs.length; i++) {
+            try {
+                byte[] encoded = certs[i].getEncoded();
+                ByteArrayInputStream bis = new ByteArrayInputStream(encoded);
+                java.security.cert.CertificateFactory cf
+                        = java.security.cert.CertificateFactory.getInstance("X.509");
+                certChain[i]=((X509Certificate)cf.generateCertificate(bis));
+                continue;
+            } catch (java.security.cert.CertificateEncodingException e) {
+                exceptionThrown = e;
+            } catch (javax.security.cert.CertificateEncodingException e) {
+                exceptionThrown = e;
+            } catch (java.security.cert.CertificateException e) {
+                exceptionThrown = e;
+            }
+            throw new CertificateVerificationException("Cant Convert certificates from " +
+                    "javax to java", exceptionThrown);
+        }
+        return certChain;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/PathChecker.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/PathChecker.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/PathChecker.java	(revision 1508687)
@@ -0,0 +1,111 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.pathvalidation;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.utils.sslcert.*;
+
+import java.security.cert.CertPathValidatorException;
+import java.security.cert.Certificate;
+import java.security.cert.PKIXCertPathChecker;
+import java.security.cert.X509Certificate;
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * This class is used by CertificatePathValidator to check revocation status of the certificate
+ * chain. Certificates in the chain will be passed to the check(..,..) method one by one.
+ * This is not Thread safe since the process is state full. Should not be shared among threads.
+ */
+public class PathChecker extends PKIXCertPathChecker {
+
+    private X509Certificate[] certChainArray;
+    private RevocationVerifier verifier;
+    private int position;
+    private static final Log log = LogFactory.getLog(PathChecker.class);
+
+    protected PathChecker(X509Certificate[] certChainArray, RevocationVerifier verifier) {
+        this.certChainArray = certChainArray;
+        //initialize position to Root Certificate position.
+        this.position = certChainArray.length - 1;
+        this.verifier = verifier;
+    }
+
+    @Override
+    public void init(boolean forward) throws CertPathValidatorException {
+        if (forward) {
+            throw new CertPathValidatorException("Forward checking is not supported");
+        }
+    }
+
+    /**
+     * Forward checking is not supported. Certificates should be passed from the most trusted CA
+     * certificate to the target certificate. This is the default implementation of the Path
+     * validator used CertPathValidator.getInstance("PKIX", "BC") in CertificatePathValidator;
+     */
+    @Override
+    public boolean isForwardCheckingSupported() {
+        return false;
+    }
+
+    @Override
+    public Set<String> getSupportedExtensions() {
+        return null;
+    }
+
+    /**
+     * Used by CertPathValidator to pass the certificates one by one from the certificate chain.
+     *
+     * @param cert the certificate passed to be checked.
+     * @param unresolvedCritExts not used in this method.
+     * @throws CertPathValidatorException
+     */
+    @Override
+    public void check(Certificate cert,
+                      Collection<String> unresolvedCritExts) throws CertPathValidatorException {
+
+        RevocationStatus status;
+        try {
+            status = verifier.checkRevocationStatus((X509Certificate) cert, nextIssuer());
+            if (log.isDebugEnabled()) {
+                log.debug("Certificate status is: " + status.getMessage());
+            }
+            if (status != RevocationStatus.GOOD) {
+                throw new CertPathValidatorException("Revocation Status is Not Good");
+            }
+        } catch (CertificateVerificationException e) {
+            throw new CertPathValidatorException(e);
+        }
+    }
+
+    /**
+     * @return the immediate issuer certificate of the current certificate which is being checked.
+     *          This is tracked by the position variable
+     */
+    private X509Certificate nextIssuer() {
+        //get immediate issuer
+        if (position > 0) {
+            return certChainArray[position--];
+        } else {
+            throw new ArrayIndexOutOfBoundsException("Certificate Chain Index Out of Bounds");
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/CertificatePathValidator.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/CertificatePathValidator.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/sslcert/pathvalidation/CertificatePathValidator.java	(revision 1508687)
@@ -0,0 +1,105 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.sslcert.pathvalidation;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.utils.sslcert.*;
+
+import java.security.*;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.security.cert.*;
+import java.util.*;
+
+/**
+ * Used to validate the revocation status of a certificate chain acquired from the peer. A
+ * revocation verifier (OCSP or CRL) should be given. Must be used only once when validating
+ * certificate chain for an SSLSession. Create a new instance if need to be reused because the
+ * path validation process is state-full. Not thread safe.
+ */
+public class CertificatePathValidator {
+
+    private PathChecker pathChecker;
+
+    // Certificate Chain with Root CA certificate (eg: peer cert, issuer cert, root cert)
+    List<X509Certificate> fullCertChain;
+    // Certificate Chain without Root CA certificate. (eg: peer cert, issuer cert)
+    List<X509Certificate> certChain;
+    private static final Log log = LogFactory.getLog(CertificatePathValidator.class);
+
+    public CertificatePathValidator(X509Certificate[] certChainArray, RevocationVerifier verifier) {
+        this.pathChecker = new PathChecker(certChainArray, verifier);
+        init(certChainArray);
+    }
+
+    /**
+     * Here revocation status checking is started from one below the root certificate in the
+     * chain (certChain). Since ssl implementation ensures that at least one certificate in the
+     * chain is trusted, we can logically say that the root is trusted.
+     */
+    private void init(X509Certificate[] certChainArray) {
+        X509Certificate[] partCertChainArray = new X509Certificate[certChainArray.length-1];
+        System.arraycopy(certChainArray,0,partCertChainArray,0,partCertChainArray.length);
+        certChain = Arrays.asList(partCertChainArray);
+        fullCertChain = Arrays.asList(certChainArray);
+    }
+
+    /**
+     * Certificate Path Validation process
+     *
+     * @throws CertificateVerificationException
+     *          if validation process fails.
+     */
+    public void validatePath() throws CertificateVerificationException {
+
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        CollectionCertStoreParameters params = new CollectionCertStoreParameters(fullCertChain);
+        try {
+            CertStore store = CertStore.getInstance("Collection", params, "BC");
+
+            // create certificate path
+            CertificateFactory fact = CertificateFactory.getInstance("X.509", "BC");
+
+            CertPath certPath = fact.generateCertPath(certChain);
+            TrustAnchor trustAnchor = new TrustAnchor(fullCertChain.get(fullCertChain.size() - 1),
+                    null);
+            Set<TrustAnchor> trust = Collections.singleton(trustAnchor);
+
+            // perform validation
+            CertPathValidator validator = CertPathValidator.getInstance("PKIX", "BC");
+            PKIXParameters param = new PKIXParameters(trust);
+
+            param.addCertPathChecker(pathChecker);
+            param.setRevocationEnabled(false);
+            param.addCertStore(store);
+            param.setDate(new Date());
+
+            validator.validate(certPath, param);
+
+            log.debug("Certificate path validated");
+        } catch (CertPathValidatorException e) {
+            throw new CertificateVerificationException("Certificate Path Validation failed on " +
+                    "certificate number " + e.getIndex() + ", details: " + e.getMessage(), e);
+        } catch (Exception e) {
+            throw new CertificateVerificationException("Certificate Path Validation failed", e);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/CRLVerifierTest.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/CRLVerifierTest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/CRLVerifierTest.java	(revision 1508687)
@@ -0,0 +1,138 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.utils.sslcert;
+
+import junit.framework.TestCase;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;import org.bouncycastle.asn1.DERObjectIdentifier;
+import org.bouncycastle.asn1.x509.*;
+import org.bouncycastle.x509.X509V2CRLGenerator;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+import org.bouncycastle.x509.extension.AuthorityKeyIdentifierStructure;
+
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.security.*;
+import java.security.cert.X509CRL;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.List;
+
+public class CRLVerifierTest extends TestCase {
+
+    /**
+     * To test CRLVerifier behaviour when a revoked certificate is given, a fake certificate will be created, signed
+     * by a fake root certificate. To make our life easy, the CrlDistributionPoint extension will be extracted from
+     * the real peer certificate in resources directory and copied to the fake certificate as a certificate extension.
+     * So the criDistributionPointURL in the fake certificate will be the same as in the real certificate.
+     * The created X509CRL object will be put to CRLCache against the criDistributionPointURL. Since the crl is in the
+     * cache, there will NOT be a remote call to the CRL server at criDistributionPointURL.
+     * @throws Exception
+     */
+    public void testRevokedCertificate() throws Exception {
+
+        //Add BouncyCastle as Security Provider.
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+
+        Utils utils = new Utils();
+        //Create X509Certificate from the real certificate file in resource folder.
+        X509Certificate realPeerCertificate = utils.getRealPeerCertificate();
+        //Extract crlDistributionPointUrl from the real peer certificate.
+        String crlDistributionPointUrl = getCRLDistributionPointUrl(realPeerCertificate);
+
+        //Create fake CA certificate.
+        KeyPair caKeyPair = utils.generateRSAKeyPair();
+        X509Certificate fakeCACert = utils.generateFakeRootCert(caKeyPair);
+
+        //Create fake peer certificate signed by the fake CA private key. This will be a revoked certificate.
+        KeyPair peerKeyPair = utils.generateRSAKeyPair();
+        BigInteger revokedSerialNumber = BigInteger.valueOf(111);
+        X509Certificate fakeRevokedCertificate = generateFakePeerCert(revokedSerialNumber, peerKeyPair.getPublic(),
+                caKeyPair.getPrivate(), fakeCACert, realPeerCertificate);
+
+        //Create a crl with fakeRevokedCertificate marked as revoked.
+        X509CRL x509CRL = createCRL(fakeCACert, caKeyPair.getPrivate(), revokedSerialNumber);
+
+        CRLCache cache = CRLCache.getCache();
+        cache.init(5, 5);
+        cache.setCacheValue(crlDistributionPointUrl, x509CRL);
+
+        CRLVerifier crlVerifier  = new CRLVerifier(cache);
+        RevocationStatus status = crlVerifier.checkRevocationStatus(fakeRevokedCertificate, null);
+
+        //the fake crl we created will be checked if the fake certificate is revoked. So the status should be REVOKED.
+        assertTrue(status == RevocationStatus.REVOKED);
+    }
+
+    /**
+     * This will use Reflection to call getCrlDistributionPoints() private method in CRLVerifier.
+     * @param certificate is a certificate with a proper CRLDistributionPoints extension.
+     * @return the extracted cRLDistributionPointUrl.
+     * @throws Exception
+     */
+    private String getCRLDistributionPointUrl(X509Certificate certificate) throws Exception {
+
+        CRLVerifier crlVerifier = new CRLVerifier(null);
+        // use reflection since getCrlDistributionPoints() is private.
+        Class<? extends CRLVerifier> crlVerifierClass = crlVerifier.getClass();
+        Method getCrlDistributionPoints = crlVerifierClass.getDeclaredMethod("getCrlDistributionPoints", X509Certificate.class);
+        getCrlDistributionPoints.setAccessible(true);
+
+        //getCrlDistributionPoints(..) returns a list of urls. Get the first one.
+        List<String> distPoints = (List<String>) getCrlDistributionPoints.invoke(crlVerifier, certificate);
+        return distPoints.get(0);
+    }
+
+    /**
+     * Creates a fake CRL for the fake CA. The fake certificate with the given revokedSerialNumber will be marked
+     * as Revoked in the returned CRL.
+     * @param caCert the fake CA certificate.
+     * @param caPrivateKey private key of the fake CA.
+     * @param revokedSerialNumber the serial number of the fake peer certificate made to be marked as revoked.
+     * @return the created fake CRL
+     * @throws Exception
+     */
+    public static X509CRL createCRL(X509Certificate caCert, PrivateKey caPrivateKey, BigInteger revokedSerialNumber)
+            throws Exception {
+
+        X509V2CRLGenerator crlGen = new X509V2CRLGenerator();
+        Date now = new Date();
+        crlGen.setIssuerDN(caCert.getSubjectX500Principal());
+        crlGen.setThisUpdate(now);
+        crlGen.setNextUpdate(new Date(now.getTime() + TestConstants.NEXT_UPDATE_PERIOD));
+        crlGen.setSignatureAlgorithm("SHA256WithRSAEncryption");
+        crlGen.addCRLEntry(revokedSerialNumber, now, CRLReason.privilegeWithdrawn);
+        crlGen.addExtension(X509Extensions.AuthorityKeyIdentifier, false, new AuthorityKeyIdentifierStructure(caCert));
+        crlGen.addExtension(X509Extensions.CRLNumber, false, new CRLNumber(BigInteger.valueOf(1)));
+
+        return crlGen.generateX509CRL(caPrivateKey, "BC");
+    }
+
+    public X509Certificate generateFakePeerCert(BigInteger serialNumber, PublicKey entityKey,
+                                                PrivateKey caKey, X509Certificate caCert, X509Certificate firstCertificate)
+            throws Exception {
+
+        Utils utils = new Utils();
+        X509V3CertificateGenerator certGen = utils.getUsableCertificateGenerator(caCert, entityKey, serialNumber);
+        certGen.copyAndAddExtension(new DERObjectIdentifier(X509Extensions.CRLDistributionPoints.getId()), false, firstCertificate);
+
+        return certGen.generateX509Certificate(caKey, "BC");
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationTest.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationTest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/RevocationVerificationTest.java	(revision 1508687)
@@ -0,0 +1,134 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.utils.sslcert;
+
+import junit.framework.TestCase;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLCache;
+import org.apache.synapse.transport.utils.sslcert.crl.CRLVerifier;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;
+import org.apache.synapse.transport.utils.sslcert.pathvalidation.CertificatePathValidator;
+
+import java.security.Security;
+import java.security.cert.X509Certificate;
+
+public class RevocationVerificationTest extends TestCase {
+
+    /**
+     * Tests CRL Path Validation with the use of a real certificate chain. The verification process will make
+     * HTTP calls to remote CRL server URLs extracted from the certificates in the chain. Usually these certificates
+     * will not be revoked. So the path validation must be successful to pass the test. In case they are revoked
+     * or expired, new certificates should be added to the resources directory and Constants should be modified
+     * accordingly. See the interface TestConstants for expiry dates of the certificates.
+     * @throws Exception
+     */
+    public void testCRLPathValidation() throws Exception {
+        //Add BouncyCastle as Security Provider.
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        Utils utils = new Utils();
+        X509Certificate[] certificates = utils.getRealCertificateChain();
+        Throwable throwable = null;
+        try {
+            crlPathValidation(certificates);
+        } catch (CertificateVerificationException e) {
+            //Path Verification Should Pass. This catch block should not be called
+            throwable = e;
+        }
+        assertNull(throwable);
+
+    }
+
+    /**
+     * Tests CRL path validation with fake certificates. The path validation should fail since they are fake and do not
+     * contain proper information.
+     * @throws Exception
+     */
+    public void testCRLPathValidationWithFakeCerts() throws Exception {
+        //Add BouncyCastle as Security Provider.
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        Utils utils = new Utils();
+        X509Certificate[] fakeCertificates = utils.getFakeCertificateChain();
+        Throwable throwable = null;
+        try {
+            crlPathValidation(fakeCertificates);
+        } catch (CertificateVerificationException e) {
+            //Path Verification Should fail. So this catch block should be called.
+            throwable = e;
+        }
+        assertNotNull(throwable);
+    }
+
+    /**
+     * Tests path validation with OCSP. The process makes remote HTTP requests to corresponding OCSP servers at the
+     * certificate authorities. The path validation must be successful to pass the test.
+     * @throws Exception
+     */
+    public void testOCSPPathValidation() throws Exception {
+        //Add BouncyCastle as Security Provider.
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        Utils utils = new Utils();
+        X509Certificate[] certificates = utils.getRealCertificateChain();
+        Throwable throwable = null;
+        try {
+            ocspPathValidation(certificates);
+        } catch (CertificateVerificationException e) {
+            //Path Verification Should Pass. This catch block should not be called
+            throwable = e;
+        }
+        assertNull(throwable);
+    }
+
+    /**
+     * Tests OCSP path validation with a chain of fake certificates. In order to pass the test, the path validation
+     * should fail since the certificates are fake and do not contain right information.
+     * @throws Exception
+     */
+    public void testOCSPPathValidationWithFakeCerts() throws Exception {
+
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+        Utils utils = new Utils();
+        X509Certificate[] fackeCertificates = utils.getFakeCertificateChain();
+        Throwable throwable = null;
+        try {
+            ocspPathValidation(fackeCertificates);
+        } catch (CertificateVerificationException e) {
+            //Path Verification Should fail. So this catch block should be called.
+            throwable = e;
+        }
+        assertNotNull(throwable);
+    }
+
+    private void crlPathValidation(X509Certificate[] certChain) throws Exception {
+
+        CRLCache crlCache = CRLCache.getCache();
+        crlCache.init(5, 5);
+        RevocationVerifier verifier = new CRLVerifier(crlCache);
+        CertificatePathValidator pathValidator = new CertificatePathValidator(certChain, verifier);
+        pathValidator.validatePath();
+    }
+
+    private void ocspPathValidation(X509Certificate[] certChain) throws Exception {
+
+        OCSPCache ocspCache = OCSPCache.getCache();
+        ocspCache.init(5, 5);
+        RevocationVerifier verifier = new OCSPVerifier(ocspCache);
+        CertificatePathValidator pathValidator = new CertificatePathValidator(certChain, verifier);
+        pathValidator.validatePath();
+    }
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/OCSPVerifierTest.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/OCSPVerifierTest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/sslcert/OCSPVerifierTest.java	(revision 1508687)
@@ -0,0 +1,171 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.utils.sslcert;
+
+import junit.framework.TestCase;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPCache;
+import org.apache.synapse.transport.utils.sslcert.ocsp.OCSPVerifier;
+import org.bouncycastle.asn1.ASN1ObjectIdentifier;
+import org.bouncycastle.asn1.ocsp.OCSPObjectIdentifiers;
+import org.bouncycastle.asn1.x509.CRLReason;
+import org.bouncycastle.asn1.x509.X509Extension;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.ocsp.*;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.security.*;
+import java.security.cert.X509Certificate;
+import java.util.Date;
+import java.util.Vector;
+
+public class OCSPVerifierTest extends TestCase {
+
+    /**
+     * A fake certificate signed by a fake CA is made as the revoked certificate. The created OCSP response to the
+     * OCSP request will say that that the fake peer certificate is revoked. The SingleResp derived from the OCSP
+     * response will be put in to the cache against the serial number of the fake peer certificate. Since the SingleResp
+     * which corresponds to the revokedSerialNumber is in the cache, there will NOT be a call to a remote OCSP server.
+     * Note that the serviceUrl passed to cache.setCacheValue(..) is null since it is not needed.
+     *
+     * @throws Exception
+     */
+    public void testOCSPVerifier() throws Exception{
+
+        //Add BouncyCastle as Security Provider.
+        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
+
+        Utils utils = new Utils();
+        //Create fake CA certificate.
+        KeyPair caKeyPair = utils.generateRSAKeyPair();
+        X509Certificate caCert = utils.generateFakeRootCert(caKeyPair);
+
+        //Create fake peer certificate signed by the fake CA private key. This will be a revoked certificate.
+        KeyPair peerKeyPair = utils.generateRSAKeyPair();
+        BigInteger revokedSerialNumber = BigInteger.valueOf(111);
+        X509Certificate revokedCertificate = generateFakePeerCert(revokedSerialNumber, peerKeyPair.getPublic(),
+                caKeyPair.getPrivate(), caCert);
+
+        //Create OCSP request to check if certificate with "serialNumber == revokedSerialNumber" is revoked.
+        OCSPReq request = getOCSPRequest(caCert,revokedSerialNumber);
+
+        //Create OCSP response saying that certificate with given serialNumber is revoked.
+        CertificateID revokedID = new CertificateID(CertificateID.HASH_SHA1, caCert, revokedSerialNumber);
+        OCSPResp response = generateOCSPResponse(request, caKeyPair.getPrivate(), caKeyPair.getPublic(), revokedID);
+        SingleResp singleResp = ((BasicOCSPResp)response.getResponseObject()).getResponses()[0];
+
+        OCSPCache cache = OCSPCache.getCache();
+        cache.init(5,5);
+        cache.setCacheValue(revokedSerialNumber,singleResp, request, null);
+
+        OCSPVerifier ocspVerifier= new OCSPVerifier(cache);
+        RevocationStatus status = ocspVerifier.checkRevocationStatus(revokedCertificate, caCert);
+
+        //the cache will have the SingleResponse derived from the OCSP response and it will be checked to see if the
+        //fake certificate is revoked. So the status should be REVOKED.
+        assertTrue(status == RevocationStatus.REVOKED);
+    }
+
+    /**
+     * An OCSP request is made to be given to the fake CA. Reflection is used to call generateOCSPRequest(..) private
+     * method in OCSPVerifier.
+     *
+     * @param caCert the fake CA certificate.
+     * @param revokedSerialNumber the serial number of the certificate which needs to be checked if revoked.
+     * @return the created OCSP request.
+     * @throws Exception
+     */
+    private OCSPReq getOCSPRequest(X509Certificate caCert, BigInteger revokedSerialNumber) throws Exception{
+        OCSPVerifier ocspVerifier = new OCSPVerifier(null);
+        Class ocspVerifierClass = ocspVerifier.getClass();
+        Method generateOCSPRequest = ocspVerifierClass.getDeclaredMethod("generateOCSPRequest", X509Certificate.class,
+                BigInteger.class);
+        generateOCSPRequest.setAccessible(true);
+
+        OCSPReq request =  (OCSPReq)generateOCSPRequest.invoke(ocspVerifier, caCert, revokedSerialNumber);
+        return request;
+    }
+
+    /**
+     * This makes the corresponding OCSP response to the OCSP request which is sent to the fake CA. If the request
+     * has a certificateID which is marked as revoked by the CA, the OCSP response will say that the certificate
+     * which is referred to by the request, is revoked.
+     *
+     * @param request the OCSP request which asks if the certificate is revoked.
+     * @param caPrivateKey privateKey of the fake CA.
+     * @param caPublicKey  publicKey of the fake CA
+     * @param revokedID the ID at fake CA which is checked against the certificateId in the request.
+     * @return the created OCSP response by the fake CA.
+     * @throws NoSuchProviderException
+     * @throws OCSPException
+     */
+    private OCSPResp generateOCSPResponse(OCSPReq request, PrivateKey caPrivateKey, PublicKey caPublicKey,
+                                          CertificateID revokedID) throws NoSuchProviderException, OCSPException {
+
+        BasicOCSPRespGenerator basicOCSPRespGenerator = new BasicOCSPRespGenerator(caPublicKey);
+        X509Extensions requestExtensions = request.getRequestExtensions();
+
+        if (requestExtensions != null) {
+
+            X509Extension extension = requestExtensions.getExtension(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);
+
+            if (extension != null) {
+
+                Vector<ASN1ObjectIdentifier> oids = new Vector<ASN1ObjectIdentifier>();
+                Vector<X509Extension> values = new Vector<X509Extension>();
+
+                oids.add(OCSPObjectIdentifiers.id_pkix_ocsp_nonce);
+                values.add(extension);
+
+                basicOCSPRespGenerator.setResponseExtensions(new X509Extensions(oids, values));
+            }
+        }
+
+        Req[] requests = request.getRequestList();
+
+        for (Req req : requests) {
+
+            CertificateID certID = req.getCertID();
+
+            if (certID.equals(revokedID)) {
+
+                RevokedStatus revokedStatus = new RevokedStatus(new Date(), CRLReason.privilegeWithdrawn);
+                Date nextUpdate = new Date(new Date().getTime() + TestConstants.NEXT_UPDATE_PERIOD);
+                basicOCSPRespGenerator.addResponse(certID, revokedStatus , nextUpdate , null);
+            }
+            else {
+                basicOCSPRespGenerator.addResponse(certID, CertificateStatus.GOOD);
+            }
+        }
+
+        BasicOCSPResp basicResp = basicOCSPRespGenerator.generate("SHA256WithRSA", caPrivateKey, null, new Date(), "BC");
+        OCSPRespGenerator respGen = new OCSPRespGenerator();
+
+        return respGen.generate(OCSPRespGenerator.SUCCESSFUL, basicResp);
+    }
+
+    private X509Certificate generateFakePeerCert(BigInteger serialNumber, PublicKey entityKey,
+                                                PrivateKey caKey, X509Certificate caCert)
+            throws Exception {
+        Utils utils = new Utils();
+        X509V3CertificateGenerator certGen = utils.getUsableCertificateGenerator(caCert,entityKey, serialNumber);
+        return certGen.generateX509Certificate(caKey, "BC");
+    }
+}
Index: java/modules/transports/core/nhttp/pom.xml
===================================================================
--- java/modules/transports/core/nhttp/pom.xml	(revision 1508686)
+++ java/modules/transports/core/nhttp/pom.xml	(revision 1508687)
@@ -153,6 +153,12 @@
             <groupId>commons-lang</groupId>
             <artifactId>commons-lang</artifactId>
         </dependency>
+
+        <!-- BouncyCastle API which is required when validating Certificates. -->
+        <dependency>
+            <groupId>org.bouncycastle</groupId>
+            <artifactId>bcprov-jdk15on</artifactId>
+        </dependency>
     </dependencies>
 
 </project>
Index: java/repository/conf/axis2.xml
===================================================================
--- java/repository/conf/axis2.xml	(revision 1508686)
+++ java/repository/conf/axis2.xml	(revision 1508687)
@@ -313,6 +313,12 @@
         </parameter>
         <!--<parameter name="HostnameVerifier">DefaultAndLocalhost</parameter>
             supports Strict|AllowAll|DefaultAndLocalhost or the default if none specified -->
+        <!-- Uncomment to enable OCSP/CRL certification revocation verification support
+        <parameter name="CertificateRevocationVerifier" locked="false">
+            <Enabled>true</Enabled>
+            <CacheSize>50</CacheSize>
+            <CacheDelayMins>15</CacheDelayMins>
+        </parameter-->
     </transportSender>
 
     <!-- Uncomment Transport sender for the non blocking local transport-->
-*-*-*-
Message: Adding OCSP and CRL support to the NHTTP and pass through transports - Applying the patch for SYNAPSE-954 with some modifications.
-*-*-*-
When: 2013-07-30 19:57:48 -0400 
-*-*-*-
Who: hiranya
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java	(nonexistent)
@@ -1,62 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.apache.synapse.transport.passthru;
-
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.impl.nio.DefaultHttpServerIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.impl.nio.SSLNHttpServerConnectionFactory;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-import org.apache.synapse.transport.passthru.logging.LoggingUtils;
-
-import javax.net.ssl.SSLContext;
-
-public class SSLSourceIOEventDispatch extends DefaultHttpServerIODispatch {
-
-    public SSLSourceIOEventDispatch(NHttpServerEventHandler handler,
-                                    SSLContext sslcontext,
-                                    SSLSetupHandler sslHandler,
-                                    HttpParams params) {
-        super(handler, new SSLSourceConnectionFactory(sslcontext, sslHandler, params));
-    }
-
-    private static class SSLSourceConnectionFactory extends SSLNHttpServerConnectionFactory {
-
-        public SSLSourceConnectionFactory(SSLContext sslcontext, SSLSetupHandler sslHandler, HttpParams params) {
-            super(sslcontext, sslHandler, params);
-        }
-
-        @Override
-        protected DefaultNHttpServerConnection createConnection(IOSession session,
-                                                                HttpRequestFactory requestFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            session = LoggingUtils.decorate(session, "sslserver");
-            return LoggingUtils.createServerConnection(
-                    session,
-                    requestFactory,
-                    allocator,
-                    params);
-        }
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java	(nonexistent)
@@ -1,61 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru;
-
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.nio.DefaultHttpClientIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.impl.nio.DefaultNHttpClientConnectionFactory;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-import org.apache.synapse.transport.passthru.logging.LoggingUtils;
-
-/**
- * This is a factory for creating the logging sessions or non-logging sessions.
- */
-public class TargetIOEventDispatch extends DefaultHttpClientIODispatch {
-
-    public TargetIOEventDispatch(final NHttpClientEventHandler handler, final HttpParams params) {
-        super(LoggingUtils.decorate(handler), new TargetConnectionFactory(params));
-    }
-
-    private static class TargetConnectionFactory extends DefaultNHttpClientConnectionFactory {
-
-        public TargetConnectionFactory(HttpParams params) {
-            super(params);
-        }
-
-        @Override
-        protected DefaultNHttpClientConnection createConnection(IOSession session,
-                                                                HttpResponseFactory responseFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            session = LoggingUtils.decorate(session, "client");
-            return LoggingUtils.createClientConnection(
-                    session,
-                    responseFactory,
-                    allocator,
-                    params);
-        }
-    }
-
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java	(nonexistent)
@@ -1,62 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru;
-
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.impl.nio.DefaultHttpServerIODispatch;
-
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.impl.nio.DefaultNHttpServerConnectionFactory;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-import org.apache.synapse.transport.passthru.logging.LoggingUtils;
-
-/**
- * This is a factory for creating the logging sessions or non-logging sessions.
- */
-public class SourceIOEventDispatch extends DefaultHttpServerIODispatch {
-
-    public SourceIOEventDispatch(final NHttpServerEventHandler handler, final HttpParams params) {
-        super(LoggingUtils.decorate(handler), new SourceConnectionFactory(params));
-    }
-
-    private static class SourceConnectionFactory extends DefaultNHttpServerConnectionFactory {
-
-        public SourceConnectionFactory(HttpParams params) {
-            super(params);
-        }
-
-        @Override
-        protected DefaultNHttpServerConnection createConnection(IOSession session,
-                                                                HttpRequestFactory requestFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            session = LoggingUtils.decorate(session, "server");
-            return LoggingUtils.createServerConnection(
-                    session,
-                    requestFactory,
-                    allocator,
-                    params);
-        }
-    }
-
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java	(nonexistent)
@@ -1,159 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.commons.logging.Log;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionOutputBuffer;
-import org.apache.http.nio.reactor.SessionInputBuffer;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.nio.NHttpMessageWriter;
-import org.apache.http.nio.NHttpMessageParser;
-import org.apache.http.*;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.params.HttpParams;
-
-import java.io.IOException;
-import java.nio.channels.ReadableByteChannel;
-
-public class LoggingNHttpTargetConnection extends DefaultNHttpClientConnection {
-
-    private final Log log;
-    private final Log headerLog;
-
-    public LoggingNHttpTargetConnection(
-            final Log log,
-            final Log headerLog,
-            final IOSession iosession,
-            final HttpResponseFactory responseFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        super(iosession, responseFactory, allocator, params);
-        this.log = log;
-        this.headerLog = headerLog;
-    }
-
-    @Override
-    public void close() throws IOException {
-        this.log.debug("Close connection");
-        super.close();
-    }
-
-    @Override
-    public void shutdown() throws IOException {
-        this.log.debug("Shutdown connection");
-        super.shutdown();
-    }
-
-    @Override
-    public void submitRequest(final HttpRequest request) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + this + ": "  + request.getRequestLine().toString());
-        }
-        super.submitRequest(request);
-    }
-
-    @Override
-    public void consumeInput(final NHttpClientEventHandler handler) {
-        this.log.debug("Consume input");
-        super.consumeInput(handler);
-    }
-
-    @Override
-    public void produceOutput(final NHttpClientEventHandler handler) {
-        this.log.debug("Produce output");
-        super.produceOutput(handler);
-    }
-
-    @Override
-    protected NHttpMessageWriter<HttpRequest> createRequestWriter(
-            final SessionOutputBuffer buffer,
-            final HttpParams params) {
-        return new LoggingNHttpMessageWriter(
-                super.createRequestWriter(buffer, params));
-    }
-
-    @Override
-    protected NHttpMessageParser<HttpResponse> createResponseParser(
-            final SessionInputBuffer buffer,
-            final HttpResponseFactory responseFactory,
-            final HttpParams params) {
-        return new LoggingNHttpMessageParser(
-                super.createResponseParser(buffer, responseFactory, params));
-    }
-
-    class LoggingNHttpMessageWriter implements NHttpMessageWriter<HttpRequest> {
-
-        private final NHttpMessageWriter<HttpRequest> writer;
-
-        public LoggingNHttpMessageWriter(final NHttpMessageWriter<HttpRequest> writer) {
-            super();
-            this.writer = writer;
-        }
-
-        public void reset() {
-            this.writer.reset();
-        }
-
-        public void write(final HttpRequest request) throws IOException, HttpException {
-            if (request != null && headerLog.isDebugEnabled()) {
-                headerLog.debug(">> " + request.getRequestLine().toString());
-                Header[] headers = request.getAllHeaders();
-                for (Header header : headers) {
-                    headerLog.debug(">> " + header.toString());
-                }
-            }
-            this.writer.write(request);
-        }
-
-    }
-
-    class LoggingNHttpMessageParser implements NHttpMessageParser<HttpResponse> {
-
-        private final NHttpMessageParser<HttpResponse> parser;
-
-        public LoggingNHttpMessageParser(final NHttpMessageParser<HttpResponse> parser) {
-            super();
-            this.parser = parser;
-        }
-
-        public void reset() {
-            this.parser.reset();
-        }
-
-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
-            return this.parser.fillBuffer(channel);
-        }
-
-        public HttpResponse parse() throws IOException, HttpException {
-            HttpResponse response = this.parser.parse();
-            if (response != null && headerLog.isDebugEnabled()) {
-                headerLog.debug("<< " + response.getStatusLine().toString());
-                Header[] headers = response.getAllHeaders();
-                for (Header header : headers) {
-                    headerLog.debug("<< " + header.toString());
-                }
-            }
-            return response;
-        }
-
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java	(nonexistent)
@@ -1,122 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.nio.*;
-import org.apache.http.HttpException;
-import org.apache.http.HttpResponse;
-
-import java.io.IOException;
-
-public class LoggingTargetHandler implements NHttpClientEventHandler {
-
-    private final Log log;
-    
-    private final NHttpClientEventHandler handler;
-
-    public LoggingTargetHandler(final NHttpClientEventHandler handler) {
-        super();
-        if (handler == null) {
-            throw new IllegalArgumentException("HTTP client handler may not be null");
-        }
-        this.handler = handler;
-        this.log = LogFactory.getLog(handler.getClass());
-    }
-
-    public void connected(final NHttpClientConnection conn, final Object attachment) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Connected (" + attachment + ")");
-        }
-        this.handler.connected(conn, attachment);
-    }
-
-    public void closed(final NHttpClientConnection conn) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed");
-        }
-        this.handler.closed(conn);
-    }
-
-    public void endOfInput(NHttpClientConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed at remote end");
-        }
-        this.handler.endOfInput(conn);
-    }
-
-    public void exception(NHttpClientConnection conn, Exception ex) {
-        this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
-        this.handler.exception(conn, ex);
-    }
-
-    public void requestReady(final NHttpClientConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": InRequest ready" + getRequestMessageID(conn));
-        }
-        this.handler.requestReady(conn);
-    }
-
-    public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Output ready" + getRequestMessageID(conn));
-        }
-        this.handler.outputReady(conn, encoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
-        }
-    }
-
-    public void responseReceived(final NHttpClientConnection conn) throws IOException, HttpException {
-        HttpResponse response = conn.getHttpResponse();
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + " : "
-                    + response.getStatusLine() + getRequestMessageID(conn));
-        }
-        this.handler.responseReceived(conn);
-    }
-
-    public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Input ready" + getRequestMessageID(conn));
-        }
-        this.handler.inputReady(conn, decoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
-        }
-    }
-
-    public void timeout(final NHttpClientConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Timeout" + getRequestMessageID(conn));
-        }
-        this.handler.timeout(conn);
-    }
-
-    private static String getRequestMessageID(final NHttpClientConnection conn) {
-        /*Axis2HttpRequest axis2Request = (Axis2HttpRequest)
-                conn.getContext().getAttribute(ClientHandler.AXIS2_HTTP_REQUEST);
-        if (axis2Request != null) {
-            return " [InRequest Message ID : " + axis2Request.getMsgContext().getMessageID() + "]";
-        }*/        
-        return "";
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java	(nonexistent)
@@ -1,228 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionBufferStatus;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-import java.util.concurrent.atomic.AtomicLong;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.SelectionKey;
-import java.nio.ByteBuffer;
-import java.net.SocketAddress;
-import java.io.IOException;
-
-class LoggingIOSession implements IOSession {
-
-    private static AtomicLong COUNT = new AtomicLong(0);
-
-    private final Log log;
-    private final Wire wirelog;
-    private final IOSession session;
-    private final ByteChannel channel;
-    private final String id;
-
-    public LoggingIOSession(            
-            final Log wirelog,
-            final IOSession session,
-            final String id) {
-        super();
-        if (session == null) {
-            throw new IllegalArgumentException("I/O session may not be null");
-        }
-        this.session = session;
-        this.channel = new LoggingByteChannel();
-        this.id = id + "-" + COUNT.incrementAndGet();
-        this.log = LogFactory.getLog(session.getClass());
-        this.wirelog = new Wire(wirelog);
-    }
-
-    public int getStatus() {
-        return this.session.getStatus();
-    }
-
-    public ByteChannel channel() {
-        return this.channel;
-    }
-
-    public SocketAddress getLocalAddress() {
-        return this.session.getLocalAddress();
-    }
-
-    public SocketAddress getRemoteAddress() {
-        return this.session.getRemoteAddress();
-    }
-
-    public int getEventMask() {
-        return this.session.getEventMask();
-    }
-
-    private static String formatOps(int ops) {
-        StringBuffer buffer = new StringBuffer(6);
-        buffer.append('[');
-        if ((ops & SelectionKey.OP_READ) > 0) {
-            buffer.append('r');
-        }
-        if ((ops & SelectionKey.OP_WRITE) > 0) {
-            buffer.append('w');
-        }
-        if ((ops & SelectionKey.OP_ACCEPT) > 0) {
-            buffer.append('a');
-        }
-        if ((ops & SelectionKey.OP_CONNECT) > 0) {
-            buffer.append('c');
-        }
-        buffer.append(']');
-        return buffer.toString();
-    }
-
-    public void setEventMask(int ops) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Set event mask "
-                    + formatOps(ops));
-        }
-        this.session.setEventMask(ops);
-    }
-
-    public void setEvent(int op) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Set event "
-                    + formatOps(op));
-        }
-        this.session.setEvent(op);
-    }
-
-    public void clearEvent(int op) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Clear event "
-                    + formatOps(op));
-        }
-        this.session.clearEvent(op);
-    }
-
-    public void close() {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Close");
-        }
-        this.session.close();
-    }
-
-    public boolean isClosed() {
-        return this.session.isClosed();
-    }
-
-    public void shutdown() {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Shutdown");
-        }
-        this.session.shutdown();
-    }
-
-    public int getSocketTimeout() {
-        return this.session.getSocketTimeout();
-    }
-
-    public void setSocketTimeout(int timeout) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Set timeout "
-                    + timeout);
-        }
-        this.session.setSocketTimeout(timeout);
-    }
-
-    public void setBufferStatus(final SessionBufferStatus status) {
-        this.session.setBufferStatus(status);
-    }
-
-    public boolean hasBufferedInput() {
-        return this.session.hasBufferedInput();
-    }
-
-    public boolean hasBufferedOutput() {
-        return this.session.hasBufferedOutput();
-    }
-
-    public Object getAttribute(final String name) {
-        return this.session.getAttribute(name);
-    }
-
-    public void setAttribute(final String name, final Object obj) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Set attribute "
-                    + name);
-        }
-        this.session.setAttribute(name, obj);
-    }
-
-    public Object removeAttribute(final String name) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("I/O session " + this.id + " " + this.session + ": Remove attribute "
-                    + name);
-        }
-        return this.session.removeAttribute(name);
-    }
-
-    class LoggingByteChannel implements ByteChannel {
-
-        public int read(final ByteBuffer dst) throws IOException {
-            int bytesRead = session.channel().read(dst);
-            if (log.isDebugEnabled()) {
-                log.debug("I/O session " + id + " " + session + ": " + bytesRead + " bytes read");
-            }
-            if (bytesRead > 0 && wirelog.isEnabled()) {
-                ByteBuffer b = dst.duplicate();
-                int p = b.position();
-                b.limit(p);
-                b.position(p - bytesRead);
-                wirelog.input(b);
-            }
-            return bytesRead;
-        }
-
-        public int write(final ByteBuffer src) throws IOException {
-            int byteWritten = session.channel().write(src);
-            if (log.isDebugEnabled()) {
-                log.debug("I/O session " + id + " " + session + ": " + byteWritten + " bytes written");
-            }
-            if (byteWritten > 0 && wirelog.isEnabled()) {
-                ByteBuffer b = src.duplicate();
-                int p = b.position();
-                b.limit(p);
-                b.position(p - byteWritten);
-                wirelog.output(b);
-            }
-            return byteWritten;
-        }
-
-        public void close() throws IOException {
-            if (log.isDebugEnabled()) {
-                log.debug("I/O session " + id + " " + session + ": Channel close");
-            }
-            session.channel().close();
-        }
-
-        public boolean isOpen() {
-            return session.channel().isOpen();
-        }
-
-    }       
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java	(nonexistent)
@@ -1,158 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionOutputBuffer;
-import org.apache.http.nio.reactor.SessionInputBuffer;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.nio.NHttpMessageWriter;
-import org.apache.http.nio.NHttpMessageParser;
-import org.apache.http.*;
-import org.apache.http.params.HttpParams;
-import org.apache.commons.logging.Log;
-
-import java.io.IOException;
-import java.nio.channels.ReadableByteChannel;
-
-public class LoggingNHttpSourceConnection extends DefaultNHttpServerConnection {
-    private final Log log;
-    private final Log headerLog;
-
-    public LoggingNHttpSourceConnection(
-            final Log log,
-            final Log headerLog,
-            final IOSession session,
-            final HttpRequestFactory requestFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        super(session, requestFactory, allocator, params);
-        this.log = log;
-        this.headerLog = headerLog;
-    }
-
-    @Override
-    public void close() throws IOException {
-        this.log.debug("Close connection");
-        super.close();
-    }
-
-    @Override
-    public void shutdown() throws IOException {
-        this.log.debug("Shutdown connection");
-        super.shutdown();
-    }
-
-    @Override
-    public void submitResponse(final HttpResponse response) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + this + ": "  + response.getStatusLine().toString());
-        }
-        super.submitResponse(response);
-    }
-
-    @Override
-    public void consumeInput(final NHttpServerEventHandler handler) {
-        this.log.debug("Consume input");
-        super.consumeInput(handler);
-    }
-
-    @Override
-    public void produceOutput(final NHttpServerEventHandler handler) {
-        this.log.debug("Produce output");
-        super.produceOutput(handler);
-    }
-
-    @Override
-    protected NHttpMessageWriter<HttpResponse> createResponseWriter(
-            final SessionOutputBuffer buffer,
-            final HttpParams params) {
-        return new LoggingNHttpMessageWriter(
-                super.createResponseWriter(buffer, params));
-    }
-
-    @Override
-    protected NHttpMessageParser<HttpRequest> createRequestParser(
-            final SessionInputBuffer buffer,
-            final HttpRequestFactory requestFactory,
-            final HttpParams params) {
-        return new LoggingNHttpMessageParser(
-                super.createRequestParser(buffer, requestFactory, params));
-    }
-
-    class LoggingNHttpMessageWriter implements NHttpMessageWriter<HttpResponse> {
-
-        private final NHttpMessageWriter<HttpResponse> writer;
-
-        public LoggingNHttpMessageWriter(final NHttpMessageWriter<HttpResponse> writer) {
-            super();
-            this.writer = writer;
-        }
-
-        public void reset() {
-            this.writer.reset();
-        }
-
-        public void write(final HttpResponse response) throws IOException, HttpException {
-            if (response != null && headerLog.isDebugEnabled()) {
-                headerLog.debug("<< " + response.getStatusLine().toString());
-                Header[] headers = response.getAllHeaders();
-                for (Header header : headers) {
-                    headerLog.debug("<< " + header.toString());
-                }
-            }
-            this.writer.write(response);
-        }
-
-    }
-
-    class LoggingNHttpMessageParser implements NHttpMessageParser<HttpRequest> {
-
-        private final NHttpMessageParser<HttpRequest> parser;
-
-        public LoggingNHttpMessageParser(final NHttpMessageParser<HttpRequest> parser) {
-            super();
-            this.parser = parser;
-        }
-
-        public void reset() {
-            this.parser.reset();
-        }
-
-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
-            return this.parser.fillBuffer(channel);
-        }
-
-        public HttpRequest parse() throws IOException, HttpException {
-            HttpRequest request = this.parser.parse();
-            if (request != null && headerLog.isDebugEnabled()) {
-                headerLog.debug(">> " + request.getRequestLine().toString());
-                Header[] headers = request.getAllHeaders();
-                for (Header header : headers) {
-                    headerLog.debug(">> " + header.toString());
-                }
-            }
-            return request;
-        }
-    }
-}
-
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java	(nonexistent)
@@ -1,129 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.nio.*;
-import org.apache.http.ConnectionClosedException;
-import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-
-import java.io.IOException;
-
-public class LoggingSourceHandler implements NHttpServerEventHandler {
-
-    private final Log log;
-
-    private final NHttpServerEventHandler handler;
-
-    public LoggingSourceHandler (final NHttpServerEventHandler handler) {
-        super();
-        if (handler == null) {
-            throw new IllegalArgumentException("HTTP service handler may not be null");
-        }
-        this.handler = handler;
-        this.log = LogFactory.getLog(handler.getClass());
-    }
-
-    public void connected(final NHttpServerConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Connected");
-        }
-        this.handler.connected(conn);
-    }
-
-    public void closed(final NHttpServerConnection conn) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed");
-        }
-        this.handler.closed(conn);
-    }
-
-    public void endOfInput(NHttpServerConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed at the remote end");
-        }
-        this.handler.endOfInput(conn);
-    }
-
-    public void exception(NHttpServerConnection conn, Exception ex) {
-        if (ex.getMessage() == null) {
-            ex.printStackTrace();
-            return;
-        }
-        if (ex instanceof ConnectionClosedException ||
-                ex.getMessage().contains("Connection reset by peer") ||
-                ex.getMessage().contains("forcibly closed")) {
-            if (this.log.isDebugEnabled()) {
-                this.log.debug("HTTP connection " + conn + ": " + ex.getMessage() +
-                        " (Probably the keep-alive connection was closed)");
-            }
-        } else if (ex instanceof HttpException) {
-            this.log.error("HTTP Error occurred on connection " + conn + ": " + ex.getMessage(), ex);
-            this.handler.exception(conn, ex);
-        } else {
-            this.log.error("IO Error occurred on HTTP connection " + conn + ": " + ex.getMessage(), ex);
-        }
-        this.handler.exception(conn, ex);
-    }
-
-    public void requestReceived(final NHttpServerConnection conn) throws IOException, HttpException {
-        HttpRequest request = conn.getHttpRequest();
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP InRequest Received on connection " + conn + ": "
-                    + request.getRequestLine());
-        }
-        this.handler.requestReceived(conn);
-    }
-
-    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Output ready");
-        }
-        this.handler.outputReady(conn, encoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
-        }
-    }
-
-    public void responseReady(final NHttpServerConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Response ready");
-        }
-        this.handler.responseReady(conn);
-    }
-
-    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Input ready");
-        }
-        this.handler.inputReady(conn, decoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
-        }
-    }
-
-    public void timeout(final NHttpServerConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Timeout");
-        }
-        this.handler.timeout(conn);
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java	(nonexistent)
@@ -1,109 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.commons.logging.Log;
-
-import java.nio.ByteBuffer;
-
-public class Wire {
-    private final Log log;
-
-    public Wire(final Log log) {
-        super();
-        this.log = log;
-    }
-
-    private void wire(final String header, final byte[] b, int pos, int off) {
-        StringBuilder buffer = new StringBuilder();
-        for (int i = 0; i < off; i++) {
-            int ch = b[pos + i];
-            if (ch == 13) {
-                buffer.append("[\\r]");
-            } else if (ch == 10) {
-                    buffer.append("[\\n]\"");
-                    buffer.insert(0, "\"");
-                    buffer.insert(0, header);
-                    this.log.debug(buffer.toString());
-                    buffer.setLength(0);
-            } else if ((ch < 32) || (ch > 127)) {
-                buffer.append("[0x");
-                buffer.append(Integer.toHexString(ch));
-                buffer.append("]");
-            } else {
-                buffer.append((char) ch);
-            }
-        }
-        if (buffer.length() > 0) {
-            buffer.append('\"');
-            buffer.insert(0, '\"');
-            buffer.insert(0, header);
-            this.log.debug(buffer.toString());
-        }
-    }
-
-
-    public boolean isEnabled() {
-        return this.log.isDebugEnabled();
-    }
-
-    public void output(final byte[] b, int pos, int off) {
-        wire("<< ", b, pos, off);
-    }
-
-    public void input(final byte[] b, int pos, int off) {
-        wire(">> ", b, pos, off);
-    }
-
-    public void output(byte[] b) {
-        output(b, 0, b.length);
-    }
-
-    public void input(byte[] b) {
-        input(b, 0, b.length);
-    }
-
-    public void output(int b) {
-        output(new byte[] {(byte) b});
-    }
-
-    public void input(int b) {
-        input(new byte[] {(byte) b});
-    }
-
-    public void output(final ByteBuffer b) {
-        if (b.hasArray()) {
-            output(b.array(), b.arrayOffset() + b.position(), b.remaining());
-        } else {
-            byte[] tmp = new byte[b.remaining()];
-            b.get(tmp);
-            output(tmp);
-        }
-    }
-
-    public void input(final ByteBuffer b) {
-        if (b.hasArray()) {
-            input(b.array(), b.arrayOffset() + b.position(), b.remaining());
-        } else {
-            byte[] tmp = new byte[b.remaining()];
-            b.get(tmp);
-            input(tmp);
-        }
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java	(nonexistent)
@@ -1,111 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru.logging;
-
-import org.apache.http.nio.*;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.params.HttpParams;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-
-public class LoggingUtils {
-
-    public final static String HEADER_LOG_ID = "org.wso2.carbon.transport.passthru.headers";
-    public final static String WIRE_LOG_ID = "org.wso2.carbon.transport.passthru.wire";
-
-    public static IOSession decorate(IOSession session, final String id) {
-        Log log = LogFactory.getLog(session.getClass());
-        Log wireLog = LogFactory.getLog(WIRE_LOG_ID);
-        if (wireLog.isDebugEnabled() || log.isDebugEnabled()) {
-            session = new LoggingIOSession(wireLog, session, id);
-        }
-        return session;
-    }
-
-    public static NHttpClientEventHandler decorate(NHttpClientEventHandler handler) {
-        Log log = LogFactory.getLog(handler.getClass());
-        if (log.isDebugEnabled()) {
-            handler = new LoggingTargetHandler(handler);
-        }
-        return handler;
-    }
-
-    public static NHttpServerEventHandler decorate(NHttpServerEventHandler handler) {
-        Log log = LogFactory.getLog(handler.getClass());
-        if (log.isDebugEnabled()) {
-            handler = new LoggingSourceHandler(handler);
-        }
-        return handler;
-    }
-
-    public static DefaultNHttpClientConnection createClientConnection(
-            final IOSession iosession,
-            final HttpResponseFactory responseFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);
-        Log headerLog = LogFactory.getLog(HEADER_LOG_ID);
-        if (headerLog.isDebugEnabled() || log.isDebugEnabled()) {
-            return new LoggingNHttpTargetConnection(
-                    log,
-                    headerLog,
-                    iosession,
-                    responseFactory,
-                    allocator,
-                    params);
-        } else {
-            return new DefaultNHttpClientConnection(
-                    iosession,
-                    responseFactory,
-                    allocator,
-                    params);
-        }
-    }
-
-    public static DefaultNHttpServerConnection createServerConnection(
-            final IOSession iosession,
-            final HttpRequestFactory requestFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);
-        Log headerLog = LogFactory.getLog(HEADER_LOG_ID);
-        if (headerLog.isDebugEnabled() || log.isDebugEnabled()) {
-            return new LoggingNHttpSourceConnection(
-                    log,
-                    headerLog,
-                    iosession,
-                    requestFactory,
-                    allocator,
-                    params);
-        } else {
-            return new DefaultNHttpServerConnection(
-                    iosession,
-                    requestFactory,
-                    allocator,
-                    params);
-        }
-    }
-
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java	(nonexistent)
@@ -1,137 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.passthru;
-
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.DefaultHttpResponseFactory;
-import org.apache.http.impl.nio.DefaultHttpClientIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.NHttpConnectionFactory;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.ssl.SSLIOSession;
-import org.apache.http.nio.reactor.ssl.SSLMode;
-import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.nio.util.HeapByteBufferAllocator;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.synapse.transport.passthru.logging.LoggingUtils;
-
-import javax.net.ssl.SSLContext;
-import java.net.InetSocketAddress;
-import java.util.Map;
-
-public class SSLTargetIOEventDispatch extends DefaultHttpClientIODispatch {
-
-    public SSLTargetIOEventDispatch(NHttpClientEventHandler handler,
-                                    SSLContext sslcontext,
-                                    Map<String,SSLContext> customContexts,
-                                    SSLSetupHandler sslHandler,
-                                    HttpParams params) {
-        super(handler,
-                new SSLTargetConnectionFactory(sslcontext, customContexts, sslHandler, params));
-    }
-
-    /**
-     * Custom NHttpClientConnectionFactory implementation. Most of this code has been borrowed
-     * from the SSLNHttpClientConnectionFactory class of HttpCore-NIO. This custom implementation
-     * allows using different SSLContext instances for different target endpoints (custom SSL
-     * profiles feature). Hopefully a future HttpCore-NIO API will provide an easier way to
-     * customize the way SSLIOSession instances are created and we will be able to get rid of this.
-     */
-    private static class SSLTargetConnectionFactory
-            implements NHttpConnectionFactory<DefaultNHttpClientConnection> {
-
-        private final HttpResponseFactory responseFactory;
-        private final ByteBufferAllocator allocator;
-        private final SSLContext sslcontext;
-        private final SSLSetupHandler sslHandler;
-        private final HttpParams params;
-        private final Map<String,SSLContext> contextMap;
-
-        public SSLTargetConnectionFactory(
-                final SSLContext sslcontext,
-                final Map<String,SSLContext> contextMap,
-                final SSLSetupHandler sslHandler,
-                final HttpParams params) {
-
-            if (params == null) {
-                throw new IllegalArgumentException("HTTP parameters may not be null");
-            }
-            this.sslcontext = sslcontext;
-            this.contextMap = contextMap;
-            this.sslHandler = sslHandler;
-            this.responseFactory = new DefaultHttpResponseFactory();
-            this.allocator = new HeapByteBufferAllocator();
-            this.params = params;
-        }
-
-        protected DefaultNHttpClientConnection createConnection(IOSession session,
-                                                                HttpResponseFactory responseFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            session = LoggingUtils.decorate(session, "sslclient");
-            return LoggingUtils.createClientConnection(
-                    session,
-                    responseFactory,
-                    allocator,
-                    params);
-        }
-
-        private SSLContext getDefaultSSLContext() {
-            SSLContext sslcontext;
-            try {
-                sslcontext = SSLContext.getInstance("TLS");
-                sslcontext.init(null, null, null);
-            } catch (Exception ex) {
-                throw new IllegalStateException("Failure initializing default SSL context", ex);
-            }
-            return sslcontext;
-        }
-
-        private SSLContext getSSLContext(IOSession session) {
-            InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();
-            String host = address.getHostName() + ":" + address.getPort();
-            SSLContext customContext = null;
-            if (contextMap != null) {
-                // See if there's a custom SSL profile configured for this server
-                customContext = contextMap.get(host);
-            }
-
-            if (customContext == null) {
-                customContext = this.sslcontext != null ? this.sslcontext : getDefaultSSLContext();
-            }
-            return customContext;
-        }
-
-        public DefaultNHttpClientConnection createConnection(final IOSession session) {
-            SSLContext sslcontext = getSSLContext(session);
-            SSLIOSession ssliosession = new SSLIOSession(session, SSLMode.CLIENT,
-                    sslcontext, this.sslHandler);
-            session.setAttribute(SSLIOSession.SESSION_KEY, ssliosession);
-            DefaultNHttpClientConnection conn = createConnection(
-                    ssliosession, this.responseFactory, this.allocator, this.params);
-            int timeout = HttpConnectionParams.getSoTimeout(this.params);
-            conn.setSocketTimeout(timeout);
-            return conn;
-        }
-    }
-}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientHandler.java	(nonexistent)
@@ -1,127 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.HttpException;
-import org.apache.http.HttpResponse;
-import org.apache.http.nio.*;
-
-/**
- * Decorator class intended to transparently extend an {@link NHttpClientEventHandler}
- * with basic event logging capabilities using Commons Logging. 
- */
-class LoggingNHttpClientHandler implements NHttpClientEventHandler {
-
-    private final Log log;
-    private final NHttpClientEventHandler handler;
-    
-    public LoggingNHttpClientHandler(
-            final Log log, 
-            final NHttpClientEventHandler handler) {
-        super();
-        if (handler == null) {
-            throw new IllegalArgumentException("HTTP client handler may not be null");
-        }
-        this.handler = handler;
-        this.log = LogFactory.getLog(handler.getClass());
-    }
-    
-    public void connected(final NHttpClientConnection conn, final Object attachment) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Connected (" + attachment + ")");
-        }
-        this.handler.connected(conn, attachment);
-    }
-
-    public void closed(final NHttpClientConnection conn) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed");
-        }
-        this.handler.closed(conn);
-    }
-
-    public void endOfInput(NHttpClientConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed at remote end");
-        }
-        this.handler.endOfInput(conn);
-    }
-
-    public void exception(NHttpClientConnection conn, Exception ex) {
-        this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
-        this.handler.exception(conn, ex);
-    }
-
-    public void requestReady(final NHttpClientConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Request ready" + getRequestMessageID(conn));
-        }
-        this.handler.requestReady(conn);
-    }
-
-    public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Output ready" + getRequestMessageID(conn));
-        }
-        this.handler.outputReady(conn, encoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
-        }
-    }
-
-    public void responseReceived(final NHttpClientConnection conn) throws IOException, HttpException {
-        HttpResponse response = conn.getHttpResponse();
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + " : "
-                    + response.getStatusLine() + getRequestMessageID(conn));
-        }
-        this.handler.responseReceived(conn);
-    }
-
-    public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Input ready" + getRequestMessageID(conn));
-        }
-        this.handler.inputReady(conn, decoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
-        }
-    }
-
-    public void timeout(final NHttpClientConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Timeout" + getRequestMessageID(conn));
-        }
-        this.handler.timeout(conn);
-    }
-
-    private static String getRequestMessageID(final NHttpClientConnection conn) {
-        Axis2HttpRequest axis2Request = (Axis2HttpRequest)
-                conn.getContext().getAttribute(ClientHandler.AXIS2_HTTP_REQUEST);
-        if (axis2Request != null) {
-            return " [Request Message ID : " + axis2Request.getMsgContext().getMessageID() + "]";
-        }
-        return "";
-    }
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientHandler.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingUtils.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingUtils.java	(nonexistent)
@@ -1,79 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.nio.*;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-class LoggingUtils {
-    
-    public final static String HEADER_LOG_ID = "org.apache.synapse.transport.nhttp.headers"; 
-    public final static String WIRE_LOG_ID = "org.apache.synapse.transport.nhttp.wire";
-    public final static String ACCESS_LOG_ID = "org.apache.synapse.transport.nhttp.access";
-
-    public static NHttpClientEventHandler decorate(NHttpClientEventHandler handler) {
-        Log log = LogFactory.getLog(handler.getClass());
-        if (log.isDebugEnabled()) {
-            handler = new LoggingNHttpClientHandler(log, handler);
-        }
-        return handler;
-    }
-
-    public static NHttpServerEventHandler decorate(NHttpServerEventHandler handler) {
-        Log log = LogFactory.getLog(handler.getClass());
-        if (log.isDebugEnabled()) {
-            handler = new LoggingNHttpServiceHandler(log, handler);
-        }
-        return handler;
-    }
-
-    public static DefaultNHttpClientConnection createClientConnection(
-            final IOSession iosession,
-            final HttpResponseFactory responseFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        return new LoggingNHttpClientConnection(
-                iosession, 
-                responseFactory,
-                allocator,
-                params);
-    }
-
-    public static DefaultNHttpServerConnection createServerConnection(
-            final IOSession iosession,
-            final HttpRequestFactory requestFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        return new LoggingNHttpServerConnection(
-                iosession, 
-                requestFactory,
-                allocator,
-                params);
-    }
-    
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingUtils.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Deleted: svn:keywords
## -1 +0,0 ##
-Date Author Id Revision HeadURL
\ No newline at end of property
Deleted: svn:mime-type
## -1 +0,0 ##
-text/plain
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLClientIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLClientIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLClientIOEventDispatch.java	(nonexistent)
@@ -1,144 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import javax.net.ssl.SSLContext;
-
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.DefaultHttpResponseFactory;
-import org.apache.http.impl.nio.DefaultHttpClientIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.NHttpConnectionFactory;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.ssl.SSLIOSession;
-import org.apache.http.nio.reactor.ssl.SSLMode;
-import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.nio.util.HeapByteBufferAllocator;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-
-import java.net.InetSocketAddress;
-import java.util.Map;
-
-/**
- * This custom SSLClientIOEventDispatch can keep a map of SSLContexts and use the correct
- * SSLContext when connecting to different servers. If a SSLContext cannot be found for a
- * particular server from the specified map it uses the default SSLContext.
- */
-public class SSLClientIOEventDispatch extends DefaultHttpClientIODispatch {
-
-    public SSLClientIOEventDispatch(
-            final NHttpClientEventHandler handler,
-            final SSLContext sslcontext,
-            final Map<String, SSLContext> contextMap,
-            final SSLSetupHandler sslHandler,
-            final HttpParams params) {
-        super(LoggingUtils.decorate(handler),
-                new SSLClientConnectionFactory(sslcontext, contextMap, sslHandler, params));
-    }
-
-    /**
-     * Custom NHttpClientConnectionFactory implementation. Most of this code has been borrowed
-     * from the SSLNHttpClientConnectionFactory class of HttpCore-NIO. This custom implementation
-     * allows using different SSLContext instances for different target endpoints (custom SSL
-     * profiles feature). Hopefully a future HttpCore-NIO API will provide an easier way to
-     * customize the way SSLIOSession instances are created and we will be able to get rid of this.
-     */
-    private static class SSLClientConnectionFactory
-            implements NHttpConnectionFactory<DefaultNHttpClientConnection> {
-
-        private final HttpResponseFactory responseFactory;
-        private final ByteBufferAllocator allocator;
-        private final SSLContext sslcontext;
-        private final SSLSetupHandler sslHandler;
-        private final HttpParams params;
-        private final Map<String,SSLContext> contextMap;
-
-        public SSLClientConnectionFactory(
-                final SSLContext sslcontext,
-                final Map<String,SSLContext> contextMap,
-                final SSLSetupHandler sslHandler,
-                final HttpParams params) {
-
-            if (params == null) {
-                throw new IllegalArgumentException("HTTP parameters may not be null");
-            }
-            this.sslcontext = sslcontext;
-            this.contextMap = contextMap;
-            this.sslHandler = sslHandler;
-            this.responseFactory = new DefaultHttpResponseFactory();
-            this.allocator = new HeapByteBufferAllocator();
-            this.params = params;
-        }
-
-        protected DefaultNHttpClientConnection createConnection(IOSession session,
-                                                                HttpResponseFactory responseFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            session = org.apache.synapse.transport.passthru.logging.LoggingUtils.decorate(session, "sslclient");
-            return LoggingUtils.createClientConnection(
-                    session,
-                    responseFactory,
-                    allocator,
-                    params);
-        }
-
-        private SSLContext getDefaultSSLContext() {
-            SSLContext sslcontext;
-            try {
-                sslcontext = SSLContext.getInstance("TLS");
-                sslcontext.init(null, null, null);
-            } catch (Exception ex) {
-                throw new IllegalStateException("Failure initializing default SSL context", ex);
-            }
-            return sslcontext;
-        }
-
-        private SSLContext getSSLContext(IOSession session) {
-            InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();
-            String host = address.getHostName() + ":" + address.getPort();
-            SSLContext customContext = null;
-            if (contextMap != null) {
-                // See if there's a custom SSL profile configured for this server
-                customContext = contextMap.get(host);
-            }
-
-            if (customContext == null) {
-                customContext = this.sslcontext != null ? this.sslcontext : getDefaultSSLContext();
-            }
-            return customContext;
-        }
-
-        public DefaultNHttpClientConnection createConnection(final IOSession session) {
-            SSLContext sslcontext = getSSLContext(session);
-            SSLIOSession ssliosession = new SSLIOSession(session, SSLMode.CLIENT,
-                    sslcontext, this.sslHandler);
-            session.setAttribute(SSLIOSession.SESSION_KEY, ssliosession);
-            DefaultNHttpClientConnection conn = createConnection(
-                    ssliosession, this.responseFactory, this.allocator, this.params);
-            int timeout = HttpConnectionParams.getSoTimeout(this.params);
-            conn.setSocketTimeout(timeout);
-            return conn;
-        }
-    }
-
-}

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLClientIOEventDispatch.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServerConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServerConnection.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServerConnection.java	(nonexistent)
@@ -1,199 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import java.io.IOException;
-import java.nio.channels.ReadableByteChannel;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.Header;
-import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.HttpResponse;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.nio.NHttpMessageParser;
-import org.apache.http.nio.NHttpMessageWriter;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionInputBuffer;
-import org.apache.http.nio.reactor.SessionOutputBuffer;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-public class LoggingNHttpServerConnection extends DefaultNHttpServerConnection {
-
-    private static final AtomicLong COUNT = new AtomicLong();
-
-    private final Log log;
-    private final Log iolog;
-    private final Log headerlog;
-    private final Log accesslog;
-    private final Log wirelog;
-    private final String id;
-
-    public LoggingNHttpServerConnection(
-            final IOSession session,
-            final HttpRequestFactory requestFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        super(session, requestFactory, allocator, params);
-        this.log = LogFactory.getLog(getClass());
-        this.iolog = LogFactory.getLog(session.getClass());
-        this.headerlog = LogFactory.getLog(LoggingUtils.HEADER_LOG_ID);
-        this.wirelog = LogFactory.getLog(LoggingUtils.WIRE_LOG_ID);
-        this.accesslog = LogFactory.getLog(LoggingUtils.ACCESS_LOG_ID);
-        this.id = "http-incoming-" + COUNT.incrementAndGet();
-        if (this.iolog.isDebugEnabled() || this.wirelog.isDebugEnabled()) {
-            this.session = new LoggingIOSession(session, this.id, this.iolog, this.wirelog);
-        }
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Close connection");
-        }
-        super.close();
-    }
-
-    @Override
-    public void shutdown() throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Shutdown connection");
-        }
-        super.shutdown();
-    }
-
-    @Override
-    public void submitResponse(final HttpResponse response) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": "  + response.getStatusLine().toString());
-        }
-        super.submitResponse(response);
-    }
-
-    @Override
-    public void consumeInput(final NHttpServerEventHandler handler) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Consume input");
-        }
-        super.consumeInput(handler);
-    }
-
-    @Override
-    public void produceOutput(final NHttpServerEventHandler handler) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Produce output");
-        }
-        super.produceOutput(handler);
-    }
-
-    @Override
-    protected NHttpMessageWriter<HttpResponse> createResponseWriter(
-            final SessionOutputBuffer buffer,
-            final HttpParams params) {
-        return new LoggingNHttpMessageWriter(
-                super.createResponseWriter(buffer, params));
-    }
-
-    @Override
-    protected NHttpMessageParser<HttpRequest> createRequestParser(
-            final SessionInputBuffer buffer,
-            final HttpRequestFactory requestFactory,
-            final HttpParams params) {
-        return new LoggingNHttpMessageParser(
-                super.createRequestParser(buffer, requestFactory, params));
-    }
-
-    @Override
-    public String toString() {
-        return this.id;
-    }
-
-    class LoggingNHttpMessageWriter implements NHttpMessageWriter<HttpResponse> {
-
-        private final NHttpMessageWriter<HttpResponse> writer;
-
-        public LoggingNHttpMessageWriter(final NHttpMessageWriter<HttpResponse> writer) {
-            super();
-            this.writer = writer;
-        }
-
-        public void reset() {
-            this.writer.reset();
-        }
-
-        public void write(final HttpResponse message) throws IOException, HttpException {
-            if (message != null && headerlog.isDebugEnabled()) {
-                headerlog.debug(id + " << " + message.getStatusLine().toString());
-                Header[] headers = message.getAllHeaders();
-                for (Header header : headers) {
-                    headerlog.debug(id + " << " + header.toString());
-                }
-            }
-
-            if (message != null && accesslog.isInfoEnabled()) {
-                AccessHandler.getAccess().addAccessToQueue(message);
-            }
-
-            this.writer.write(message);
-        }
-
-    }
-
-    class LoggingNHttpMessageParser implements NHttpMessageParser<HttpRequest> {
-
-        private final NHttpMessageParser<HttpRequest> parser;
-
-        public LoggingNHttpMessageParser(final NHttpMessageParser<HttpRequest> parser) {
-            super();
-            this.parser = parser;
-        }
-
-        public void reset() {
-            this.parser.reset();
-        }
-
-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
-            return this.parser.fillBuffer(channel);
-        }
-
-        public HttpRequest parse() throws IOException, HttpException {
-            HttpRequest message = this.parser.parse();
-            if (message != null && headerlog.isDebugEnabled()) {
-                headerlog.debug(id + " >> " + message.getRequestLine().toString());
-                Header[] headers = message.getAllHeaders();
-                for (Header header : headers) {
-                    headerlog.debug(id + " >> " + header.toString());
-                }
-            }
-            if (message != null && accesslog.isInfoEnabled()) {
-                AccessHandler.getAccess().addAccessToQueue(message);
-            }
-
-            return message;
-        }
-
-    }
-
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServerConnection.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Deleted: svn:keywords
## -1 +0,0 ##
-Date Author Id Revision HeadURL
\ No newline at end of property
Deleted: svn:mime-type
## -1 +0,0 ##
-text/plain
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainClientIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainClientIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainClientIOEventDispatch.java	(nonexistent)
@@ -1,56 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.nio.DefaultHttpClientIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.impl.nio.DefaultNHttpClientConnectionFactory;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-public class PlainClientIOEventDispatch extends DefaultHttpClientIODispatch {
-
-    public PlainClientIOEventDispatch(final NHttpClientEventHandler handler, final HttpParams params) {
-        super(LoggingUtils.decorate(handler), new TargetConnectionFactory(params));
-    }
-
-    private static class TargetConnectionFactory extends DefaultNHttpClientConnectionFactory {
-
-        public TargetConnectionFactory(HttpParams params) {
-            super(params);
-        }
-
-        @Override
-        protected DefaultNHttpClientConnection createConnection(IOSession session,
-                                                                HttpResponseFactory responseFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            return LoggingUtils.createClientConnection(
-                    session,
-                    responseFactory,
-                    allocator,
-                    params);
-        }
-    }
-    
-}

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainClientIOEventDispatch.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingIOSession.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingIOSession.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingIOSession.java	(nonexistent)
@@ -1,224 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.apache.synapse.transport.nhttp;
-
-import java.io.IOException;
-import java.net.SocketAddress;
-import java.nio.ByteBuffer;
-import java.nio.channels.ByteChannel;
-import java.nio.channels.SelectionKey;
-
-import org.apache.commons.logging.Log;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionBufferStatus;
-
-/**
- * Decorator class intended to transparently extend an {@link IOSession} 
- * with basic event logging capabilities using Commons Logging. 
- */
-class LoggingIOSession implements IOSession {
-
-    private final Log log;
-    private final Wire wirelog;
-    private final String id;
-    private final IOSession session;
-    private final ByteChannel channel;
-
-    public LoggingIOSession(final IOSession session, final String id, final Log log, final Log wirelog) {
-        super();
-        if (session == null) {
-            throw new IllegalArgumentException("I/O session may not be null");
-        }
-        this.session = session;
-        this.channel = new LoggingByteChannel();
-        this.id = id;
-        this.log = log;
-        this.wirelog = new Wire(wirelog, this.id);
-    }
-
-    public ByteChannel channel() {
-        return this.channel;
-    }
-
-    public SocketAddress getLocalAddress() {
-        return this.session.getLocalAddress();
-    }
-
-    public SocketAddress getRemoteAddress() {
-        return this.session.getRemoteAddress();
-    }
-
-    public int getEventMask() {
-        return this.session.getEventMask();
-    }
-
-    private static String formatOps(int ops) {
-        StringBuilder buffer = new StringBuilder(6);
-        buffer.append('[');
-        if ((ops & SelectionKey.OP_READ) > 0) {
-            buffer.append('r');
-        }
-        if ((ops & SelectionKey.OP_WRITE) > 0) {
-            buffer.append('w');
-        }
-        if ((ops & SelectionKey.OP_ACCEPT) > 0) {
-            buffer.append('a');
-        }
-        if ((ops & SelectionKey.OP_CONNECT) > 0) {
-            buffer.append('c');
-        }
-        buffer.append(']');
-        return buffer.toString();
-    }
-
-    public void setEventMask(int ops) {
-        this.session.setEventMask(ops);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Event mask set " + formatOps(ops));
-        }
-    }
-
-    public void setEvent(int op) {
-        this.session.setEvent(op);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Event set " + formatOps(op));
-        }
-    }
-
-    public void clearEvent(int op) {
-        this.session.clearEvent(op);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Event cleared " + formatOps(op));
-        }
-    }
-
-    public void close() {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Close");
-        }
-        this.session.close();
-    }
-
-    public int getStatus() {
-        return this.session.getStatus();
-    }
-
-    public boolean isClosed() {
-        return this.session.isClosed();
-    }
-
-    public void shutdown() {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Shutdown");
-        }
-        this.session.shutdown();
-    }
-
-    public int getSocketTimeout() {
-        return this.session.getSocketTimeout();
-    }
-
-    public void setSocketTimeout(int timeout) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Set timeout " + timeout);
-        }
-        this.session.setSocketTimeout(timeout);
-    }
-
-    public void setBufferStatus(final SessionBufferStatus status) {
-        this.session.setBufferStatus(status);
-    }
-
-    public boolean hasBufferedInput() {
-        return this.session.hasBufferedInput();
-    }
-
-    public boolean hasBufferedOutput() {
-        return this.session.hasBufferedOutput();
-    }
-
-    public Object getAttribute(final String name) {
-        return this.session.getAttribute(name);
-    }
-
-    public void setAttribute(final String name, final Object obj) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Set attribute " + name);
-        }
-        this.session.setAttribute(name, obj);
-    }
-
-    public Object removeAttribute(final String name) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + " " + this.session + ": Remove attribute " + name);
-        }
-        return this.session.removeAttribute(name);
-    }
-
-    @Override
-    public String toString() {
-        return this.id + " " + this.session.toString();
-    }
-
-    class LoggingByteChannel implements ByteChannel {
-
-        public int read(final ByteBuffer dst) throws IOException {
-            int bytesRead = session.channel().read(dst);
-            if (log.isDebugEnabled()) {
-                log.debug(id + " " + session + ": " + bytesRead + " bytes read");
-            }
-            if (bytesRead > 0 && wirelog.isEnabled()) {
-                ByteBuffer b = dst.duplicate();
-                int p = b.position();
-                b.limit(p);
-                b.position(p - bytesRead);
-                wirelog.input(b);
-            }
-            return bytesRead;
-        }
-
-        public int write(final ByteBuffer src) throws IOException {
-            int byteWritten = session.channel().write(src);
-            if (log.isDebugEnabled()) {
-                log.debug(id + " " + session + ": " + byteWritten + " bytes written");
-            }
-            if (byteWritten > 0 && wirelog.isEnabled()) {
-                ByteBuffer b = src.duplicate();
-                int p = b.position();
-                b.limit(p);
-                b.position(p - byteWritten);
-                wirelog.output(b);
-            }
-            return byteWritten;
-        }
-
-        public void close() throws IOException {
-            if (log.isDebugEnabled()) {
-                log.debug(id + " " + session + ": Channel close");
-            }
-            session.channel().close();
-        }
-
-        public boolean isOpen() {
-            return session.channel().isOpen();
-        }
-
-    }
-
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingIOSession.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServiceHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServiceHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServiceHandler.java	(nonexistent)
@@ -1,131 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import java.io.IOException;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.ConnectionClosedException;
-import org.apache.http.nio.*;
-
-/**
- * Decorator class intended to transparently extend an {@link NHttpServerEventHandler}
- * with basic event logging capabilities using Commons Logging. 
- */
-class LoggingNHttpServiceHandler implements NHttpServerEventHandler {
-
-    private final Log log;
-    private final NHttpServerEventHandler handler;
-    
-    public LoggingNHttpServiceHandler(
-            final Log log, 
-            final NHttpServerEventHandler handler) {
-        super();
-        if (handler == null) {
-            throw new IllegalArgumentException("HTTP service handler may not be null");
-        }
-        this.handler = handler;
-        this.log = LogFactory.getLog(handler.getClass());
-    }
-    
-    public void connected(final NHttpServerConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Connected");
-        }
-        this.handler.connected(conn);
-    }
-
-    public void closed(final NHttpServerConnection conn) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed");
-        }
-        this.handler.closed(conn);
-    }
-
-    public void endOfInput(NHttpServerConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Closed at remote end");
-        }
-        this.handler.endOfInput(conn);
-    }
-
-    public void exception(NHttpServerConnection conn, Exception ex) {
-        if (ex instanceof ConnectionClosedException ||
-                ex.getMessage().contains("Connection reset by peer") ||
-                ex.getMessage().contains("forcibly closed")) {
-            if (this.log.isDebugEnabled()) {
-                this.log.debug("HTTP connection " + conn + ": " + ex.getMessage() +
-                        " (Probably the keepalive connection was closed)");
-            }
-        } else if (ex instanceof HttpException) {
-            this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
-            this.handler.exception(conn, ex);
-        } else {
-            this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
-        }
-        this.handler.exception(conn, ex);
-    }
-
-    public void requestReceived(final NHttpServerConnection conn) throws IOException, HttpException {
-        HttpRequest request = conn.getHttpRequest();
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": " + request.getRequestLine());
-        }
-        this.handler.requestReceived(conn);
-    }
-
-    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Output ready");
-        }
-        this.handler.outputReady(conn, encoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
-        }
-    }
-
-    public void responseReady(final NHttpServerConnection conn) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Response ready");
-        }
-        this.handler.responseReady(conn);
-    }
-
-    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Input ready");
-        }
-        this.handler.inputReady(conn, decoder);
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
-        }
-    }
-
-    public void timeout(final NHttpServerConnection conn) throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug("HTTP connection " + conn + ": Timeout");
-        }
-        this.handler.timeout(conn);
-    }
-
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpServiceHandler.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLServerIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLServerIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLServerIOEventDispatch.java	(nonexistent)
@@ -1,64 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import javax.net.ssl.SSLContext;
-
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.impl.nio.DefaultHttpServerIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.impl.nio.SSLNHttpServerConnectionFactory;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-public class SSLServerIOEventDispatch
-        extends DefaultHttpServerIODispatch {
-
-    public SSLServerIOEventDispatch(
-            final NHttpServerEventHandler handler,
-            final SSLContext sslcontext,
-            final SSLSetupHandler sslHandler,
-            final HttpParams params) {
-        super(LoggingUtils.decorate(handler), new SSLSourceConnectionFactory(sslcontext, sslHandler, params));
-    }
-
-    private static class SSLSourceConnectionFactory extends SSLNHttpServerConnectionFactory {
-
-        public SSLSourceConnectionFactory(SSLContext sslcontext, SSLSetupHandler sslHandler, HttpParams params) {
-            super(sslcontext, sslHandler, params);
-        }
-
-        @Override
-        protected DefaultNHttpServerConnection createConnection(IOSession session,
-                                                                HttpRequestFactory requestFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            return LoggingUtils.createServerConnection(
-                    session,
-                    requestFactory,
-                    allocator,
-                    params);
-        }
-    }
-    
-}

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/SSLServerIOEventDispatch.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainServerIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainServerIOEventDispatch.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainServerIOEventDispatch.java	(nonexistent)
@@ -1,56 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import org.apache.http.HttpRequestFactory;
-import org.apache.http.impl.nio.DefaultHttpServerIODispatch;
-import org.apache.http.impl.nio.DefaultNHttpServerConnection;
-import org.apache.http.impl.nio.DefaultNHttpServerConnectionFactory;
-import org.apache.http.nio.NHttpServerEventHandler;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-public class PlainServerIOEventDispatch extends DefaultHttpServerIODispatch {
-
-    public PlainServerIOEventDispatch(NHttpServerEventHandler handler, HttpParams params) {
-        super(LoggingUtils.decorate(handler), new SourceConnectionFactory(params));
-    }
-
-    private static class SourceConnectionFactory extends DefaultNHttpServerConnectionFactory {
-
-        public SourceConnectionFactory(HttpParams params) {
-            super(params);
-        }
-
-        @Override
-        protected DefaultNHttpServerConnection createConnection(IOSession session,
-                                                                HttpRequestFactory requestFactory,
-                                                                ByteBufferAllocator allocator,
-                                                                HttpParams params) {
-            return LoggingUtils.createServerConnection(
-                    session,
-                    requestFactory,
-                    allocator,
-                    params);
-        }
-    }
-    
-}

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/PlainServerIOEventDispatch.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientConnection.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientConnection.java	(nonexistent)
@@ -1,196 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package org.apache.synapse.transport.nhttp;
-
-import java.io.IOException;
-import java.nio.channels.ReadableByteChannel;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.Header;
-import org.apache.http.HttpException;
-import org.apache.http.HttpRequest;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpResponseFactory;
-import org.apache.http.impl.nio.DefaultNHttpClientConnection;
-import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.NHttpMessageParser;
-import org.apache.http.nio.NHttpMessageWriter;
-import org.apache.http.nio.reactor.IOSession;
-import org.apache.http.nio.reactor.SessionInputBuffer;
-import org.apache.http.nio.reactor.SessionOutputBuffer;
-import org.apache.http.nio.util.ByteBufferAllocator;
-import org.apache.http.params.HttpParams;
-
-public class LoggingNHttpClientConnection extends DefaultNHttpClientConnection {
-
-    private static final AtomicLong COUNT = new AtomicLong();
-
-    private final Log log;
-    private final Log iolog;
-    private final Log headerlog;
-    private final Log wirelog;
-    private final Log accesslog;
-    private final String id;
-
-    public LoggingNHttpClientConnection(
-            final IOSession session,
-            final HttpResponseFactory responseFactory,
-            final ByteBufferAllocator allocator,
-            final HttpParams params) {
-        super(session, responseFactory, allocator, params);
-        this.log = LogFactory.getLog(getClass());
-        this.iolog = LogFactory.getLog(session.getClass());
-        this.headerlog = LogFactory.getLog(LoggingUtils.HEADER_LOG_ID);
-        this.wirelog = LogFactory.getLog(LoggingUtils.WIRE_LOG_ID);
-        this.accesslog = LogFactory.getLog(LoggingUtils.ACCESS_LOG_ID);
-        this.id = "http-outgoing-" + COUNT.incrementAndGet();
-        if (this.iolog.isDebugEnabled() || this.wirelog.isDebugEnabled()) {
-            this.session = new LoggingIOSession(session, this.id, this.iolog, this.wirelog);
-        }
-    }
-
-    @Override
-    public void close() throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Close connection");
-        }
-        super.close();
-    }
-
-    @Override
-    public void shutdown() throws IOException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Shutdown connection");
-        }
-        super.shutdown();
-    }
-
-    @Override
-    public void submitRequest(final HttpRequest request) throws IOException, HttpException {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": "  + request.getRequestLine().toString());
-        }
-        super.submitRequest(request);
-    }
-
-    @Override
-    public void consumeInput(final NHttpClientEventHandler handler) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Consume input");
-        }
-        super.consumeInput(handler);
-    }
-
-    @Override
-    public void produceOutput(final NHttpClientEventHandler handler) {
-        if (this.log.isDebugEnabled()) {
-            this.log.debug(this.id + ": Produce output");
-        }
-        super.produceOutput(handler);
-    }
-
-    @Override
-    protected NHttpMessageWriter<HttpRequest> createRequestWriter(
-            final SessionOutputBuffer buffer,
-            final HttpParams params) {
-        return new LoggingNHttpMessageWriter(
-                super.createRequestWriter(buffer, params));
-    }
-
-    @Override
-    protected NHttpMessageParser<HttpResponse> createResponseParser(
-            final SessionInputBuffer buffer,
-            final HttpResponseFactory responseFactory,
-            final HttpParams params) {
-        return new LoggingNHttpMessageParser(
-                super.createResponseParser(buffer, responseFactory, params));
-    }
-
-    @Override
-    public String toString() {
-        return this.id;
-    }
-
-    class LoggingNHttpMessageWriter implements NHttpMessageWriter<HttpRequest> {
-
-        private final NHttpMessageWriter<HttpRequest> writer;
-
-        public LoggingNHttpMessageWriter(final NHttpMessageWriter<HttpRequest> writer) {
-            super();
-            this.writer = writer;
-        }
-
-        public void reset() {
-            this.writer.reset();
-        }
-
-        public void write(final HttpRequest message) throws IOException, HttpException {
-            if (message != null && headerlog.isDebugEnabled()) {
-                headerlog.debug(id + " >> " + message.getRequestLine().toString());
-                Header[] headers = message.getAllHeaders();
-                for (Header header : headers) {
-                    headerlog.debug(id + " >> " + header.toString());
-                }
-            }
-            if (message != null && accesslog.isInfoEnabled()) {
-                AccessHandler.getAccess().addAccessToQueue(message);
-            }
-            this.writer.write(message);
-        }
-
-    }
-
-    class LoggingNHttpMessageParser implements NHttpMessageParser<HttpResponse> {
-
-        private final NHttpMessageParser<HttpResponse> parser;
-
-        public LoggingNHttpMessageParser(final NHttpMessageParser<HttpResponse> parser) {
-            super();
-            this.parser = parser;
-        }
-
-        public void reset() {
-            this.parser.reset();
-        }
-
-        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
-            return this.parser.fillBuffer(channel);
-        }
-
-        public HttpResponse parse() throws IOException, HttpException {
-            HttpResponse message = this.parser.parse();
-            if (message != null && headerlog.isDebugEnabled()) {
-                headerlog.debug(id + " << " + message.getStatusLine().toString());
-                Header[] headers = message.getAllHeaders();
-                for (Header header : headers) {
-                    headerlog.debug(id + " << " + header.toString());
-                }
-            }
-            if (message != null && accesslog.isInfoEnabled()) {
-                AccessHandler.getAccess().addAccessToQueue(message);
-            }
-            return message;
-        }
-
-    }
-
-}
\ No newline at end of file

Property changes on: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/LoggingNHttpClientConnection.java
___________________________________________________________________
Deleted: svn:eol-style
## -1 +0,0 ##
-native
\ No newline at end of property
Deleted: svn:keywords
## -1 +0,0 ##
-Date Author Id Revision HeadURL
\ No newline at end of property
Deleted: svn:mime-type
## -1 +0,0 ##
-text/plain
\ No newline at end of property
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLClientConnectionFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLClientConnectionFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLClientConnectionFactory.java	(revision 1512866)
@@ -0,0 +1,74 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.ssl.SSLIOSession;
+import org.apache.http.nio.reactor.ssl.SSLMode;
+import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
+
+import javax.net.ssl.SSLContext;
+import java.net.InetSocketAddress;
+import java.util.Map;
+
+public class LoggingNHttpSSLClientConnectionFactory extends LoggingNHttpClientConnectionFactory {
+
+    private SSLContext sslContext;
+    private SSLSetupHandler sslSetupHandler;
+    private Map<String,SSLContext> customContexts;
+
+    public LoggingNHttpSSLClientConnectionFactory(ConnectionConfig config,
+                                                  SSLContext sslContext,
+                                                  SSLSetupHandler sslSetupHandler,
+                                                  Map<String, SSLContext> customContexts) {
+        super(config);
+        this.sslContext = sslContext;
+        this.sslSetupHandler = sslSetupHandler;
+        this.customContexts = customContexts;
+    }
+
+    @Override
+    public DefaultNHttpClientConnection createConnection(IOSession session) {
+        final SSLIOSession ssliosession = new SSLIOSession(
+                session,
+                SSLMode.CLIENT,
+                getSSLContext(session),
+                sslSetupHandler);
+        session.setAttribute(SSLIOSession.SESSION_KEY, ssliosession);
+        return super.createConnection(ssliosession);
+    }
+
+    private SSLContext getSSLContext(IOSession session) {
+        InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();
+        String host = address.getHostName() + ":" + address.getPort();
+        SSLContext customContext = null;
+        if (customContexts != null) {
+            // See if there's a custom SSL profile configured for this server
+            customContext = customContexts.get(host);
+        }
+
+        if (customContext == null) {
+            customContext = sslContext;
+        }
+        return customContext;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingConstants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingConstants.java	(revision 1512866)
@@ -0,0 +1,43 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+public class LoggingConstants {
+
+    public static final String SOURCE_CONNECTION_LOG_ID =
+            "org.apache.synapse.transport.http.conn.SourceConnection";
+    public static final String TARGET_CONNECTION_LOG_ID =
+            "org.apache.synapse.transport.http.conn.TargetConnection";
+
+    public static final String SOURCE_HEADER_LOG_ID =
+            "org.apache.synapse.transport.http.headers.SourceHeaders";
+    public static final String TARGET_HEADER_LOG_ID =
+            "org.apache.synapse.transport.http.headers.TargetHeaders";
+
+    public static final String SOURCE_SESSION_LOG_ID =
+            "org.apache.synapse.transport.http.session.SourceSession";
+    public static final String TARGET_SESSION_LOG_ID =
+            "org.apache.synapse.transport.http.session.TargetSession";
+
+    public static final String SOURCE_WIRE_LOG_ID =
+            "org.apache.synapse.transport.http.wire.SourceWire";
+    public static final String TARGET_WIRE_LOG_ID =
+            "org.apache.synapse.transport.http.wire.TargetWire";
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingClientEventHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingClientEventHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingClientEventHandler.java	(revision 1512866)
@@ -0,0 +1,125 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpException;
+import org.apache.http.HttpResponse;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.http.nio.NHttpClientEventHandler;
+
+import java.io.IOException;
+
+public class LoggingClientEventHandler implements NHttpClientEventHandler {
+
+    private final Log log;
+
+    private final NHttpClientEventHandler handler;
+
+    public LoggingClientEventHandler(final NHttpClientEventHandler handler) {
+        super();
+        if (handler == null) {
+            throw new IllegalArgumentException("HTTP client handler may not be null");
+        }
+        this.handler = handler;
+        this.log = LogFactory.getLog(handler.getClass());
+    }
+
+    public void connected(final NHttpClientConnection conn, final Object attachment) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Connected (" + attachment + ")");
+        }
+        this.handler.connected(conn, attachment);
+    }
+
+    public void closed(final NHttpClientConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed");
+        }
+        this.handler.closed(conn);
+    }
+
+    public void endOfInput(NHttpClientConnection conn) throws IOException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed at remote end");
+        }
+        this.handler.endOfInput(conn);
+    }
+
+    public void exception(NHttpClientConnection conn, Exception ex) {
+        // Do not log errors at this level - Actual handler implementation should do that
+        this.handler.exception(conn, ex);
+    }
+
+    public void requestReady(final NHttpClientConnection conn) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": InRequest ready" + getRequestMessageID(conn));
+        }
+        this.handler.requestReady(conn);
+    }
+
+    public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Output ready" + getRequestMessageID(conn));
+        }
+        this.handler.outputReady(conn, encoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
+        }
+    }
+
+    public void responseReceived(final NHttpClientConnection conn) throws IOException, HttpException {
+        HttpResponse response = conn.getHttpResponse();
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + " : "
+                    + response.getStatusLine() + getRequestMessageID(conn));
+        }
+        this.handler.responseReceived(conn);
+    }
+
+    public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Input ready" + getRequestMessageID(conn));
+        }
+        this.handler.inputReady(conn, decoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
+        }
+    }
+
+    public void timeout(final NHttpClientConnection conn) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Timeout" + getRequestMessageID(conn));
+        }
+        this.handler.timeout(conn);
+    }
+
+    private static String getRequestMessageID(final NHttpClientConnection conn) {
+        /*Axis2HttpRequest axis2Request = (Axis2HttpRequest)
+                conn.getContext().getAttribute(ClientHandler.AXIS2_HTTP_REQUEST);
+        if (axis2Request != null) {
+            return " [InRequest Message ID : " + axis2Request.getMsgContext().getMessageID() + "]";
+        }*/
+        return "";
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingUtils.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingUtils.java	(revision 1512866)
@@ -0,0 +1,80 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.impl.nio.DefaultHttpClientIODispatch;
+import org.apache.http.impl.nio.DefaultHttpServerIODispatch;
+import org.apache.http.nio.NHttpClientEventHandler;
+import org.apache.http.nio.NHttpServerEventHandler;
+import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
+
+import javax.net.ssl.SSLContext;
+import java.util.Map;
+
+public class LoggingUtils {
+
+    private static NHttpClientEventHandler decorate(NHttpClientEventHandler handler) {
+        Log log = LogFactory.getLog(handler.getClass());
+        if (log.isDebugEnabled()) {
+            handler = new LoggingClientEventHandler(handler);
+        }
+        return handler;
+    }
+
+    private static NHttpServerEventHandler decorate(NHttpServerEventHandler handler) {
+        Log log = LogFactory.getLog(handler.getClass());
+        if (log.isDebugEnabled()) {
+            handler = new LoggingServerEventHandler(handler);
+        }
+        return handler;
+    }
+
+    public static DefaultHttpServerIODispatch getServerIODispatch(final NHttpServerEventHandler handler,
+                                                                  final ConnectionConfig config) {
+        return new DefaultHttpServerIODispatch(decorate(handler),
+                new LoggingNHttpServerConnectionFactory(config));
+    }
+
+    public static DefaultHttpServerIODispatch getServerIODispatch(final NHttpServerEventHandler handler,
+                                                                  final ConnectionConfig config,
+                                                                  final SSLContext sslContext,
+                                                                  final SSLSetupHandler sslSetupHandler) {
+        return new DefaultHttpServerIODispatch(decorate(handler),
+                new LoggingNHttpSSLServerConnectionFactory(config, sslContext, sslSetupHandler));
+    }
+
+    public static DefaultHttpClientIODispatch getClientIODispatch(final NHttpClientEventHandler handler,
+                                                                  final ConnectionConfig config) {
+        return new DefaultHttpClientIODispatch(decorate(handler),
+                new LoggingNHttpClientConnectionFactory(config));
+    }
+
+    public static DefaultHttpClientIODispatch getClientIODispatch(final NHttpClientEventHandler handler,
+                                                                  final ConnectionConfig config,
+                                                                  final SSLContext sslContext,
+                                                                  final SSLSetupHandler sslSetupHandler,
+                                                                  Map<String, SSLContext> customContexts) {
+        return new DefaultHttpClientIODispatch(decorate(handler),
+                new LoggingNHttpSSLClientConnectionFactory(config, sslContext, sslSetupHandler, customContexts));
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NHttpConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NHttpConfiguration.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NHttpConfiguration.java	(revision 1512866)
@@ -19,20 +19,15 @@
 
 package org.apache.synapse.transport.nhttp;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.synapse.commons.util.MiscellaneousUtil;
+import org.apache.synapse.transport.utils.config.HttpTransportConfiguration;
 
-import java.nio.charset.CodingErrorAction;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Properties;
 
 /**
  * Store and manage properties that tune the nhttp transport
  */
-public final class NHttpConfiguration {
+public final class NHttpConfiguration extends HttpTransportConfiguration {
 
     // defaults
     private static final int WORKERS_CORE_THREADS  = 20;
@@ -47,7 +42,6 @@
     private static final String S_T_MAX      = "snd_t_max";
     private static final String S_T_ALIVE    = "snd_alive_sec";
     private static final String S_T_QLEN     = "snd_qlen";
-    private static final String S_IO_WORKERS = "snd_io_threads";
 
     // client sender
     private static final String C_T_CORE     = "lst_t_core";
@@ -54,16 +48,15 @@
     private static final String C_T_MAX      = "lst_t_max";
     private static final String C_T_ALIVE    = "lst_alive_sec";
     private static final String C_T_QLEN     = "lst_qlen";
-    private static final String C_IO_WORKERS = "lst_io_threads";
 
+    private static final String IO_WORKERS = "io_threads_per_reactor";
+
     // general
     private static final String G_BUFFER_SIZE  = "nhttp_buffer_size";
     private static final String G_DISABLED_HTTP_METHODS = "nhttp_disabled_methods";
 
-    private static final Log log = LogFactory.getLog(NHttpConfiguration.class);
     private static NHttpConfiguration _instance = new NHttpConfiguration();
-    private Properties props;
-    List<String> methods;
+    private List<String> methods;
 
     /** Comma separated list of blocked uris*/
     public static final String BLOCK_SERVICE_LIST = "http.block_service_list";
@@ -71,146 +64,78 @@
     public static final String BLOCK_SERVICE_LIST_DEFAULT = "false";
     
     private NHttpConfiguration() {
-        try {
-            props = MiscellaneousUtil.loadProperties("nhttp.properties");
-        } catch (Exception ignore) {}
+        super("nhttp");
     }
 
+    @Override
+    protected int getThreadsPerReactor() {
+        return getIntProperty(IO_WORKERS, IO_WORKER_COUNT);
+    }
+
     public static NHttpConfiguration getInstance() {
         return _instance;
     }
 
     public int getServerCoreThreads() {
-        return getProperty(S_T_CORE, WORKERS_CORE_THREADS);
+        return getIntProperty(S_T_CORE, WORKERS_CORE_THREADS);
     }
 
     public int getServerMaxThreads() {
-        return getProperty(S_T_MAX, WORKERS_MAX_THREADS);
+        return getIntProperty(S_T_MAX, WORKERS_MAX_THREADS);
     }
 
     public int getServerKeepalive() {
-        return getProperty(S_T_ALIVE, WORKER_KEEP_ALIVE);
+        return getIntProperty(S_T_ALIVE, WORKER_KEEP_ALIVE);
     }
 
     public int getServerQueueLen() {
-        return getProperty(S_T_QLEN, BLOCKING_QUEUE_LENGTH);
+        return getIntProperty(S_T_QLEN, BLOCKING_QUEUE_LENGTH);
     }
 
-    public int getServerIOWorkers() {
-        return getProperty(S_IO_WORKERS, IO_WORKER_COUNT);
-    }
-
-
     public int getClientCoreThreads() {
-        return getProperty(C_T_CORE, WORKERS_CORE_THREADS);
+        return getIntProperty(C_T_CORE, WORKERS_CORE_THREADS);
     }
 
     public int getClientMaxThreads() {
-        return getProperty(C_T_MAX, WORKERS_MAX_THREADS);
+        return getIntProperty(C_T_MAX, WORKERS_MAX_THREADS);
     }
 
     public int getClientKeepalive() {
-        return getProperty(C_T_ALIVE, WORKER_KEEP_ALIVE);
+        return getIntProperty(C_T_ALIVE, WORKER_KEEP_ALIVE);
     }
 
     public int getClientQueueLen() {
-        return getProperty(C_T_QLEN, BLOCKING_QUEUE_LENGTH);
+        return getIntProperty(C_T_QLEN, BLOCKING_QUEUE_LENGTH);
     }
 
-    public int getClientIOWorkers() {
-        return getProperty(C_IO_WORKERS, IO_WORKER_COUNT);
-    }
-
     public int getBufferSize() {
-        return getProperty(G_BUFFER_SIZE, BUFFER_SIZE);
+        return getIntProperty(G_BUFFER_SIZE, BUFFER_SIZE);
     }
 
     public boolean isKeepAliveDisabled() {
-        return getProperty(NhttpConstants.DISABLE_KEEPALIVE, 0) == 1;
+        return getIntProperty(NhttpConstants.DISABLE_KEEPALIVE, 0) == 1;
     }
 
     public boolean isPreserveUserAgentHeader() {
-        return getBooleanValue(NhttpConstants.USER_AGENT_HEADER_PRESERVE, false);
+        return getBooleanProperty(NhttpConstants.USER_AGENT_HEADER_PRESERVE, false);
     }
 
     public boolean isPreserveServerHeader() {
-        return getBooleanValue(NhttpConstants.SERVER_HEADER_PRESERVE, true);
+        return getBooleanProperty(NhttpConstants.SERVER_HEADER_PRESERVE, true);
     }
 
     public boolean isCountConnections() {
-        return getBooleanValue(NhttpConstants.COUNT_CONNECTIONS, false);
+        return getBooleanProperty(NhttpConstants.COUNT_CONNECTIONS, false);
     }
 
     public String isServiceListBlocked() {
-        return getStringValue(BLOCK_SERVICE_LIST, BLOCK_SERVICE_LIST_DEFAULT);
+        return getStringProperty(BLOCK_SERVICE_LIST, BLOCK_SERVICE_LIST_DEFAULT);
     }
 
-    /**
-     * Get properties that tune nhttp transport. Preference to system properties
-     * @param name name of the system/config property
-     * @param def default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public int getProperty(String name, int def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        if (val != null && Integer.valueOf(val) > 0) {
-            if (log.isDebugEnabled()) {
-                log.debug("Using nhttp tuning parameter : " + name + " = " + val);
-            }
-            return Integer.valueOf(val);
-        }        
-        return def;
-    }
-
-    /**
-     * Get properties that tune nhttp transport. Preference to system properties
-     * @param name name of the system/config property
-     * @param def default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public boolean getBooleanValue(String name, boolean def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        if (val != null && Boolean.parseBoolean(val)) {
-            if (log.isDebugEnabled()) {
-                log.debug("Using nhttp tuning parameter : " + name);
-            }
-            return true;
-        } else if (val != null && !Boolean.parseBoolean(val)) {
-            if (log.isDebugEnabled()) {
-                log.debug("Using nhttp tuning parameter : " + name);
-            }
-            return false;
-        }
-        return def;
-    }
-
-    /**
-     * Get properties that tune nhttp transport. Preference to system properties
-     * @param name name of the system/config property
-     * @param def default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public String getStringValue(String name, String def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        return val == null ? def : val;
-    }
-
     public boolean isHttpMethodDisabled(String method) {
         if (methods == null) {
             methods = new ArrayList<String>();
-            String methodsString = getStringValue(G_DISABLED_HTTP_METHODS, "");
+            String methodsString = getStringProperty(G_DISABLED_HTTP_METHODS, "");
             for (String methodStr : methodsString.split(",")) {
                 methods.add(methodStr.trim().toUpperCase());
             }
@@ -218,25 +143,4 @@
         return methods.contains(method);
     }
 
-    public CodingErrorAction getMalformedInputActionValue() {
-        String val = getStringValue(HttpProtocolParams.HTTP_MALFORMED_INPUT_ACTION, "report");
-        return getCodingErrorAction(val);
-    }
-
-    public CodingErrorAction getUnMappableInputActionValue() {
-        String val = getStringValue(HttpProtocolParams.HTTP_UNMAPPABLE_INPUT_ACTION, "report");
-        return getCodingErrorAction(val);
-    }
-
-    private CodingErrorAction getCodingErrorAction(String action) {
-        if ("report".equals(action)) {
-            return CodingErrorAction.REPORT;
-        } else if ("ignore".equals(action)) {
-            return CodingErrorAction.IGNORE;
-        } else if ("replace".equals(action)) {
-            return CodingErrorAction.REPLACE;
-        } else {
-            return CodingErrorAction.REPORT;
-        }
-    }
 }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ListenerContext.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ListenerContext.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ListenerContext.java	(revision 1512866)
@@ -31,12 +31,8 @@
 import org.apache.axis2.transport.base.endpoint.config.URLEndpointsConfigurationFactory;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.impl.nio.reactor.IOReactorConfig;
-import org.apache.http.nio.params.NIOReactorPNames;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
 import org.apache.synapse.commons.evaluators.EvaluatorConstants;
 import org.apache.synapse.commons.evaluators.EvaluatorException;
 import org.apache.synapse.commons.evaluators.Parser;
@@ -83,8 +79,6 @@
     /** The bind addresses as (address, port) pairs */
     private String bindAddress = null;
 
-    private HttpParams params = null;
-
     /** Endpoints configuration for specific HTTP Urls */
     private URLEndpointsConfiguration endpoints = null;
 
@@ -155,9 +149,6 @@
             httpGetRequestProcessor = new DefaultHttpGetProcessor();
         }
 
-        params = getListenerParameters();
-
-
         param = transportIn.getParameter(NhttpConstants.ENDPOINTS_CONFIGURATION);
         if (param != null && param.getValue() != null) {
             endpoints = new URLEndpointsConfigurationFactory().create(param.getValue().toString());
@@ -171,7 +162,7 @@
      * @throws org.apache.axis2.AxisFault if an error occurs
      */
     private void createPriorityConfiguration(String fileName) throws AxisFault {
-        OMElement definitions = null;
+        OMElement definitions;
         try {
             FileInputStream fis = new FileInputStream(fileName);
             definitions = new StAXOMBuilder(fis).getDocumentElement();
@@ -179,8 +170,10 @@
             definitions.build();
         } catch (FileNotFoundException e) {
             handleException("Priority configuration file cannot be found : " + fileName, e);
+            return;
         } catch (XMLStreamException e) {
             handleException("Error parsing priority configuration xml file " + fileName, e);
+            return;
         }
 
         OMElement executorElem = definitions.getFirstChildWithName(
@@ -243,51 +236,14 @@
         return null;
     }
 
-    /**
-     * get HTTP protocol parameters to which the listener must adhere to
-     * @return the applicable HTTP protocol parameters
-     */
-    private HttpParams getListenerParameters() {
-        HttpParams params = new BasicHttpParams();
+    public ConnectionConfig getConnectionConfig() {
         NHttpConfiguration cfg = NHttpConfiguration.getInstance();
-        params
-            .setIntParameter(HttpConnectionParams.SO_TIMEOUT,
-                cfg.getProperty(NhttpConstants.SO_TIMEOUT_RECEIVER, 60000))
-            .setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,
-                cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024))
-            .setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK,
-                cfg.getProperty(HttpConnectionParams.STALE_CONNECTION_CHECK, 0) == 1)
-            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY,
-                cfg.getProperty(HttpConnectionParams.TCP_NODELAY, 1) == 1)
-            .setParameter(HttpProtocolParams.ORIGIN_SERVER, "Synapse-HttpComponents-NIO")
-            .setParameter(
-                    HttpProtocolParams.HTTP_MALFORMED_INPUT_ACTION,
-                    cfg.getMalformedInputActionValue())
-            .setParameter(
-                    HttpProtocolParams.HTTP_UNMAPPABLE_INPUT_ACTION,
-                    cfg.getUnMappableInputActionValue());
-
-        if (cfg.getBooleanValue(NIOReactorPNames.INTEREST_OPS_QUEUEING, false)) {
-            params.setBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING, true);
-        }
-        return params;
+        return cfg.getConnectionConfig();
     }
 
     public IOReactorConfig getReactorConfig() {
-        IOReactorConfig config = new IOReactorConfig();
         NHttpConfiguration cfg = NHttpConfiguration.getInstance();
-        config.setIoThreadCount(cfg.getServerIOWorkers());
-        config.setSoTimeout(cfg.getProperty(NhttpConstants.SO_TIMEOUT_RECEIVER, 60000));
-        config.setSndBufSize(cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setRcvBufSize(cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setTcpNoDelay(cfg.getProperty(HttpConnectionParams.TCP_NODELAY, 1) == 1);
-        if (cfg.getBooleanValue(NIOReactorPNames.INTEREST_OPS_QUEUEING, false)) {
-            config.setInterestOpQueued(true);
-        }
-        if (cfg.getBooleanValue(HttpConnectionParams.SO_REUSEADDR, false)) {
-            config.setSoReuseAddress(true);
-        }
-        return config;
+        return cfg.getReactorConfig();
     }
 
     public ConfigurationContext getCfgCtx() {
@@ -334,10 +290,6 @@
         return bindAddress;
     }
 
-    public HttpParams getParams() {
-        return params;
-    }
-
     public URLEndpointsConfiguration getEndpoints() {
         return endpoints;
     }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java	(revision 1512866)
@@ -41,21 +41,17 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.*;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.entity.BasicHttpEntity;
 import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
 import org.apache.http.impl.nio.reactor.IOReactorConfig;
 import org.apache.http.nio.NHttpClientConnection;
 import org.apache.http.nio.NHttpClientEventHandler;
-import org.apache.http.nio.params.NIOReactorPNames;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOReactorExceptionHandler;
 import org.apache.http.nio.reactor.SessionRequest;
 import org.apache.http.nio.reactor.SessionRequestCallback;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.HTTP;
 import org.apache.axis2.transport.base.threads.NativeThreadFactory;
 import org.apache.synapse.transport.nhttp.debug.ClientConnectionDebug;
@@ -63,6 +59,7 @@
 import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
 import org.apache.synapse.transport.nhttp.util.NhttpUtil;
 import org.apache.synapse.transport.nhttp.util.NhttpMetricsCollector;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 import javax.net.ssl.SSLContext;
 import java.io.IOException;
@@ -158,7 +155,6 @@
         preserveUserAgentHeader = NHttpConfiguration.getInstance().isPreserveUserAgentHeader();
         preserveServerHeader = NHttpConfiguration.getInstance().isPreserveServerHeader();
 
-        HttpParams params = getClientParameters();
         try {
             String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";
             ioReactor = new DefaultConnectingIOReactor(
@@ -182,9 +178,9 @@
         }
 
         metrics = new NhttpMetricsCollector(false, transportOut.getName());
-        handler = new ClientHandler(cfgCtx, params, metrics);
+        handler = new ClientHandler(cfgCtx, metrics);
         final IOEventDispatch ioEventDispatch = getEventDispatch(
-            handler, sslContext, sslSetupHandler, params, transportOut);
+            handler, sslContext, sslSetupHandler, getConnectionConfig(), transportOut);
 
         // start the Sender in a new seperate thread
         Thread t = new Thread(new Runnable() {
@@ -216,16 +212,15 @@
      * @param handler The NHTTP client handler instance
      * @param sslContext SSL context used by the sender or null
      * @param sslIOSessionHandler SSL session handler or null
-     * @param params HTTP parameters
+     * @param config ConnectionConfig object
      * @param trpOut Transport out description
      * @return an IOEventDispatch instance
      * @throws AxisFault on error
      */
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler, SSLContext sslContext,
-        SSLSetupHandler sslIOSessionHandler, HttpParams params,
+        SSLSetupHandler sslIOSessionHandler, ConnectionConfig config,
         TransportOutDescription trpOut) throws AxisFault {
-
-        return new PlainClientIOEventDispatch(handler, params);
+        return LoggingUtils.getClientIODispatch(handler, config);
     }
 
     /**
@@ -253,47 +248,14 @@
      * get HTTP protocol parameters to which the sender must adhere to
      * @return the applicable HTTP protocol parameters
      */
-    private HttpParams getClientParameters() {
+    private ConnectionConfig getConnectionConfig() {
         NHttpConfiguration cfg = NHttpConfiguration.getInstance();
-        HttpParams params = new BasicHttpParams();
-        params
-            .setIntParameter(HttpConnectionParams.SO_TIMEOUT,
-                cfg.getProperty(NhttpConstants.SO_TIMEOUT_SENDER, 60000))
-            .setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,
-                cfg.getProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 10000))
-            .setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,
-                cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024))
-            .setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK,
-                cfg.getProperty(HttpConnectionParams.STALE_CONNECTION_CHECK, 0) == 1)
-            .setBooleanParameter(HttpConnectionParams.TCP_NODELAY,
-                cfg.getProperty(HttpConnectionParams.TCP_NODELAY, 1) == 1)
-            .setParameter(HttpProtocolParams.USER_AGENT, "Synapse-HttpComponents-NIO")
-            .setParameter(
-                    HttpProtocolParams.HTTP_MALFORMED_INPUT_ACTION,
-                    cfg.getMalformedInputActionValue())
-            .setParameter(
-                    HttpProtocolParams.HTTP_UNMAPPABLE_INPUT_ACTION,
-                    cfg.getUnMappableInputActionValue());
-
-        if (cfg.getBooleanValue(NIOReactorPNames.INTEREST_OPS_QUEUEING, false)) {
-            params.setBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING, true);
-        }
-        return params;
+        return cfg.getConnectionConfig();
     }
 
     private IOReactorConfig getReactorConfig() {
-        IOReactorConfig config = new IOReactorConfig();
         NHttpConfiguration cfg = NHttpConfiguration.getInstance();
-        config.setIoThreadCount(cfg.getClientIOWorkers());
-        config.setSoTimeout(cfg.getProperty(NhttpConstants.SO_TIMEOUT_SENDER, 60000));
-        config.setConnectTimeout(cfg.getProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 10000));
-        config.setSndBufSize(cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setRcvBufSize(cfg.getProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setTcpNoDelay(cfg.getProperty(HttpConnectionParams.TCP_NODELAY, 1) == 1);
-        if (cfg.getBooleanValue(NIOReactorPNames.INTEREST_OPS_QUEUEING, false)) {
-            config.setInterestOpQueued(true);
-        }
-        return config;
+        return cfg.getReactorConfig();
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpTransportConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpTransportConfiguration.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpTransportConfiguration.java	(revision 1512866)
@@ -0,0 +1,187 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.config;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.impl.nio.reactor.IOReactorConfig;
+import org.apache.synapse.commons.util.MiscellaneousUtil;
+
+import java.nio.charset.CodingErrorAction;
+import java.util.Properties;
+
+public abstract class HttpTransportConfiguration {
+
+    protected Log log = LogFactory.getLog(this.getClass());
+
+    private Properties props;
+
+    public HttpTransportConfiguration(String fileName) {
+        try {
+            props = MiscellaneousUtil.loadProperties(fileName + ".properties");
+        } catch (Exception ignored) {}
+    }
+
+    abstract protected int getThreadsPerReactor();
+
+    public IOReactorConfig getReactorConfig() {
+        IOReactorConfig.Builder builder = IOReactorConfig.custom()
+                .setIoThreadCount(getThreadsPerReactor())
+                .setSoTimeout(getIntProperty(HttpConfigConstants.SO_TIMEOUT, 60000))
+                .setConnectTimeout(getIntProperty(HttpConfigConstants.CONNECTION_TIMEOUT, 0))
+                .setInterestOpQueued(getBooleanProperty(HttpConfigConstants.INTEREST_OPS_QUEUEING, false))
+                .setTcpNoDelay(getBooleanProperty(HttpConfigConstants.TCP_NODELAY, true))
+                .setRcvBufSize(getIntProperty(HttpConfigConstants.SOCKET_RCV_BUFFER_SIZE, 8 * 1024))
+                .setSndBufSize(getIntProperty(HttpConfigConstants.SOCKET_SND_BUFFER_SIZE, 8 * 1024));
+
+        if (getIntProperty(HttpConfigConstants.SO_LINGER) != null) {
+            builder.setSoLinger(getIntProperty(HttpConfigConstants.SO_LINGER));
+        }
+
+        if (getBooleanProperty(HttpConfigConstants.SO_REUSEADDR) != null) {
+            builder.setSoReuseAddress(getBooleanProperty(HttpConfigConstants.SO_REUSEADDR));
+        }
+
+        if (getIntProperty(HttpConfigConstants.SELECT_INTERVAL) != null) {
+            builder.setSelectInterval(getIntProperty(HttpConfigConstants.SELECT_INTERVAL));
+        }
+        return builder.build();
+    }
+
+    public ConnectionConfig getConnectionConfig() {
+        return ConnectionConfig.custom()
+                .setBufferSize(getIntProperty(HttpConfigConstants.SOCKET_BUFFER_SIZE, 8 * 1024))
+                .setMalformedInputAction(getMalformedInputActionValue())
+                .setUnmappableInputAction(getUnMappableInputActionValue())
+                .build();
+    }
+
+    /**
+     * Get an int property that tunes the http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public Integer getIntProperty(String name, Integer def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        if (val != null) {
+            int intVal;
+            try {
+                intVal = Integer.valueOf(val);
+            } catch (NumberFormatException e) {
+                log.warn("Invalid http tuning property value. " + name + " must be an integer");
+                return def;
+            }
+            if (log.isDebugEnabled()) {
+                log.debug("Using http tuning parameter : " + name + " = " + val);
+            }
+            return intVal;
+        }
+
+        return def;
+    }
+
+    /**
+     * Get an int property that tunes the http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @return the value of the property, null if the property is not found
+     */
+    public Integer getIntProperty(String name) {
+        return getIntProperty(name, null);
+    }
+
+    /**
+     * Get a boolean property that tunes the http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public Boolean getBooleanProperty(String name, Boolean def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        if (val != null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Using http tuning parameter : " + name + " = " + val);
+            }
+            return Boolean.valueOf(val);
+        }
+
+        return def;
+    }
+
+    /**
+     * Get a Boolean property that tunes the http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @return the value of the property, null if the property is not found
+     */
+    public Boolean getBooleanProperty(String name) {
+        return getBooleanProperty(name, null);
+    }
+
+    /**
+     * Get a String property that tunes the http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public String getStringProperty(String name, String def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        return val == null ? def : val;
+    }
+
+    private CodingErrorAction getMalformedInputActionValue() {
+        String val = getStringProperty(HttpConfigConstants.HTTP_MALFORMED_INPUT_ACTION, "report");
+        return getCodingErrorAction(val);
+    }
+
+    private CodingErrorAction getUnMappableInputActionValue() {
+        String val = getStringProperty(HttpConfigConstants.HTTP_UNMAPPABLE_INPUT_ACTION, "report");
+        return getCodingErrorAction(val);
+    }
+
+    private CodingErrorAction getCodingErrorAction(String action) {
+        if ("report".equals(action)) {
+            return CodingErrorAction.REPORT;
+        } else if ("ignore".equals(action)) {
+            return CodingErrorAction.IGNORE;
+        } else if ("replace".equals(action)) {
+            return CodingErrorAction.REPLACE;
+        } else {
+            return CodingErrorAction.REPORT;
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnection.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnection.java	(revision 1512866)
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.config.MessageConstraints;
+import org.apache.http.entity.ContentLengthStrategy;
+import org.apache.http.impl.nio.DefaultNHttpServerConnection;
+import org.apache.http.nio.NHttpMessageParserFactory;
+import org.apache.http.nio.NHttpMessageWriterFactory;
+import org.apache.http.nio.NHttpServerEventHandler;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.util.ByteBufferAllocator;
+
+import java.io.IOException;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+
+public class LoggingNHttpServerConnection extends DefaultNHttpServerConnection {
+
+    private final Log log;
+
+    public LoggingNHttpServerConnection(IOSession session,
+                                        int bufferSize,
+                                        int fragmentSizeHint,
+                                        ByteBufferAllocator allocator,
+                                        CharsetDecoder charDecoder,
+                                        CharsetEncoder charEncoder,
+                                        MessageConstraints constraints,
+                                        ContentLengthStrategy incomingContentStrategy,
+                                        ContentLengthStrategy outgoingContentStrategy,
+                                        NHttpMessageParserFactory<HttpRequest> requestParserFactory,
+                                        NHttpMessageWriterFactory<HttpResponse> responseWriterFactory,
+                                        Log log) {
+        super(session, bufferSize, fragmentSizeHint, allocator,
+                charDecoder, charEncoder, constraints, incomingContentStrategy,
+                outgoingContentStrategy, requestParserFactory, responseWriterFactory);
+        this.log = log;
+    }
+
+    @Override
+    public void close() throws IOException {
+        this.log.debug("Close connection");
+        super.close();
+    }
+
+    @Override
+    public void shutdown() throws IOException {
+        this.log.debug("Shutdown connection");
+        super.shutdown();
+    }
+
+    @Override
+    public void submitResponse(final HttpResponse response) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + this + ": "  + response.getStatusLine().toString());
+        }
+        super.submitResponse(response);
+    }
+
+    @Override
+    public void consumeInput(final NHttpServerEventHandler handler) {
+        this.log.debug("Consume input");
+        super.consumeInput(handler);
+    }
+
+    @Override
+    public void produceOutput(final NHttpServerEventHandler handler) {
+        this.log.debug("Produce output");
+        super.produceOutput(handler);
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingIOSession.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingIOSession.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingIOSession.java	(revision 1512866)
@@ -0,0 +1,232 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionBufferStatus;
+import org.apache.http.nio.reactor.ssl.SSLIOSession;
+
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.SelectionKey;
+import java.util.concurrent.atomic.AtomicLong;
+
+public class LoggingIOSession implements IOSession {
+
+    private static AtomicLong COUNT = new AtomicLong(0);
+
+    private final Log sessionLog;
+    private final Wire wireLog;
+    private final IOSession session;
+    private final ByteChannel channel;
+    private final String id;
+
+    public LoggingIOSession(
+            final Log sessionLog,
+            final Log wireLog,
+            final IOSession session,
+            final String id) {
+        super();
+        if (session == null) {
+            throw new IllegalArgumentException("I/O session may not be null");
+        }
+        this.session = session;
+        this.channel = new LoggingByteChannel();
+        this.id = id + "-" + COUNT.incrementAndGet();
+        this.sessionLog = sessionLog;
+        this.wireLog = new Wire(wireLog);
+    }
+
+    public int getStatus() {
+        return this.session.getStatus();
+    }
+
+    public ByteChannel channel() {
+        return this.channel;
+    }
+
+    public SocketAddress getLocalAddress() {
+        return this.session.getLocalAddress();
+    }
+
+    public SocketAddress getRemoteAddress() {
+        return this.session.getRemoteAddress();
+    }
+
+    public int getEventMask() {
+        return this.session.getEventMask();
+    }
+
+    private static String formatOps(int ops) {
+        StringBuilder buffer = new StringBuilder(6);
+        buffer.append('[');
+        if ((ops & SelectionKey.OP_READ) > 0) {
+            buffer.append('r');
+        }
+        if ((ops & SelectionKey.OP_WRITE) > 0) {
+            buffer.append('w');
+        }
+        if ((ops & SelectionKey.OP_ACCEPT) > 0) {
+            buffer.append('a');
+        }
+        if ((ops & SelectionKey.OP_CONNECT) > 0) {
+            buffer.append('c');
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
+
+    private String getPreamble() {
+        String preamble = "I/O session " + this.id + " " + this.session;
+        if (this.session instanceof SSLIOSession) {
+            return "SSL " + preamble;
+        } else {
+            return preamble;
+        }
+    }
+
+    public void setEventMask(int ops) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Set event mask " + formatOps(ops));
+        }
+        this.session.setEventMask(ops);
+    }
+
+    public void setEvent(int op) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Set event " + formatOps(op));
+        }
+        this.session.setEvent(op);
+    }
+
+    public void clearEvent(int op) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Clear event " + formatOps(op));
+        }
+        this.session.clearEvent(op);
+    }
+
+    public void close() {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Close");
+        }
+        this.session.close();
+    }
+
+    public boolean isClosed() {
+        return this.session.isClosed();
+    }
+
+    public void shutdown() {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Shutdown");
+        }
+        this.session.shutdown();
+    }
+
+    public int getSocketTimeout() {
+        return this.session.getSocketTimeout();
+    }
+
+    public void setSocketTimeout(int timeout) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Set timeout " + timeout);
+        }
+        this.session.setSocketTimeout(timeout);
+    }
+
+    public void setBufferStatus(final SessionBufferStatus status) {
+        this.session.setBufferStatus(status);
+    }
+
+    public boolean hasBufferedInput() {
+        return this.session.hasBufferedInput();
+    }
+
+    public boolean hasBufferedOutput() {
+        return this.session.hasBufferedOutput();
+    }
+
+    public Object getAttribute(final String name) {
+        return this.session.getAttribute(name);
+    }
+
+    public void setAttribute(final String name, final Object obj) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Set attribute " + name);
+        }
+        this.session.setAttribute(name, obj);
+    }
+
+    public Object removeAttribute(final String name) {
+        if (sessionLog.isDebugEnabled()) {
+            sessionLog.debug(getPreamble() + ": Remove attribute " + name);
+        }
+        return this.session.removeAttribute(name);
+    }
+
+    class LoggingByteChannel implements ByteChannel {
+
+        public int read(final ByteBuffer dst) throws IOException {
+            int bytesRead = session.channel().read(dst);
+            if (sessionLog.isDebugEnabled()) {
+                sessionLog.debug(getPreamble() + ": " + bytesRead + " bytes read");
+            }
+            if (bytesRead > 0 && wireLog.isEnabled()) {
+                ByteBuffer b = dst.duplicate();
+                int p = b.position();
+                b.limit(p);
+                b.position(p - bytesRead);
+                wireLog.input(b);
+            }
+            return bytesRead;
+        }
+
+        public int write(final ByteBuffer src) throws IOException {
+            int byteWritten = session.channel().write(src);
+            if (sessionLog.isDebugEnabled()) {
+                sessionLog.debug(getPreamble() + ": " + byteWritten + " bytes written");
+            }
+            if (byteWritten > 0 && wireLog.isEnabled()) {
+                ByteBuffer b = src.duplicate();
+                int p = b.position();
+                b.limit(p);
+                b.position(p - byteWritten);
+                wireLog.output(b);
+            }
+            return byteWritten;
+        }
+
+        public void close() throws IOException {
+            if (sessionLog.isDebugEnabled()) {
+                sessionLog.debug(getPreamble() + ": Channel close");
+            }
+            session.channel().close();
+        }
+
+        public boolean isOpen() {
+            return session.channel().isOpen();
+        }
+
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnectionFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnectionFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpServerConnectionFactory.java	(revision 1512866)
@@ -0,0 +1,150 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.config.MessageConstraints;
+import org.apache.http.impl.ConnSupport;
+import org.apache.http.impl.entity.StrictContentLengthStrategy;
+import org.apache.http.impl.nio.DefaultNHttpServerConnection;
+import org.apache.http.impl.nio.codecs.DefaultHttpRequestParser;
+import org.apache.http.impl.nio.codecs.DefaultHttpResponseWriter;
+import org.apache.http.nio.*;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionInputBuffer;
+import org.apache.http.nio.reactor.SessionOutputBuffer;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+
+import java.io.IOException;
+
+public class LoggingNHttpServerConnectionFactory implements NHttpConnectionFactory<DefaultNHttpServerConnection> {
+
+    private static final Log sourceConnLog = LogFactory.getLog(
+            LoggingConstants.SOURCE_CONNECTION_LOG_ID);
+    private static final Log sourceHeaderLog = LogFactory.getLog(
+            LoggingConstants.SOURCE_HEADER_LOG_ID);
+    private static final Log sourceSessionLog = LogFactory.getLog(
+            LoggingConstants.SOURCE_SESSION_LOG_ID);
+    private static final Log sourceWireLog = LogFactory.getLog(
+            LoggingConstants.SOURCE_WIRE_LOG_ID);
+
+    private static final NHttpMessageParserFactory<HttpRequest> requestParserFactory =
+            new LoggingNHttpRequestParserFactory();
+    private static final NHttpMessageWriterFactory<HttpResponse> responseWriterFactory =
+            new LoggingNHttpResponseWriterFactory();
+
+    private final ConnectionConfig config;
+
+    public LoggingNHttpServerConnectionFactory(ConnectionConfig config) {
+        this.config = config;
+    }
+
+    public DefaultNHttpServerConnection createConnection(IOSession session) {
+        if (sourceSessionLog.isDebugEnabled() || sourceWireLog.isDebugEnabled()) {
+            session = new LoggingIOSession(sourceSessionLog, sourceWireLog,
+                    session, "http-listener");
+        }
+
+        if (sourceConnLog.isDebugEnabled()) {
+            return new LoggingNHttpServerConnection(
+                    session,
+                    config.getBufferSize(),
+                    config.getFragmentSizeHint(),
+                    HeapByteBufferAllocator.INSTANCE,
+                    ConnSupport.createDecoder(config),
+                    ConnSupport.createEncoder(config),
+                    config.getMessageConstraints(),
+                    StrictContentLengthStrategy.INSTANCE,
+                    StrictContentLengthStrategy.INSTANCE,
+                    requestParserFactory,
+                    responseWriterFactory,
+                    sourceConnLog);
+        } else {
+            return new DefaultNHttpServerConnection(
+                    session,
+                    config.getBufferSize(),
+                    config.getFragmentSizeHint(),
+                    HeapByteBufferAllocator.INSTANCE,
+                    ConnSupport.createDecoder(config),
+                    ConnSupport.createEncoder(config),
+                    config.getMessageConstraints(),
+                    StrictContentLengthStrategy.INSTANCE,
+                    StrictContentLengthStrategy.INSTANCE,
+                    requestParserFactory,
+                    responseWriterFactory);
+        }
+    }
+
+    static class LoggingNHttpRequestParserFactory implements NHttpMessageParserFactory<HttpRequest> {
+        public NHttpMessageParser<HttpRequest> create(SessionInputBuffer sessionBuffer,
+                                                      MessageConstraints messageConstraints) {
+            return new LoggingNHttpRequestParser(sessionBuffer, messageConstraints);
+        }
+    }
+
+    static class LoggingNHttpResponseWriterFactory implements NHttpMessageWriterFactory<HttpResponse> {
+        public NHttpMessageWriter<HttpResponse> create(SessionOutputBuffer sessionBuffer) {
+            return new LoggingNHttpResponseWriter(sessionBuffer);
+        }
+    }
+
+    static class LoggingNHttpRequestParser extends DefaultHttpRequestParser {
+
+        public LoggingNHttpRequestParser(SessionInputBuffer buffer, MessageConstraints constraints) {
+            super(buffer, constraints);
+        }
+
+        public HttpRequest parse() throws IOException, HttpException {
+            HttpRequest request = super.parse();
+            if (request != null && sourceHeaderLog.isDebugEnabled()) {
+                sourceHeaderLog.debug(">> " + request.getRequestLine().toString());
+                Header[] headers = request.getAllHeaders();
+                for (Header header : headers) {
+                    sourceHeaderLog.debug(">> " + header.toString());
+                }
+            }
+            return request;
+        }
+    }
+
+    static class LoggingNHttpResponseWriter extends DefaultHttpResponseWriter {
+
+        public LoggingNHttpResponseWriter(SessionOutputBuffer buffer) {
+            super(buffer);
+        }
+
+        public void write(final HttpResponse response) throws IOException, HttpException {
+            if (response != null && sourceHeaderLog.isDebugEnabled()) {
+                sourceHeaderLog.debug("<< " + response.getStatusLine().toString());
+                Header[] headers = response.getAllHeaders();
+                for (Header header : headers) {
+                    sourceHeaderLog.debug("<< " + header.toString());
+                }
+            }
+            super.write(response);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/Wire.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/Wire.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/Wire.java	(revision 1512866)
@@ -0,0 +1,111 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+
+import java.nio.ByteBuffer;
+
+public class Wire {
+
+    private final Log log;
+
+    public Wire(final Log log) {
+        super();
+        this.log = log;
+    }
+
+    private void wire(final String header, final byte[] b, int pos, int off) {
+        StringBuilder buffer = new StringBuilder();
+        for (int i = 0; i < off; i++) {
+            int ch = b[pos + i];
+            if (ch == 13) {
+                buffer.append("[\\r]");
+            } else if (ch == 10) {
+                buffer.append("[\\n]\"");
+                buffer.insert(0, "\"");
+                buffer.insert(0, header);
+                this.log.debug(buffer.toString());
+                buffer.setLength(0);
+            } else if ((ch < 32) || (ch > 127)) {
+                buffer.append("[0x");
+                buffer.append(Integer.toHexString(ch));
+                buffer.append("]");
+            } else {
+                buffer.append((char) ch);
+            }
+        }
+        if (buffer.length() > 0) {
+            buffer.append('\"');
+            buffer.insert(0, '\"');
+            buffer.insert(0, header);
+            this.log.debug(buffer.toString());
+        }
+    }
+
+
+    public boolean isEnabled() {
+        return this.log.isDebugEnabled();
+    }
+
+    public void output(final byte[] b, int pos, int off) {
+        wire("<< ", b, pos, off);
+    }
+
+    public void input(final byte[] b, int pos, int off) {
+        wire(">> ", b, pos, off);
+    }
+
+    public void output(byte[] b) {
+        output(b, 0, b.length);
+    }
+
+    public void input(byte[] b) {
+        input(b, 0, b.length);
+    }
+
+    public void output(int b) {
+        output(new byte[] {(byte) b});
+    }
+
+    public void input(int b) {
+        input(new byte[] {(byte) b});
+    }
+
+    public void output(final ByteBuffer b) {
+        if (b.hasArray()) {
+            output(b.array(), b.arrayOffset() + b.position(), b.remaining());
+        } else {
+            byte[] tmp = new byte[b.remaining()];
+            b.get(tmp);
+            output(tmp);
+        }
+    }
+
+    public void input(final ByteBuffer b) {
+        if (b.hasArray()) {
+            input(b.array(), b.arrayOffset() + b.position(), b.remaining());
+        } else {
+            byte[] tmp = new byte[b.remaining()];
+            b.get(tmp);
+            input(tmp);
+        }
+    }
+}
Index: java/repository/conf/nhttp.properties
===================================================================
--- java/repository/conf/nhttp.properties	(revision 1512865)
+++ java/repository/conf/nhttp.properties	(revision 1512866)
@@ -21,18 +21,22 @@
 
 #http.socket.timeout=60000
 #http.socket.buffer-size=8192
-#http.tcp.nodelay=1
+#http.socket.rcv-buffer-size=8192
+#http.socket.snd-buffer-size=8192
+#http.tcp.nodelay=true
 #http.connection.stalecheck=0
 
 # Uncomment the following property for an AIX based deployment
 #http.nio.interest-ops-queueing=true
 
+# Number of I/O dispatcher threads that should be used by each IOReactor
+#io_threads_per_reactor=2
+
 # HTTP Listener thread pool parameters
 #snd_t_core=20
 #snd_t_max=100
 #snd_alive_sec=5
 #snd_qlen=-1
-#snd_io_threads=2
 
 # HTTP Sender thread pool parameters
 #lst_t_core=20
@@ -39,4 +43,3 @@
 #lst_t_max=100
 #lst_alive_sec=5
 #lst_qlen=-1
-#lst_io_threads=2
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java	(revision 1512866)
@@ -19,7 +19,6 @@
 
 package org.apache.synapse.transport.passthru;
 
-import java.io.OutputStream;
 import java.net.InetAddress;
 import java.util.Comparator;
 import java.util.Map;
@@ -60,10 +59,10 @@
 import org.apache.http.nio.reactor.ssl.SSLIOSession;
 import org.apache.http.protocol.HTTP;
 import org.apache.synapse.transport.nhttp.HttpCoreRequestResponseTransport;
-import org.apache.synapse.transport.nhttp.NHttpConfiguration;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.transport.nhttp.util.NhttpUtil;
 import org.apache.synapse.transport.nhttp.util.RESTUtil;
+import org.apache.synapse.transport.passthru.config.PassThroughConfiguration;
 import org.apache.synapse.transport.passthru.config.SourceConfiguration;
 import org.apache.synapse.transport.passthru.util.SourceResponseFactory;
 
@@ -89,18 +88,14 @@
     private HttpGetRequestProcessor httpGetRequestProcessor = null;
     
     private boolean isHttps = false;
-    
-    
-    private OutputStream os; //only used for WSDL  requests..
   
     public ServerWorker(final SourceRequest request,
-                        final SourceConfiguration sourceConfiguration, final OutputStream os) {
+                        final SourceConfiguration sourceConfiguration) {
         this.request = request;
         this.sourceConfiguration = sourceConfiguration;
         this.isHttps = sourceConfiguration.isSsl();
         this.msgContext = createMessageContext(request);
         this.httpGetRequestProcessor = sourceConfiguration.getHttpGetRequestProcessor();
-        this.os = os;
 
         // set these properties to be accessed by the engine
         msgContext.setProperty(
@@ -180,7 +175,7 @@
             response.setEntity(entity);
             
 			httpGetRequestProcessor.process(request.getRequest(), response, msgContext,
-					request.getConnection(), os, true);
+					request.getConnection(), true);
 		} 
 		
 		//need special case to handle REST
@@ -258,7 +253,7 @@
 				// Dispatcher Service.
 
 				if (axisService == null) {
-					String defaultSvcName = NHttpConfiguration.getInstance().getStringValue(
+					String defaultSvcName = PassThroughConfiguration.getInstance().getStringProperty(
                             "nhttp.default.service", "__SynapseService");
 					axisService =  msgContext.getConfigurationContext().getAxisConfiguration()
 					                        .getService(defaultSvcName);
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java	(revision 1512866)
@@ -145,7 +145,7 @@
      */
     public void closeConnection(NHttpServerConnection conn) {
         if (log.isDebugEnabled()) {
-            log.debug("Shutting down connection forcefully " + conn);
+            log.debug("Closing connection forcefully " + conn);
         }
         lock.lock();
         try {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java	(revision 1512866)
@@ -21,9 +21,6 @@
 
 public class PassThroughConstants {
 
-    public static final int DEFAULT_IO_THREAD_COUNT = Runtime.getRuntime().availableProcessors();
-    public static final int DEFAULT_MAX_CONN_PER_HOST_PORT = Integer.MAX_VALUE;
-    
     public static final String REQUEST_MESSAGE_CONTEXT = "REQUEST_MESSAGE_CONTEXT";
     public static final String CONNECTION_POOL = "CONNECTION_POOL";
 
@@ -84,6 +81,8 @@
     protected static final String PASS_THROUGH_TARGET_CONNECTION = "pass-through.Target-Connection";
     protected static final String PASS_THROUGH_TARGET_RESPONSE = "pass-through.Target-Response";
 
+    public static final String PASS_THROUGH_RESPONSE_SOURCE_BUFFER = "synapse.response-source-buffer";
+
     public static final String PASS_THROUGH_PIPE = "pass-through.pipe";
 
     // used to define the default content type as a parameter in the axis2.xml
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(revision 1512866)
@@ -42,6 +42,7 @@
 import org.apache.commons.logging.LogFactory;
 import org.apache.http.HttpException;
 import org.apache.http.HttpStatus;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
 import org.apache.http.nio.NHttpClientEventHandler;
 import org.apache.http.nio.NHttpServerConnection;
@@ -49,7 +50,6 @@
 import org.apache.http.nio.reactor.IOReactorException;
 import org.apache.http.nio.reactor.IOReactorExceptionHandler;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
 import org.apache.synapse.commons.jmx.MBeanRegistrar;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
@@ -61,6 +61,7 @@
 import org.apache.synapse.transport.passthru.jmx.TransportView;
 import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;
 import org.apache.synapse.transport.passthru.util.SourceResponseFactory;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 import javax.net.ssl.SSLContext;
 import java.io.ByteArrayOutputStream;
@@ -159,7 +160,6 @@
 
         targetConfiguration = new TargetConfiguration(configurationContext,
                 transportOutDescription, workerPool);
-        targetConfiguration.build();
         configurationContext.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL,
                 targetConfiguration.getWorkerPool());
 
@@ -211,7 +211,7 @@
         TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);
         final IOEventDispatch ioEventDispatch =
                 getEventDispatch(handler, sslContext, sslSetupHandler,
-                        targetConfiguration.getHttpParameters(), transportOutDescription);
+                        targetConfiguration.getConnectionConfig(), transportOutDescription);
 
         // start the sender in a separate thread
         Thread t = new Thread(new Runnable() {
@@ -429,7 +429,7 @@
      * @param handler The passthru target handler instance
      * @param sslContext SSL context used by the sender or null
      * @param sslIOSessionHandler SSL session handler or null
-     * @param params HTTP parameters
+     * @param config ConnectionConfig instance
      * @param trpOut Transport out description
      * @return an IOEventDispatch instance
      * @throws AxisFault on error
@@ -437,10 +437,10 @@
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler,
                                                SSLContext sslContext,
                                                SSLSetupHandler sslIOSessionHandler,
-                                               HttpParams params,
+                                               ConnectionConfig config,
                                                TransportOutDescription trpOut) throws AxisFault {
 
-        return new TargetIOEventDispatch(handler, params);
+        return LoggingUtils.getClientIODispatch(handler, config);
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java	(revision 1512866)
@@ -37,6 +37,7 @@
 import org.apache.axis2.util.JavaUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.impl.nio.reactor.DefaultListeningIOReactor;
 import org.apache.http.nio.NHttpServerEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
@@ -44,11 +45,11 @@
 import org.apache.http.nio.reactor.IOReactorExceptionHandler;
 import org.apache.http.nio.reactor.ListenerEndpoint;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
 import org.apache.synapse.commons.jmx.MBeanRegistrar;
 import org.apache.synapse.transport.passthru.config.SourceConfiguration;
 import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
 import org.apache.synapse.transport.passthru.jmx.TransportView;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 import javax.net.ssl.SSLContext;
 import java.io.IOException;
@@ -111,12 +112,10 @@
         // is this a SSL listener?
         sslContext = getSSLContext(transportInDescription);
         sslSetupHandler = getSSLSetupHandler(transportInDescription);
-
         namePrefix = (sslContext == null) ? "HTTP" : "HTTPS";
 
-        sourceConfiguration = new SourceConfiguration(cfgCtx, transportInDescription, workerPool);
-        sourceConfiguration.setSsl(sslContext != null);
-        sourceConfiguration.build();
+        sourceConfiguration = new SourceConfiguration(cfgCtx, transportInDescription,
+                workerPool, sslContext != null);
 
         // register to receive updates on services for lifetime management
         cfgCtx.getAxisConfiguration().addObservers(axisObserver);
@@ -164,7 +163,7 @@
 
         SourceHandler handler = new SourceHandler(sourceConfiguration);
         final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext,
-                sslSetupHandler, sourceConfiguration.getHttpParameters());
+                sslSetupHandler, sourceConfiguration.getConnectionConfig());
 
         ListenerEndpoint endpoint = ioReactor.listen(new InetSocketAddress(
                 sourceConfiguration.getPort()));
@@ -320,9 +319,8 @@
         public void init(AxisConfiguration axisConfig) {}
 
         public void serviceUpdate(AxisEvent event, AxisService service) {
-            if (!ignoreService(service)
-                    && BaseUtils.isUsingTransport(service,
-                    sourceConfiguration.getInDescription().getName())) {
+            if (!ignoreService(service) && BaseUtils.isUsingTransport(
+                    service, sourceConfiguration.getTransportName())) {
                 switch (event.getEventType()) {
                     case AxisEvent.SERVICE_DEPLOY :
                         addToServiceURIMap(service);
@@ -375,8 +373,8 @@
 
     protected IOEventDispatch getEventDispatch(
             NHttpServerEventHandler handler, SSLContext sslContext,
-            SSLSetupHandler sslSetupHandler, HttpParams params) {
-        return new SourceIOEventDispatch(handler, params);
+            SSLSetupHandler sslSetupHandler, ConnectionConfig config) {
+        return LoggingUtils.getServerIODispatch(handler, config);
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java	(revision 1512866)
@@ -24,7 +24,6 @@
 import org.apache.http.impl.DefaultConnectionReuseStrategy;
 import org.apache.http.nio.ContentEncoder;
 import org.apache.http.nio.NHttpServerConnection;
-import org.apache.http.params.DefaultedHttpParams;
 import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HTTP;
 import org.apache.synapse.transport.passthru.config.SourceConfiguration;
@@ -127,9 +126,6 @@
             }
         }
 
-        response.setParams(new DefaultedHttpParams(response.getParams(),
-                sourceConfiguration.getHttpParameters()));
-
         SourceContext.updateState(conn, ProtocolState.RESPONSE_HEAD);
 
         // Pre-process HTTP response
@@ -165,7 +161,6 @@
 
             if (!this.connStrategy.keepAlive(response, conn.getContext())) {
                 SourceContext.updateState(conn, ProtocolState.CLOSING);
-
                 sourceConfiguration.getSourceConnections().closeConnection(conn);
             } else if (SourceContext.get(conn).isShutDown()) {
                 // we need to shut down if the shutdown flag is set
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java	(revision 1512866)
@@ -459,6 +459,7 @@
         } else if (e instanceof IOException) {
             exception(conn, (IOException) e);
         } else {
+            log.error("Unexpected exception encountered in TargetHandler", e);
             ProtocolState state = TargetContext.getState(conn);
             MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
             if (requestMsgCtx != null) {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java	(revision 1512866)
@@ -19,12 +19,9 @@
 
 package org.apache.synapse.transport.passthru.config;
 
-import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.ParameterInclude;
 import org.apache.axis2.transport.base.threads.WorkerPool;
-import org.apache.http.HttpRequestInterceptor;
-import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.*;
 import org.apache.synapse.transport.passthru.connections.TargetConnections;
 
@@ -33,13 +30,12 @@
  */
 public class TargetConfiguration extends BaseConfiguration {
 
-    private HttpProcessor httpProcessor = null;
-
     private int maxConnections = Integer.MAX_VALUE;
 
-    /** Weather User-Agent header coming from client should be preserved */
+    /** Whether User-Agent header coming from client should be preserved */
     private boolean preserveUserAgentHeader = false;
-    /** Weather Server header coming from server should be preserved */
+
+    /** Whether Server header coming from server should be preserved */
     private boolean preserveServerHeader = true;
 
     private TargetConnections connections = null;
@@ -48,34 +44,25 @@
                                ParameterInclude parameters,
                                WorkerPool pool) {
         super(configurationContext, parameters, pool);
-
-        httpProcessor = new ImmutableHttpProcessor(
-                new HttpRequestInterceptor[] {
-                        new RequestContent(),
-                        new RequestTargetHost(),
-                        new RequestConnControl(),
-                        new RequestUserAgent(),
-                        new RequestExpectContinue()
-         });
-    }
-
-    public void build() throws AxisFault {
-        super.build();
-
-        maxConnections = conf.getIntProperty(PassThroughConfigPNames.MAX_CONNECTION_PER_HOST_PORT,
+        maxConnections = conf.getIntProperty(
+                PassThroughConfigPNames.MAX_CONNECTION_PER_HOST_PORT,
                 Integer.MAX_VALUE);
-        preserveUserAgentHeader = conf.isPreserveUserAgentHeader();
-        preserveServerHeader = conf.isPreserveServerHeader();
+        preserveUserAgentHeader = conf.getBooleanProperty(
+                PassThroughConfigPNames.USER_AGENT_HEADER_PRESERVE, false);
+        preserveServerHeader = conf.getBooleanProperty(
+                PassThroughConfigPNames.SERVER_HEADER_PRESERVE, true);
     }
 
-    public HttpParams getHttpParameters() {
-        return httpParameters;
+    @Override
+    protected HttpProcessor initHttpProcessor() {
+        return new ImmutableHttpProcessor(
+                new RequestContent(),
+                new RequestTargetHost(),
+                new RequestConnControl(),
+                new RequestUserAgent(),
+                new RequestExpectContinue(false));
     }
 
-    public HttpProcessor getHttpProcessor() {
-        return httpProcessor;
-    }
-
     public int getMaxConnections() {
         return maxConnections;
     }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java	(revision 1512866)
@@ -19,19 +19,13 @@
 
 package org.apache.synapse.transport.passthru.config;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.http.params.HttpProtocolParams;
-import org.apache.synapse.commons.util.MiscellaneousUtil;
+import org.apache.synapse.transport.utils.config.HttpTransportConfiguration;
 
-import java.nio.charset.CodingErrorAction;
-import java.util.Properties;
-
 /**
  * This class encapsulates pass-through http transport tuning configurations specified via a
  * configurations file or system properties.
  */
-public class PassThroughConfiguration {
+public class PassThroughConfiguration extends HttpTransportConfiguration {
 
     /**
      * Default tuning parameter values
@@ -40,20 +34,12 @@
     private static final int DEFAULT_WORKER_POOL_SIZE_MAX        = 200;
     private static final int DEFAULT_WORKER_THREAD_KEEPALIVE_SEC = 60;
     private static final int DEFAULT_WORKER_POOL_QUEUE_LENGTH    = -1;
-    private static final int DEFAULT_IO_BUFFER_SIZE              = 8 * 1024;
-    private static final int DEFAULT_IO_THREADS_PER_REACTOR      =
-                                                         Runtime.getRuntime().availableProcessors();
+    private static final int DEFAULT_IO_THREADS_PER_REACTOR      = Runtime.getRuntime().availableProcessors();
 
-    private static final Log log = LogFactory.getLog(PassThroughConfiguration.class);
-
     private static PassThroughConfiguration _instance = new PassThroughConfiguration();
 
-    private Properties props;
-
     private PassThroughConfiguration() {
-        try {
-            props = MiscellaneousUtil.loadProperties("passthru-http.properties");
-        } catch (Exception ignored) {}
+        super("passthru-http") ;
     }
 
     public static PassThroughConfiguration getInstance() {
@@ -80,138 +66,9 @@
                 DEFAULT_WORKER_POOL_QUEUE_LENGTH);
     }
 
-    public int getIOThreadsPerReactor() {
+    protected int getThreadsPerReactor() {
         return getIntProperty(PassThroughConfigPNames.IO_THREADS_PER_REACTOR,
                 DEFAULT_IO_THREADS_PER_REACTOR);
     }
 
-    public int getIOBufferSize() {
-        return getIntProperty(PassThroughConfigPNames.IO_BUFFER_SIZE,
-                DEFAULT_IO_BUFFER_SIZE);
-    }
-
-    public boolean isKeepAliveDisabled() {
-        return getBooleanProperty(PassThroughConfigPNames.DISABLE_KEEPALIVE, false);
-    }
-
-    public boolean isPreserveUserAgentHeader() {
-        return getBooleanProperty(PassThroughConfigPNames.USER_AGENT_HEADER_PRESERVE, false);
-    }
-
-    public boolean isPreserveServerHeader() {
-        return getBooleanProperty(PassThroughConfigPNames.SERVER_HEADER_PRESERVE, true);
-    }
-
-    /**
-     * Get an int property that tunes pass-through http transport. Prefer system properties
-     *
-     * @param name name of the system/config property
-     * @param def  default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public Integer getIntProperty(String name, Integer def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        if (val != null) {
-            int intVal;
-            try {
-                intVal = Integer.valueOf(val);
-            } catch (NumberFormatException e) {
-                log.warn("Invalid pass-through http tuning property value. " + name +
-                        " must be an integer");
-                return def;
-            }
-            if (log.isDebugEnabled()) {
-                log.debug("Using pass-through http tuning parameter : " + name + " = " + val);
-            }
-            return intVal;
-        }
-
-        return def;
-    }
-
-    /**
-     * Get an int property that tunes pass-through http transport. Prefer system properties
-     *
-     * @param name name of the system/config property
-     * @return the value of the property, null if the property is not found
-     */
-    public Integer getIntProperty(String name) {
-        return getIntProperty(name, null);
-    }
-
-    /**
-     * Get a boolean property that tunes pass-through http transport. Prefer system properties
-     *
-     * @param name name of the system/config property
-     * @param def  default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public Boolean getBooleanProperty(String name, Boolean def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        if (val != null) {
-            if (log.isDebugEnabled()) {
-                log.debug("Using pass-through http tuning parameter : " + name + " = " + val);
-            }
-            return Boolean.valueOf(val);
-        }
-
-        return def;
-    }
-
-    /**
-     * Get a Boolean property that tunes pass-through http transport. Prefer system properties
-     *
-     * @param name name of the system/config property
-     * @return the value of the property, null if the property is not found
-     */
-    public Boolean getBooleanProperty(String name) {
-        return getBooleanProperty(name, null);
-    }
-
-    /**
-     * Get a String property that tunes pass-through http transport. Prefer system properties
-     *
-     * @param name name of the system/config property
-     * @param def  default value to return if the property is not set
-     * @return the value of the property to be used
-     */
-    public String getStringProperty(String name, String def) {
-        String val = System.getProperty(name);
-        if (val == null) {
-            val = props.getProperty(name);
-        }
-
-        return val == null ? def : val;
-    }
-
-    public CodingErrorAction getMalformedInputActionValue() {
-        String val = getStringProperty(HttpProtocolParams.HTTP_MALFORMED_INPUT_ACTION, "report");
-        return getCodingErrorAction(val);
-    }
-
-    public CodingErrorAction getUnMappableInputActionValue() {
-        String val = getStringProperty(HttpProtocolParams.HTTP_UNMAPPABLE_INPUT_ACTION, "report");
-        return getCodingErrorAction(val);
-    }
-
-    private CodingErrorAction getCodingErrorAction(String action) {
-        if ("report".equals(action)) {
-            return CodingErrorAction.REPORT;
-        } else if ("ignore".equals(action)) {
-            return CodingErrorAction.IGNORE;
-        } else if ("replace".equals(action)) {
-            return CodingErrorAction.REPLACE;
-        } else {
-            return CodingErrorAction.REPORT;
-        }
-    }
-
 }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java	(revision 1512866)
@@ -19,19 +19,14 @@
 
 package org.apache.synapse.transport.passthru.config;
 
-import org.apache.axis2.AxisFault;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.description.ParameterInclude;
 import org.apache.axis2.transport.base.threads.WorkerPool;
 import org.apache.axis2.transport.base.threads.WorkerPoolFactory;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.impl.nio.reactor.IOReactorConfig;
-import org.apache.http.nio.params.NIOReactorPNames;
-import org.apache.http.nio.params.NIOReactorParams;
 import org.apache.http.nio.util.HeapByteBufferAllocator;
-import org.apache.http.params.BasicHttpParams;
-import org.apache.http.params.HttpConnectionParams;
-import org.apache.http.params.HttpParams;
-import org.apache.http.params.HttpProtocolParams;
+import org.apache.http.protocol.HttpProcessor;
 import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
 import org.apache.synapse.transport.passthru.util.BufferFactory;
 
@@ -49,16 +44,13 @@
     private WorkerPool workerPool = null;
 
     /** The Axis2 ConfigurationContext */
-    protected ConfigurationContext configurationContext = null;
+    private ConfigurationContext configurationContext = null;
 
-    /** Default http parameters */
-    protected HttpParams httpParameters = null;
+    private BufferFactory bufferFactory = null;
 
-    protected BufferFactory bufferFactory = null;
-
     private PassThroughTransportMetricsCollector metrics = null;
 
-    private int iOThreadsPerReactor;
+    private HttpProcessor httpProcessor;
 
     protected PassThroughConfiguration conf = PassThroughConfiguration.getInstance();
 
@@ -66,56 +58,32 @@
                              ParameterInclude parameters,
                              WorkerPool workerPool) {
         this.parameters = parameters;
-        this.workerPool = workerPool;
         this.configurationContext = configurationContext;
-    }
-
-    public void build() throws AxisFault {
-        iOThreadsPerReactor = conf.getIOThreadsPerReactor();
-
         if (workerPool == null) {
-            workerPool = WorkerPoolFactory.getWorkerPool(
-                            conf.getWorkerPoolCoreSize(),
-                            conf.getWorkerPoolMaxSize(),
-                            conf.getWorkerThreadKeepaliveSec(),
-                            conf.getWorkerPoolQueueLen(),
-                            "Pass-through Message Processing Thread Group",
-                            "PassThroughMessageProcessor");
+            this.workerPool = WorkerPoolFactory.getWorkerPool(
+                    conf.getWorkerPoolCoreSize(),
+                    conf.getWorkerPoolMaxSize(),
+                    conf.getWorkerThreadKeepaliveSec(),
+                    conf.getWorkerPoolQueueLen(),
+                    "Pass-through Message Processing Thread Group",
+                    "PassThroughMessageProcessor");
+        } else {
+            this.workerPool = workerPool;
         }
 
-        httpParameters = retrieveHttpParameters();
-        bufferFactory = new BufferFactory(conf.getIOBufferSize(), new HeapByteBufferAllocator(), 512);
+        int bufferSize = conf.getIntProperty(PassThroughConfigPNames.IO_BUFFER_SIZE, 1024 * 8);
+        bufferFactory = new BufferFactory(bufferSize, HeapByteBufferAllocator.INSTANCE, 512);
+        httpProcessor = initHttpProcessor();
     }
 
+    abstract protected HttpProcessor initHttpProcessor();
+
     public IOReactorConfig getReactorConfig() {
-        IOReactorConfig config = new IOReactorConfig();
-        config.setIoThreadCount(iOThreadsPerReactor);
-        config.setSoTimeout(
-                conf.getIntProperty(HttpConnectionParams.SO_TIMEOUT, 60000));
-        config.setConnectTimeout(
-                conf.getIntProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 0));
-        config.setRcvBufSize(
-                conf.getIntProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setSndBufSize(
-                conf.getIntProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024));
-        config.setTcpNoDelay(
-                conf.getBooleanProperty(HttpConnectionParams.TCP_NODELAY, true));
-        config.setInterestOpQueued(
-                conf.getBooleanProperty(NIOReactorParams.INTEREST_OPS_QUEUEING, false));
+        return conf.getReactorConfig();
+    }
 
-        if (conf.getIntProperty(HttpConnectionParams.SO_LINGER) != null) {
-            config.setSoLinger(conf.getIntProperty(HttpConnectionParams.SO_LINGER));
-        }
-
-        if (conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR) != null) {
-            config.setSoReuseAddress(conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR));
-        }
-
-        if (conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL) != null) {
-            config.setSelectInterval(conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL));
-        }
-
-        return config;
+    public ConnectionConfig getConnectionConfig() {
+        return conf.getConnectionConfig();
     }
 
     public WorkerPool getWorkerPool() {
@@ -126,51 +94,14 @@
         return configurationContext;
     }
 
-    protected HttpParams retrieveHttpParameters() throws AxisFault {
-        HttpParams params = new BasicHttpParams();
-        params.
-            setIntParameter(HttpConnectionParams.SO_TIMEOUT,
-                    conf.getIntProperty(HttpConnectionParams.SO_TIMEOUT, 60000)).
-            setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,
-                    conf.getIntProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 0)).
-            setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,
-                    conf.getIntProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024)).
-            setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK,
-                    conf.getBooleanProperty(HttpConnectionParams.STALE_CONNECTION_CHECK, false)).
-            setBooleanParameter(HttpConnectionParams.TCP_NODELAY,
-                    conf.getBooleanProperty(HttpConnectionParams.TCP_NODELAY, true)).
-            setBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING,
-                    conf.getBooleanProperty(NIOReactorParams.INTEREST_OPS_QUEUEING, false)).
-            setParameter(HttpProtocolParams.ORIGIN_SERVER,
-                    conf.getStringProperty(HttpProtocolParams.ORIGIN_SERVER, "Synapse-PassThrough-HTTP")).
-            setParameter(HttpProtocolParams.HTTP_MALFORMED_INPUT_ACTION,
-                    conf.getMalformedInputActionValue()).
-            setParameter(HttpProtocolParams.HTTP_UNMAPPABLE_INPUT_ACTION,
-                    conf.getUnMappableInputActionValue());
-        /* Set advanced tuning params only if they are explicitly set so that we are not loosing
-           internal defaults of HttpCore-NIO */
-        if (conf.getIntProperty(HttpConnectionParams.SO_LINGER) != null) {
-            HttpConnectionParams.setLinger(params,
-                    conf.getIntProperty(HttpConnectionParams.SO_LINGER));
-        }
-
-        if (conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR) != null) {
-            HttpConnectionParams.setSoReuseaddr(params,
-                    conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR));
-        }
-
-        if (conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL) != null) {
-            NIOReactorParams.setSelectInterval(params,
-                    conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL));
-        }
-
-        return params;
-    }
-
     public BufferFactory getBufferFactory() {
         return bufferFactory;
     }
 
+    public HttpProcessor getHttpProcessor() {
+        return httpProcessor;
+    }
+
     public PassThroughTransportMetricsCollector getMetrics() {
         return metrics;
     }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java	(revision 1512866)
@@ -25,10 +25,8 @@
 import org.apache.axis2.transport.TransportListener;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.http.params.*;
 import org.apache.http.protocol.*;
 import org.apache.http.HttpResponseFactory;
-import org.apache.http.HttpResponseInterceptor;
 import org.apache.http.impl.DefaultHttpResponseFactory;
 import org.apache.axis2.transport.base.threads.WorkerPool;
 import org.apache.axis2.transport.base.ParamUtils;
@@ -48,9 +46,6 @@
 
     private Log log = LogFactory.getLog(SourceConfiguration.class);
 
-    /** This is used to process HTTP responses */
-    private HttpProcessor httpProcessor = null;
-
     /** Response factory used for creating HTTP Responses */
     private HttpResponseFactory responseFactory = null;
 
@@ -60,46 +55,34 @@
     /** Object to manage the source connections */
     private SourceConnections sourceConnections = null;
 
-    private TransportInDescription inDescription;
-
     private String host;
 
+    private String transportName;
+
     /** The EPR prefix for services available over this transport */
     private String serviceEPRPrefix;
+
     /** The EPR prefix for services with custom URI available over this transport */
     private String customEPRPrefix;
     
     /** SSLContext if this listener is a SSL listener */
     private boolean ssl = false;
-    
-    
+
     /** WSDL processor for Get requests*/
     private HttpGetRequestProcessor httpGetRequestProcessor = null;
 
-
     public SourceConfiguration(ConfigurationContext configurationContext,
                                TransportInDescription description,
-                               WorkerPool pool) {
+                               WorkerPool pool, boolean ssl) throws AxisFault {
+
         super(configurationContext, description, pool);
-        this.inDescription = description;
-        httpProcessor = new ImmutableHttpProcessor(
-                new HttpResponseInterceptor[]{
-                        new ResponseDate(),
-                        new ResponseServer(),
-                        new ResponseContent(),
-                        new ResponseConnControl()});
+        this.transportName = description.getName();
+        this.ssl = ssl;
+        this.responseFactory = new DefaultHttpResponseFactory();
+        this.sourceConnections = new SourceConnections();
+        this.port = ParamUtils.getRequiredParamInt(parameters, "port");
 
-        responseFactory = new DefaultHttpResponseFactory();
-
-        sourceConnections = new SourceConnections();
-    }
-
-    public void build() throws AxisFault {
-        super.build();
-
-        port = ParamUtils.getRequiredParamInt(parameters, "port");
-
-        Parameter hostParameter = inDescription.getParameter(TransportListener.HOST_ADDRESS);
+        Parameter hostParameter = parameters.getParameter(TransportListener.HOST_ADDRESS);
         if (hostParameter != null) {
             host = ((String) hostParameter.getValue()).trim();
         } else {
@@ -110,34 +93,35 @@
             }
         }
 
-        Parameter param = inDescription.getParameter(PassThroughConstants.WSDL_EPR_PREFIX);
+        Parameter param = parameters.getParameter(PassThroughConstants.WSDL_EPR_PREFIX);
         if (param != null) {
             serviceEPRPrefix = getServiceEPRPrefix(configurationContext, (String) param.getValue());
             customEPRPrefix = (String) param.getValue();
         } else {
             serviceEPRPrefix = getServiceEPRPrefix(configurationContext, host, port);
-            customEPRPrefix = inDescription.getName() + "://" + host + ":" +
+            customEPRPrefix = transportName + "://" + host + ":" +
                     (port == 80 ? "" : port) + "/";
         }
-        
+
         // create http Get processor
-        param = inDescription.getParameter(NhttpConstants.HTTP_GET_PROCESSOR);
+        param = parameters.getParameter(NhttpConstants.HTTP_GET_PROCESSOR);
         if (param != null && param.getValue() != null) {
             httpGetRequestProcessor = createHttpGetProcessor(param.getValue().toString());
             if (httpGetRequestProcessor == null) {
                 handleException("Cannot create HttpGetRequestProcessor");
             }
-        } 
+        }
     }
 
-    public HttpParams getHttpParameters() {
-        return httpParameters;
+    @Override
+    protected HttpProcessor initHttpProcessor() {
+        return new ImmutableHttpProcessor(
+                new ResponseDate(),
+                new ResponseServer("Synapse-PassThrough-Http"),
+                new ResponseContent(),
+                new ResponseConnControl());
     }
 
-    public HttpProcessor getHttpProcessor() {
-        return httpProcessor;
-    }
-
     public HttpResponseFactory getResponseFactory() {
         return responseFactory;
     }
@@ -150,8 +134,8 @@
         return sourceConnections;
     }
 
-    public TransportInDescription getInDescription() {
-        return inDescription;
+    public String getTransportName() {
+        return transportName;
     }
 
     public String getServiceEPRPrefix() {
@@ -161,19 +145,11 @@
     public String getCustomEPRPrefix() {
         return customEPRPrefix;
     }
-    
-    
-    
+
     public boolean isSsl() {
 		return ssl;
 	}
 
-	public void setSsl(boolean ssl) {
-		this.ssl = ssl;
-	}
-	
-	
-	
 	public HttpGetRequestProcessor getHttpGetRequestProcessor() {
 		return httpGetRequestProcessor;
 	}
@@ -221,8 +197,6 @@
 		}
 	}
     
-    
-    
     private HttpGetRequestProcessor createHttpGetProcessor(String str) throws AxisFault {
         Object obj = null;
         try {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java	(revision 1512866)
@@ -16,6 +16,7 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
+
 package org.apache.synapse.transport.passthru;
 
 import org.apache.axis2.AxisFault;
@@ -25,8 +26,6 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.nio.NHttpServerConnection;
 
-import java.io.OutputStream;
-
 /**
  * This PassThrough transport level interface is used for plugging in different implementations
  * for special processing of some HTTP GET requests.
@@ -54,7 +53,6 @@
      * @param response      The HttpResponse
      * @param msgContext    The MessageContext
      * @param conn          The NHttpServerConnection
-     * @param os            The OutputStream
      * @param isRestDispatching Rest dispatching
      */
     void process(HttpRequest request,
@@ -61,7 +59,6 @@
                  HttpResponse response,
                  MessageContext msgContext,
                  NHttpServerConnection conn,
-                 OutputStream os,
                  boolean isRestDispatching);
 
 }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/api/PassThroughNHttpGetProcessor.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/api/PassThroughNHttpGetProcessor.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/api/PassThroughNHttpGetProcessor.java	(revision 1512866)
@@ -43,6 +43,8 @@
 import org.apache.http.HttpResponse;
 import org.apache.http.HttpStatus;
 import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.nio.entity.ContentOutputStream;
+import org.apache.http.nio.util.SimpleOutputBuffer;
 import org.apache.http.protocol.HTTP;
 import org.apache.synapse.transport.nhttp.NHttpConfiguration;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
@@ -51,6 +53,7 @@
 import org.apache.synapse.transport.passthru.ProtocolState;
 import org.apache.synapse.transport.passthru.SourceContext;
 import org.apache.synapse.transport.passthru.SourceHandler;
+import org.apache.synapse.transport.passthru.config.PassThroughConfiguration;
 import org.apache.ws.commons.schema.XmlSchema;
 
 public class PassThroughNHttpGetProcessor implements HttpGetRequestProcessor {
@@ -76,7 +79,7 @@
 
 	public void process(HttpRequest request, HttpResponse response,
 			MessageContext msgContext, NHttpServerConnection conn,
-			OutputStream os, boolean isRestDispatching) {
+			boolean isRestDispatching) {
 
 		String uri = request.getRequestLine().getUri();
 		String serviceName = getServiceName(request);
@@ -101,6 +104,10 @@
 			msgContext.setTo(new EndpointReference(uri));
 		}
 
+        SimpleOutputBuffer outputBuffer = (SimpleOutputBuffer) conn.getContext().getAttribute(
+                PassThroughConstants.PASS_THROUGH_RESPONSE_SOURCE_BUFFER);
+        ContentOutputStream os = new ContentOutputStream(outputBuffer);
+
 		if (isServiceListBlocked(uri)) {
             sendResponseAndFinish(response, HttpStatus.SC_FORBIDDEN, conn, os, msgContext);
 		} else if (uri.equals("/favicon.ico")) {
@@ -132,7 +139,7 @@
                                        MessageContext msgContext) throws IOException {
         SourceContext.updateState(conn, ProtocolState.GET_REQUEST_COMPLETE);
         sourceHandler.commitResponseHideExceptions(conn, response);
-        os.write(data);
+        write(conn, os, data);
         closeOutputStream(os);
         msgContext.setProperty(PassThroughConstants.GET_REQUEST_HANDLED, Boolean.TRUE);
     }
@@ -181,7 +188,7 @@
                 sendResponseAndFinish(response, output.toByteArray(), conn, os, msgContext);
 
 			} catch (Exception e) {
-				handleBrowserException(response, conn, os,
+				handleBrowserException(response, msgContext, conn, os,
 						"Error generating ?wsdl output for service : " + serviceName, e);
 			}
 		} else {
@@ -216,7 +223,7 @@
 					.getParameterValue("serviceType");
 			if ("proxy".equals(parameterValue)
 					&& !isWSDLProvidedForProxyService(service)) {
-				handleBrowserException(response, conn, os,
+				handleBrowserException(response, msgContext, conn, os,
 						"No WSDL was provided for the Service " + serviceName
 								+ ". A WSDL cannot be generated.", null);
 			}
@@ -226,7 +233,7 @@
 				response.addHeader(CONTENT_TYPE, TEXT_XML);
                 sendResponseAndFinish(response, output.toByteArray(), conn, os, msgContext);
 			} catch (Exception e) {
-				handleBrowserException(response, conn, os,
+				handleBrowserException(response, msgContext, conn, os,
 						"Error generating ?wsdl2 output for service : "
 								+ serviceName, e);
 			}
@@ -316,7 +323,7 @@
 					response.addHeader(CONTENT_TYPE, TEXT_XML);
                     sendResponseAndFinish(response, output.toByteArray(), conn, os, msgContext);
 				} catch (Exception e) {
-					handleBrowserException(response, conn, os,
+					handleBrowserException(response, msgContext, conn, os,
 							"Error generating ?xsd output for service : "
 									+ serviceName, e);
 				}
@@ -351,11 +358,11 @@
 						response.addHeader(CONTENT_TYPE, TEXT_XML);
 						sourceHandler.commitResponseHideExceptions(conn,
 								response);
-						os.write(output.toByteArray());
+                        write(conn, os, output.toByteArray());
 						closeOutputStream(os);
                         msgContext.setProperty(PassThroughConstants.GET_REQUEST_HANDLED, Boolean.TRUE);
 					} catch (Exception e) {
-						handleBrowserException(response, conn, os,
+						handleBrowserException(response, msgContext, conn, os,
 								"Error generating named ?xsd output for service : "
 										+ serviceName, e);
 					}
@@ -372,7 +379,6 @@
 		}
 	}
 
-	
 	/**
      * Handles browser exception.
      *
@@ -382,7 +388,7 @@
      * @param msg      message
      * @param e        Exception
      */
-    protected void handleBrowserException(HttpResponse response,
+    protected void handleBrowserException(HttpResponse response, MessageContext msgContext,
                                           NHttpServerConnection conn, OutputStream os,
                                           String msg, Exception e) {
         if (e == null) {
@@ -397,7 +403,7 @@
             response.addHeader(CONTENT_TYPE, TEXT_HTML);
             sourceHandler.commitResponseHideExceptions(conn, response);
             try {
-                os.write(msg.getBytes());
+                write(conn, os, msg.getBytes());
                 os.close();
             } catch (IOException ignore) {
             }
@@ -409,6 +415,7 @@
             } catch (IOException ignore) {
             }
         }
+        msgContext.setProperty(PassThroughConstants.GET_REQUEST_HANDLED, Boolean.TRUE);
     }
     
     
@@ -421,8 +428,7 @@
 	 * @return whether to proceed with incomingURI
 	 */
 	protected boolean isServiceListBlocked(String incomingURI) {
-		String isBlocked = NHttpConfiguration.getInstance()
-				.isServiceListBlocked();
+		String isBlocked = NHttpConfiguration.getInstance().isServiceListBlocked();
 
 		return (("/services").equals(incomingURI) || ("/services" + "/")
 				.equals(incomingURI)) && Boolean.parseBoolean(isBlocked);
@@ -474,4 +480,15 @@
         return hostAddress.split("[.]").length == 4;
     }
 
+    private void write(NHttpServerConnection conn, OutputStream os,
+                       byte[] data) throws IOException {
+        synchronized (conn.getContext()) {
+            // The SimpleOutputBuffer on which this output stream is based is not thread safe.
+            // Explicit synchronization required.
+            // Do not worry about running out of buffer space.
+            // SimpleOutputBuffer expands to fit the data.
+            os.write(data);
+        }
+    }
+
 }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(revision 1512866)
@@ -24,11 +24,12 @@
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.transport.base.ParamUtils;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.nio.NHttpClientEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;
 import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
 import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;
@@ -53,12 +54,12 @@
 
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler,
                                                SSLContext sslContext,
-                                               SSLSetupHandler sslIOSessionHandler,
-                                               HttpParams params,
+                                               SSLSetupHandler sslSetupHandler,
+                                               ConnectionConfig config,
                                                TransportOutDescription transportOut) throws AxisFault {
 
-        return new SSLTargetIOEventDispatch(handler, sslContext, getCustomSSLContexts(transportOut),
-                sslIOSessionHandler, params);
+        return LoggingUtils.getClientIODispatch(handler, config, sslContext, sslSetupHandler,
+                getCustomSSLContexts(transportOut));
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java	(revision 1512866)
@@ -16,6 +16,7 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
+
 package org.apache.synapse.transport.passthru.util;
 
 import org.apache.axiom.om.OMElement;
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java	(revision 1512866)
@@ -42,7 +42,7 @@
         if (allocator != null) {
             this.allocator = allocator;
         } else {
-            this.allocator = new HeapByteBufferAllocator();
+            this.allocator = HeapByteBufferAllocator.INSTANCE;
         }
 
         buffers = new ByteBuffer[size];
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java	(revision 1512866)
@@ -20,13 +20,11 @@
 package org.apache.synapse.transport.passthru;
 
 import org.apache.http.nio.*;
-import org.apache.http.nio.entity.ContentOutputStream;
 import org.apache.http.nio.util.ContentOutputBuffer;
 import org.apache.http.nio.util.HeapByteBufferAllocator;
+import org.apache.http.*;
 import org.apache.http.nio.util.SimpleOutputBuffer;
-import org.apache.http.*;
 import org.apache.http.protocol.*;
-import org.apache.http.params.DefaultedHttpParams;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.axis2.AxisFault;
 import org.apache.commons.logging.Log;
@@ -36,7 +34,6 @@
 import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
 
 import java.io.IOException;
-import java.io.OutputStream;
 
 /**
  * This is the class where transport interacts with the client. This class
@@ -100,17 +97,16 @@
 
             String method = request.getRequest() != null ?
                     request.getRequest().getRequestLine().getMethod().toUpperCase() : "";
-            OutputStream os = null;
 			if ("GET".equals(method)) {
 				HttpContext context = request.getConnection().getContext();
 				ContentOutputBuffer outputBuffer = new SimpleOutputBuffer(8192,
-                        new HeapByteBufferAllocator());
-				context.setAttribute("synapse.response-source-buffer",outputBuffer);
-				os = new ContentOutputStream(outputBuffer);
+                        HeapByteBufferAllocator.INSTANCE);
+				context.setAttribute(PassThroughConstants.PASS_THROUGH_RESPONSE_SOURCE_BUFFER,
+                        outputBuffer);
 			} 
 
             sourceConfiguration.getWorkerPool().execute(
-                    new ServerWorker(request, sourceConfiguration,os));
+                    new ServerWorker(request, sourceConfiguration));
 
         } catch (HttpException e) {
             log.error("HTTP exception while processing request", e);
@@ -186,31 +182,32 @@
         }
     }
 
-    public void outputReady(NHttpServerConnection conn,
-                            ContentEncoder encoder) {
+    public void outputReady(NHttpServerConnection conn, ContentEncoder encoder) {
         try {
             ProtocolState protocolState = SourceContext.getState(conn);
-            
-            //special case to handle WSDLs
-            if(protocolState == ProtocolState.GET_REQUEST_COMPLETE){
-            	// we need to shut down if the shutdown flag is set
-            	 HttpContext context = conn.getContext();
-            	 ContentOutputBuffer outBuf = (ContentOutputBuffer) context.getAttribute(
-                         "synapse.response-source-buffer");
-            	  int bytesWritten = outBuf.produceContent(encoder);
-                  if (metrics != null && bytesWritten > 0) {
-                      metrics.incrementBytesSent(bytesWritten);
-                  }
-                
-                  conn.requestInput();
-                  if(outBuf instanceof SimpleOutputBuffer && !((SimpleOutputBuffer)outBuf).hasData()){
-                	  sourceConfiguration.getSourceConnections().releaseConnection(conn);
-                  }
-                  
-            	return;
+
+            // special case to handle WSDLs
+            if (protocolState == ProtocolState.GET_REQUEST_COMPLETE) {
+                SimpleOutputBuffer outBuf = (SimpleOutputBuffer) conn.getContext().getAttribute(
+                        PassThroughConstants.PASS_THROUGH_RESPONSE_SOURCE_BUFFER);
+                synchronized (conn.getContext()) {
+                    // SimpleOutputBuffer is not thread safe
+                    // Explicit synchronization required
+                    int bytesWritten = outBuf.produceContent(encoder);
+                    if (metrics != null && bytesWritten > 0) {
+                        metrics.incrementBytesSent(bytesWritten);
+                    }
+
+                    conn.requestInput();
+                    if (!outBuf.hasData()) {
+                        // We are done - At this point the entire response payload has been
+                        // written out to the SimpleOutputBuffer
+                        sourceConfiguration.getSourceConnections().releaseConnection(conn);
+                    }
+                }
+                return;
             }
-            
-                        
+
             if (protocolState != ProtocolState.RESPONSE_HEAD
                     && protocolState != ProtocolState.RESPONSE_BODY) {
                 log.warn("Illegal incoming connection state: "
@@ -222,7 +219,6 @@
             }
 
             SourceContext.updateState(conn, ProtocolState.RESPONSE_BODY);
-
             SourceResponse response = SourceContext.getResponse(conn);
 
             int bytesSent = response.write(conn, encoder);
@@ -272,6 +268,7 @@
         } else if (e instanceof IOException) {
             exception(conn, (IOException) e);
         } else {
+            log.error("Unexpected exception encountered in SourceHandler", e);
             metrics.incrementFaultsReceiving();
 
             ProtocolState state = SourceContext.getState(conn);
@@ -337,38 +334,37 @@
             metrics.incrementFaultsReceiving();
         } else {
             log.error("Unexpected I/O error: " + e.getClass().getName(), e);
-
             metrics.incrementFaultsReceiving();
         }
     }
 
     public void exception(NHttpServerConnection conn, HttpException e) {
-        try {
-            if (conn.isResponseSubmitted()) {
-                sourceConfiguration.getSourceConnections().shutDownConnection(conn);
-                return;
-            }
-            HttpContext httpContext = conn.getContext();
+        if (log.isDebugEnabled()) {
+            log.debug("HTTP protocol error encountered in SourceHandler", e);
+        }
 
-            HttpResponse response = new BasicHttpResponse(
-                    HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, "Bad request");
-            response.setParams(
-                    new DefaultedHttpParams(sourceConfiguration.getHttpParameters(),
-                            response.getParams()));
-            response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);
+        if (conn.isResponseSubmitted()) {
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+            return;
+        }
+        HttpContext httpContext = conn.getContext();
 
-            // Pre-process HTTP request
-            httpContext.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
-            httpContext.setAttribute(ExecutionContext.HTTP_REQUEST, null);
-            httpContext.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
+        HttpResponse response = new BasicHttpResponse(
+                HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, "Bad request");
+        response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);
 
+        // Pre-process HTTP request
+        httpContext.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
+        httpContext.setAttribute(ExecutionContext.HTTP_REQUEST, null);
+        httpContext.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
+
+        try {
             sourceConfiguration.getHttpProcessor().process(response, httpContext);
-
-            conn.submitResponse(response);            
+            conn.submitResponse(response);
             SourceContext.updateState(conn, ProtocolState.CLOSED);
             conn.close();
-        } catch (Exception e1) {
-            log.error(e.getMessage(), e);
+        } catch (Exception ex) {
+            log.error("Error while handling HttpException", ex);
             SourceContext.updateState(conn, ProtocolState.CLOSED);
             sourceConfiguration.getSourceConnections().shutDownConnection(conn);
         }
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java	(revision 1512866)
@@ -31,7 +31,6 @@
 import org.apache.http.message.BasicHttpRequest;
 import org.apache.http.nio.ContentEncoder;
 import org.apache.http.nio.NHttpClientConnection;
-import org.apache.http.params.DefaultedHttpParams;
 import org.apache.http.protocol.ExecutionContext;
 import org.apache.http.protocol.HTTP;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
@@ -203,24 +202,15 @@
                     MessageFormatterDecoratorFactory.createMessageFormatterDecorator(requestMsgCtx);
                 request.setHeader(HTTPConstants.HEADER_SOAP_ACTION,
                         messageFormatter.formatSOAPAction(requestMsgCtx, null, soapAction));
-                request.setHeader(HTTPConstants.USER_AGENT,"Synapse-PT-HttpComponents-NIO");
+                request.setHeader(HttpHeaders.USER_AGENT, "Synapse-PT-HttpComponents-NIO");
             }
     	}
 
-        request.setParams(new DefaultedHttpParams(request.getParams(),
-                targetConfiguration.getHttpParameters()));
-        
-        
-	
-		
-		this.processChunking(conn, requestMsgCtx);
-		
+        this.processChunking(conn, requestMsgCtx);
 
         if (!keepAlive) {
             request.setHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);
         }
-        
-       
 
         // Pre-process HTTP request
         conn.getContext().setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
@@ -230,8 +220,7 @@
 
         // start the request
         targetConfiguration.getHttpProcessor().process(request, conn.getContext());
-        
-        
+
         conn.submitRequest(request);
 
         if (hasEntityBody) {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(revision 1512866)
@@ -23,11 +23,12 @@
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportInDescription;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.nio.NHttpServerEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 import javax.net.ssl.*;
 import javax.xml.namespace.QName;
@@ -40,8 +41,8 @@
 
     @Override
     protected IOEventDispatch getEventDispatch(NHttpServerEventHandler handler, SSLContext sslContext,
-                                               SSLSetupHandler sslSetupHandler, HttpParams params) {
-        return new SSLSourceIOEventDispatch(handler, sslContext, sslSetupHandler, params);
+                                               SSLSetupHandler sslSetupHandler, ConnectionConfig config) {
+        return LoggingUtils.getServerIODispatch(handler, config, sslContext, sslSetupHandler);
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java	(revision 1512866)
@@ -35,6 +35,7 @@
 import org.apache.axis2.util.JavaUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.impl.nio.reactor.DefaultListeningIOReactor;
 import org.apache.http.nio.NHttpServerEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
@@ -41,8 +42,8 @@
 import org.apache.http.nio.reactor.IOReactorExceptionHandler;
 import org.apache.http.nio.reactor.ListenerEndpoint;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
 import org.apache.synapse.transport.nhttp.util.NhttpMetricsCollector;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 import javax.net.ssl.SSLContext;
 import java.io.IOException;
@@ -89,8 +90,8 @@
 
     protected IOEventDispatch getEventDispatch(
         NHttpServerEventHandler handler, SSLContext sslContext,
-        SSLSetupHandler setupHandler, HttpParams params) {
-        return new PlainServerIOEventDispatch(handler, params);
+        SSLSetupHandler setupHandler, ConnectionConfig config) {
+        return LoggingUtils.getServerIODispatch(handler, config);
     }
 
     /**
@@ -197,7 +198,6 @@
         }
         
         // configure the IO reactor on the specified port
-        HttpParams params = listenerContext.getParams();
         try {
             String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";
             ioReactor = new DefaultListeningIOReactor(
@@ -229,7 +229,7 @@
 
         handler = new ServerHandler(listenerContext);
         final IOEventDispatch ioEventDispatch = getEventDispatch(handler,
-                sslContext, sslSetupHandler, params);
+                sslContext, sslSetupHandler, listenerContext.getConnectionConfig());
         state = BaseConstants.STARTED;
 
         listenerContext.getHttpGetRequestProcessor().init(cfgCtx, handler);
@@ -354,7 +354,7 @@
     }
 
     /**
-     * Returns the number of requestes queued in the thread pool
+     * Returns the number of requests queued in the thread pool
      * @return queue size
      */
     public int getQueueSize() {
@@ -383,34 +383,6 @@
 
 
     /**
-     * Return the EPR for the given service (implements deprecated method temporarily)
-     */
-    public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {
-
-        String trailer = "";
-        //Strip out the operation name
-        if (serviceName.indexOf('/') != -1) {
-            trailer += serviceName.substring(serviceName.indexOf("/"));
-            serviceName = serviceName.substring(0, serviceName.indexOf('/'));
-        }
-        // strip out the endpoint name if present
-        if (serviceName.indexOf('.') != -1) {
-            trailer += serviceName.substring(serviceName.indexOf("."));
-            serviceName = serviceName.substring(0, serviceName.indexOf('.'));
-        }
-
-        if (serviceNameToEPRMap.containsKey(serviceName)) {
-            return new EndpointReference(
-                    customEPRPrefix + serviceNameToEPRMap.get(serviceName) + trailer);
-        } else {
-            if (serviceEPRPrefix == null) {
-                return null;
-            }
-            return new EndpointReference(serviceEPRPrefix + serviceName + trailer);
-        }
-    }
-
-    /**
      * Return the EPRs for the given service over this transport
      * @param serviceName name of the service
      * @param ip IP address
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java	(revision 1512866)
@@ -30,7 +30,6 @@
 import org.apache.http.impl.DefaultConnectionReuseStrategy;
 import org.apache.http.impl.DefaultHttpResponseFactory;
 import org.apache.http.nio.*;
-import org.apache.http.nio.util.ByteBufferAllocator;
 import org.apache.http.nio.util.HeapByteBufferAllocator;
 import org.apache.http.nio.util.ContentOutputBuffer;
 import org.apache.http.nio.util.ContentInputBuffer;
@@ -38,7 +37,6 @@
 import org.apache.http.nio.util.SharedOutputBuffer;
 import org.apache.http.nio.entity.ContentInputStream;
 import org.apache.http.nio.entity.ContentOutputStream;
-import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.*;
 import org.apache.http.util.EncodingUtils;
 import org.apache.commons.logging.Log;
@@ -68,8 +66,6 @@
 
     private static final Log log = LogFactory.getLog(ServerHandler.class);
 
-    /** the HTTP protocol parameters to adhere to */
-    private final HttpParams params;
     /** the factory to create HTTP responses */
     private final HttpResponseFactory responseFactory;
     /** the HTTP response processor */
@@ -76,15 +72,11 @@
     private final HttpProcessor httpProcessor;
     /** the strategy to re-use connections */
     private final ConnectionReuseStrategy connStrategy;
-    /** the buffer allocator */
-    private final ByteBufferAllocator allocator;
 
     /** the Axis2 configuration context */
     ConfigurationContext cfgCtx = null;
     /** the nhttp configuration */
     private NHttpConfiguration cfg = null;
-    /** is this https? */
-    private boolean isHttps = false;
 
     /** the thread pool to process requests */
     private WorkerPool workerPool = null;
@@ -95,22 +87,17 @@
     private volatile List<NHttpServerConnection> activeConnections = null;
 
     /**
-     * This parset is used by the priority executor to parse a given HTTP message and
+     * This parser is used by the priority executor to parse a given HTTP message and
      * determine the priority of the message
      */
     private Parser parser = null;
 
-    /** WSDL processor for Get requests*/
-    private HttpGetRequestProcessor httpGetRequestProcessor = null;
-
     /**
-     * An executor capable of exucuting the Server Worker according the priority assigned
+     * An executor capable of executing the Server Worker according the priority assigned
      * to a particular message
      */
     private PriorityExecutor executor = null;
 
-    private boolean restDispatching = true;
-    
     private LatencyView latencyView = null;
     private LatencyView s2sLatencyView = null;
     private ThreadingView threadingView = null;
@@ -126,18 +113,14 @@
         super();
         this.listenerContext = listenerContext;
         this.cfgCtx = listenerContext.getCfgCtx();
-        this.params = listenerContext.getParams();
-        this.isHttps = listenerContext.isSsl();
         this.metrics = listenerContext.getMetrics();
         this.responseFactory = new DefaultHttpResponseFactory();
         this.httpProcessor = getHttpProcessor();
         this.connStrategy = new DefaultConnectionReuseStrategy();
-        this.allocator = new HeapByteBufferAllocator();
         this.activeConnections = new ArrayList<NHttpServerConnection>();
         this.latencyView = new LatencyView("NHTTPLatencyView", listenerContext.getTransportIn().getName());
         this.s2sLatencyView = new LatencyView("NHTTPS2SLatencyView", listenerContext.getTransportIn().getName());
         this.threadingView = new ThreadingView("HttpServerWorker", true, 50);
-        this.restDispatching = listenerContext.isRestDispatching();
 
         this.cfg = NHttpConfiguration.getInstance();
         if (listenerContext.getExecutor() == null)  {
@@ -151,8 +134,6 @@
             this.executor = listenerContext.getExecutor();
             this.parser = listenerContext.getParser();
         }
-
-        this.httpGetRequestProcessor = listenerContext.getHttpGetRequestProcessor();
     }
 
     /**
@@ -179,7 +160,7 @@
                 conn.getContext().setAttribute(NhttpConstants.REQUEST_READ, Boolean.FALSE);
                 
                 ContentInputBuffer inputBuffer
-                        = new SharedInputBuffer(cfg.getBufferSize(), conn, allocator);
+                        = new SharedInputBuffer(cfg.getBufferSize(), HeapByteBufferAllocator.INSTANCE);
                 context.setAttribute(REQUEST_SINK_BUFFER, inputBuffer);
                 is = new ContentInputStream(inputBuffer);
             } else {
@@ -188,7 +169,7 @@
             }
             
             ContentOutputBuffer outputBuffer
-                    = new SharedOutputBuffer(cfg.getBufferSize(), conn, allocator);
+                    = new SharedOutputBuffer(cfg.getBufferSize(), HeapByteBufferAllocator.INSTANCE);
             context.setAttribute(RESPONSE_SOURCE_BUFFER, outputBuffer);
             OutputStream os = new ContentOutputStream(outputBuffer);
 
@@ -196,7 +177,6 @@
             ProtocolVersion httpVersion = request.getRequestLine().getProtocolVersion();
             HttpResponse response = responseFactory.newHttpResponse(
                 httpVersion, HttpStatus.SC_OK, context);
-            response.setParams(this.params);
 
             // create a basic HttpEntity using the source channel of the response pipe
             BasicHttpEntity entity = new BasicHttpEntity();
@@ -243,11 +223,11 @@
     public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {
 
         HttpContext context = conn.getContext();
-        ContentInputBuffer inBuf
-                = (ContentInputBuffer) context.getAttribute(REQUEST_SINK_BUFFER);
+        SharedInputBuffer inBuf
+                = (SharedInputBuffer) context.getAttribute(REQUEST_SINK_BUFFER);
 
         try {
-            int bytesRead = inBuf.consumeContent(decoder);
+            int bytesRead = inBuf.consumeContent(decoder, conn);
             if (metrics != null && bytesRead > 0) {
                 metrics.incrementBytesReceived(bytesRead);
             }
@@ -278,17 +258,17 @@
 
         HttpContext context = conn.getContext();
         HttpResponse response = conn.getHttpResponse();
-        ContentOutputBuffer outBuf = (ContentOutputBuffer) context.getAttribute(
+        SharedOutputBuffer outBuf = (SharedOutputBuffer) context.getAttribute(
                 RESPONSE_SOURCE_BUFFER);
 
         if (outBuf == null) {
-            // fix for SYNAPSE 584. This is a temporaly fix becuase of HTTPCORE-208
+            // fix for SYNAPSE 584. This is a temporarily fix because of HTTPCORE-208
             shutdownConnection(conn);
             return;
         }
 
         try {
-            int bytesWritten = outBuf.produceContent(encoder);
+            int bytesWritten = outBuf.produceContent(encoder, conn);
             if (metrics != null && bytesWritten > 0) {
                 metrics.incrementBytesSent(bytesWritten);
             }
@@ -490,6 +470,9 @@
      * @param e the exception encountered
      */
     public void exception(final NHttpServerConnection conn, final HttpException e) {
+        if (log.isDebugEnabled()) {
+            log.debug("HTTP protocol error encountered in ServerHandler", e);
+        }
         if (metrics != null) {
             metrics.incrementFaultsReceiving();
         }
@@ -522,7 +505,7 @@
         } else if (e instanceof IOException) {
             exception(conn, (IOException) e);
         } else {
-            log.error("Unexpected I/O error: " + e.getClass().getName(), e);
+            log.error("Unexpected error: " + e.getClass().getName(), e);
             if (metrics != null) {
                 metrics.incrementFaultsReceiving();
             }
@@ -609,12 +592,11 @@
      * @return the HttpProcessor that processes HttpResponses of this server
      */
     private HttpProcessor getHttpProcessor() {
-        BasicHttpProcessor httpProcessor = new BasicHttpProcessor();
-        httpProcessor.addInterceptor(new ResponseDate());
-        httpProcessor.addInterceptor(new ResponseServer());
-        httpProcessor.addInterceptor(new ResponseContent());
-        httpProcessor.addInterceptor(new ResponseConnControl());
-        return httpProcessor;
+        return new ImmutableHttpProcessor(
+                new ResponseDate(),
+                new ResponseServer("Synapse-HttpComponents-NIO"),
+                new ResponseContent(),
+                new ResponseConnControl());
     }
 
     public int getActiveCount() {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/debug/NhttpConnectionDebugConfig.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/debug/NhttpConnectionDebugConfig.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/debug/NhttpConnectionDebugConfig.java	(revision 1512866)
@@ -53,13 +53,13 @@
 
     private NhttpConnectionDebugConfig() {
 
-        this.keyValueSeparator = NHttpConfiguration.getInstance().getStringValue(
+        this.keyValueSeparator = NHttpConfiguration.getInstance().getStringProperty(
                 KEY_VALUE_SEPARATOR_PROPERTY, DEFAULT_KEY_VALUE_SEPARATOR);
-        this.fieldSeparator = NHttpConfiguration.getInstance().getStringValue(
+        this.fieldSeparator = NHttpConfiguration.getInstance().getStringProperty(
                 FIELD_SEPARATOR_PROPERTY, DEFAULT_FIELD_SEPARATOR);
-        this.statementSeparator = NHttpConfiguration.getInstance().getStringValue(
+        this.statementSeparator = NHttpConfiguration.getInstance().getStringProperty(
                 STATEMENT_SEPARATOR_PROPERTY, DEFAULT_STATEMENT_SEPARATOR);
-        String headerSet = NHttpConfiguration.getInstance().getStringValue(
+        String headerSet = NHttpConfiguration.getInstance().getStringProperty(
                 HEADER_INFO_PROPERTY, HEADER_INFO_ALL);
         if (HEADER_INFO_NONE.equals(headerSet)) {
             this.noHeaders = true;
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java	(revision 1512866)
@@ -16,6 +16,7 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
+
 package org.apache.synapse.transport.nhttp;
 
 import org.apache.axiom.om.OMAbstractFactory;
@@ -49,8 +50,6 @@
 import org.apache.http.nio.util.SharedInputBuffer;
 import org.apache.http.nio.util.SharedOutputBuffer;
 import org.apache.http.nio.entity.ContentInputStream;
-import org.apache.http.params.DefaultedHttpParams;
-import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.*;
 import org.apache.synapse.transport.nhttp.debug.ClientConnectionDebug;
 import org.apache.synapse.transport.nhttp.util.NhttpMetricsCollector;
@@ -76,8 +75,6 @@
 
     private static final Log log = LogFactory.getLog(ClientHandler.class);
 
-    /** the HTTP protocol parameters to adhere to for outgoing messages */
-    private final HttpParams params;
     /** the HttpProcessor for response messages received */
     private final HttpProcessor httpProcessor;
     /** the connection re-use strategy */
@@ -122,15 +119,12 @@
      * context and Http protocol parameters given
      * 
      * @param cfgCtx the Axis2 configuration context
-     * @param params the Http protocol parameters to adhere to
      * @param metrics statistics collection metrics
      */
-    public ClientHandler(final ConfigurationContext cfgCtx, final HttpParams params,
-        final NhttpMetricsCollector metrics) {
+    public ClientHandler(final ConfigurationContext cfgCtx, final NhttpMetricsCollector metrics) {
         
         super();
         this.cfgCtx = cfgCtx;
-        this.params = params;
         this.httpProcessor = getHttpProcessor();
         this.connStrategy = new DefaultConnectionReuseStrategy();
         this.metrics = metrics;
@@ -228,7 +222,7 @@
 
             HttpContext context = conn.getContext();
             ContentOutputBuffer outputBuffer
-                    = new SharedOutputBuffer(cfg.getBufferSize(), conn, allocator);
+                    = new SharedOutputBuffer(cfg.getBufferSize(), allocator);
             axis2Req.setOutputBuffer(outputBuffer);
             context.setAttribute(REQUEST_SOURCE_BUFFER, outputBuffer);
 
@@ -238,7 +232,6 @@
             context.setAttribute(OUTGOING_MESSAGE_CONTEXT, axis2Req.getMsgContext());
 
             HttpRequest request = axis2Req.getRequest();
-            request.setParams(new DefaultedHttpParams(request.getParams(), this.params));
             this.httpProcessor.process(request, context);
             if (axis2Req.getTimeout() > 0) {
                 conn.setSocketTimeout(axis2Req.getTimeout());
@@ -521,10 +514,10 @@
     public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {
         HttpContext context = conn.getContext();
         HttpResponse response = conn.getHttpResponse();
-        ContentInputBuffer inBuf = (ContentInputBuffer) context.getAttribute(RESPONSE_SINK_BUFFER);
+        SharedInputBuffer inBuf = (SharedInputBuffer) context.getAttribute(RESPONSE_SINK_BUFFER);
 
         try {
-            int bytesRead = inBuf.consumeContent(decoder);
+            int bytesRead = inBuf.consumeContent(decoder, conn);
             if (metrics != null && bytesRead > 0) {
                 if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
                     metrics.incrementBytesReceived(getMessageContext(conn), bytesRead);
@@ -598,12 +591,12 @@
     public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {
         HttpContext context = conn.getContext();
 
-        ContentOutputBuffer outBuf
-                = (ContentOutputBuffer) context.getAttribute(REQUEST_SOURCE_BUFFER);
+        SharedOutputBuffer outBuf
+                = (SharedOutputBuffer) context.getAttribute(REQUEST_SOURCE_BUFFER);
         if (outBuf == null) return;
 
         try {
-            int bytesWritten = outBuf.produceContent(encoder);
+            int bytesWritten = outBuf.produceContent(encoder, conn);
             if (metrics != null) {
                 if (bytesWritten > 0) {
                     if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
@@ -711,7 +704,7 @@
 
                 // sometimes, some http clients sends an "\r\n" as the content body with a
                 // HTTP 202 OK.. we will just get it into this temp buffer and ignore it..
-                ContentInputBuffer inputBuffer = new SharedInputBuffer(8, conn, allocator);
+                ContentInputBuffer inputBuffer = new SharedInputBuffer(8, allocator);
                 context.setAttribute(RESPONSE_SINK_BUFFER, inputBuffer);
 
                 // create a dummy message with an empty SOAP envelope and a property
@@ -954,8 +947,7 @@
         }
 
         if (expectEntityBody) {
-            inputBuffer
-                = new SharedInputBuffer(cfg.getBufferSize(), conn, allocator);
+            inputBuffer = new SharedInputBuffer(cfg.getBufferSize(), allocator);
             context.setAttribute(RESPONSE_SINK_BUFFER, inputBuffer);
 
             BasicHttpEntity entity = new BasicHttpEntity();
@@ -1116,13 +1108,11 @@
      * @return the HttpProcessor that processes requests
      */
     private HttpProcessor getHttpProcessor() {
-        BasicHttpProcessor httpProcessor = new BasicHttpProcessor();
-        httpProcessor.addInterceptor(new RequestContent());
-        httpProcessor.addInterceptor(new RequestTargetHost());
-        httpProcessor.addInterceptor(new RequestConnControl());
-        httpProcessor.addInterceptor(new RequestUserAgent());
-        httpProcessor.addInterceptor(new RequestExpectContinue());
-        return httpProcessor;
+        return new ImmutableHttpProcessor(new RequestContent(),
+                new RequestTargetHost(),
+                new RequestConnControl(),
+                new RequestUserAgent(),
+                new RequestExpectContinue(false));
     }
 
     public int getActiveCount() {
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLSender.java	(revision 1512866)
@@ -21,16 +21,17 @@
 
 import org.apache.commons.logging.LogFactory;
 import org.apache.commons.logging.Log;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.nio.NHttpClientEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.description.Parameter;
 import org.apache.axis2.description.TransportOutDescription;
 import org.apache.axis2.transport.base.ParamUtils;
 import org.apache.axiom.om.OMElement;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 import org.apache.synapse.transport.utils.sslcert.CertificateVerificationConfig;
 import org.apache.synapse.transport.utils.sslcert.CertificateVerificationException;
 import org.apache.synapse.transport.utils.sslcert.adaptor.SynapseAdaptorForOcspCrl;
@@ -54,11 +55,10 @@
     private static final SynapseAdaptorForOcspCrl ocspCrl = new SynapseAdaptorForOcspCrl();
 
     protected IOEventDispatch getEventDispatch(NHttpClientEventHandler handler, SSLContext sslContext,
-        SSLSetupHandler sslIOSessionHandler, HttpParams params,
+        SSLSetupHandler sslSetupHandler, ConnectionConfig config,
         TransportOutDescription transportOut) throws AxisFault {
-
-        return new SSLClientIOEventDispatch(handler, sslContext,
-                getCustomSSLContexts(transportOut), sslIOSessionHandler, params);
+        return LoggingUtils.getClientIODispatch(handler, config, sslContext,
+                sslSetupHandler, getCustomSSLContexts(transportOut));
     }
 
     /**
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLListener.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSSLListener.java	(revision 1512866)
@@ -41,11 +41,12 @@
 import org.apache.axis2.description.TransportInDescription;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.http.config.ConnectionConfig;
 import org.apache.http.nio.NHttpServerEventHandler;
 import org.apache.http.nio.reactor.IOEventDispatch;
 import org.apache.http.nio.reactor.IOSession;
 import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
-import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.utils.logging.LoggingUtils;
 
 public class HttpCoreNIOSSLListener extends HttpCoreNIOListener {
 
@@ -53,14 +54,10 @@
 
     protected IOEventDispatch getEventDispatch(
         NHttpServerEventHandler handler, SSLContext sslContext,
-        SSLSetupHandler sslIOSessionHandler, HttpParams params) {
-        return new SSLServerIOEventDispatch(handler, sslContext, sslIOSessionHandler, params);
+        SSLSetupHandler sslSetupHandler, ConnectionConfig config) {
+        return LoggingUtils.getServerIODispatch(handler, config, sslContext, sslSetupHandler);
     }
 
-    /**
-     * Return the EPR prefix for services made available over this transport
-     * @return
-     */
     protected String getServiceEPRPrefix(ConfigurationContext cfgCtx, String host, int port) {
         return "https://" + host + (port == 443 ? "" : ":" + port) +
             (!cfgCtx.getServiceContextPath().startsWith("/") ? "/" : "") +
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/RESTUtil.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/RESTUtil.java	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/util/RESTUtil.java	(revision 1512866)
@@ -285,7 +285,7 @@
             RequestURIBasedDispatcher requestDispatcher = new RequestURIBasedDispatcher();
             AxisService axisService = requestDispatcher.findService(msgContext);
             if (axisService == null) {
-                String defaultSvcName = NHttpConfiguration.getInstance().getStringValue(
+                String defaultSvcName = NHttpConfiguration.getInstance().getStringProperty(
                         "nhttp.default.service", "__SynapseService");
                 axisService = msgContext.getConfigurationContext()
                         .getAxisConfiguration().getService(defaultSvcName);
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpConfigConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpConfigConstants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/config/HttpConfigConstants.java	(revision 1512866)
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.config;
+
+public class HttpConfigConstants {
+
+    public static final String CONNECTION_TIMEOUT = "http.connection.timeout";
+    public static final String INTEREST_OPS_QUEUEING = "http.nio.interest-ops-queueing";
+    public static final String TCP_NODELAY = "http.tcp.nodelay";
+    public static final String SOCKET_BUFFER_SIZE = "http.socket.buffer-size";
+    public static final String SOCKET_RCV_BUFFER_SIZE = "http.socket.rcv-buffer-size";
+    public static final String SOCKET_SND_BUFFER_SIZE = "http.socket.snd-buffer-size";
+    public static final String SO_LINGER = "http.socket.linger";
+    public static final String SO_REUSEADDR = "http.socket.reuseaddr";
+    public static final String SO_TIMEOUT = "http.socket.timeout";
+    public static final String SELECT_INTERVAL = "http.nio.select-interval";
+
+    public static final String HTTP_MALFORMED_INPUT_ACTION = "http.malformed.input.action";
+    public static final String HTTP_UNMAPPABLE_INPUT_ACTION = "http.unmappable.input.action";
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnectionFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnectionFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnectionFactory.java	(revision 1512866)
@@ -0,0 +1,152 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.config.MessageConstraints;
+import org.apache.http.impl.ConnSupport;
+import org.apache.http.impl.entity.StrictContentLengthStrategy;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.impl.nio.codecs.DefaultHttpRequestWriter;
+import org.apache.http.impl.nio.codecs.DefaultHttpResponseParser;
+import org.apache.http.nio.*;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionInputBuffer;
+import org.apache.http.nio.reactor.SessionOutputBuffer;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+
+import java.io.IOException;
+
+public class LoggingNHttpClientConnectionFactory implements NHttpConnectionFactory<DefaultNHttpClientConnection> {
+
+    private static final Log targetConnLog = LogFactory.getLog(
+            LoggingConstants.TARGET_CONNECTION_LOG_ID);
+    private static final Log targetHeaderLog = LogFactory.getLog(
+            LoggingConstants.TARGET_HEADER_LOG_ID);
+    private static final Log targetSessionLog = LogFactory.getLog(
+            LoggingConstants.TARGET_SESSION_LOG_ID);
+    private static final Log targetWireLog = LogFactory.getLog(
+            LoggingConstants.TARGET_WIRE_LOG_ID);
+
+    private static final NHttpMessageWriterFactory<HttpRequest> requestWriterFactory =
+            new LoggingNHttpRequestWriterFactory();
+    private static final NHttpMessageParserFactory<HttpResponse> responseParserFactory =
+            new LoggingNHttpResponseParserFactory();
+
+    private final ConnectionConfig config;
+
+    public LoggingNHttpClientConnectionFactory(ConnectionConfig config) {
+        this.config = config;
+    }
+
+    public DefaultNHttpClientConnection createConnection(IOSession session) {
+        if (targetSessionLog.isDebugEnabled() || targetWireLog.isDebugEnabled()) {
+            session = new LoggingIOSession(targetSessionLog, targetWireLog,
+                    session, "http-sender");
+        }
+
+        if (targetConnLog.isDebugEnabled() || targetHeaderLog.isDebugEnabled()) {
+            return new LoggingNHttpClientConnection(
+                    session,
+                    config.getBufferSize(),
+                    config.getFragmentSizeHint(),
+                    HeapByteBufferAllocator.INSTANCE,
+                    ConnSupport.createDecoder(config),
+                    ConnSupport.createEncoder(config),
+                    config.getMessageConstraints(),
+                    StrictContentLengthStrategy.INSTANCE,
+                    StrictContentLengthStrategy.INSTANCE,
+                    requestWriterFactory,
+                    responseParserFactory,
+                    targetConnLog);
+        } else {
+            return new DefaultNHttpClientConnection(
+                    session,
+                    config.getBufferSize(),
+                    config.getFragmentSizeHint(),
+                    HeapByteBufferAllocator.INSTANCE,
+                    ConnSupport.createDecoder(config),
+                    ConnSupport.createEncoder(config),
+                    config.getMessageConstraints(),
+                    StrictContentLengthStrategy.INSTANCE,
+                    StrictContentLengthStrategy.INSTANCE,
+                    requestWriterFactory,
+                    responseParserFactory);
+        }
+    }
+
+    static class LoggingNHttpRequestWriterFactory implements NHttpMessageWriterFactory<HttpRequest> {
+        public NHttpMessageWriter<HttpRequest> create(SessionOutputBuffer sessionBuffer) {
+            return new LoggingNHttpRequestWriter(sessionBuffer);
+        }
+    }
+
+    static class LoggingNHttpResponseParserFactory implements NHttpMessageParserFactory<HttpResponse> {
+        public NHttpMessageParser<HttpResponse> create(SessionInputBuffer sessionBuffer,
+                                                      MessageConstraints messageConstraints) {
+            return new LoggingNHttpResponseParser(sessionBuffer, messageConstraints);
+        }
+    }
+
+    static class LoggingNHttpRequestWriter extends DefaultHttpRequestWriter {
+
+        public LoggingNHttpRequestWriter(SessionOutputBuffer buffer) {
+            super(buffer);
+        }
+
+        public void write(final HttpRequest request) throws IOException, HttpException {
+            if (request != null && targetHeaderLog.isDebugEnabled()) {
+                targetHeaderLog.debug(">> " + request.getRequestLine().toString());
+                Header[] headers = request.getAllHeaders();
+                for (Header header : headers) {
+                    targetHeaderLog.debug(">> " + header.toString());
+                }
+            }
+            super.write(request);
+        }
+
+    }
+
+    static class LoggingNHttpResponseParser extends DefaultHttpResponseParser {
+
+        public LoggingNHttpResponseParser(SessionInputBuffer buffer, MessageConstraints constraints) {
+            super(buffer, constraints);
+        }
+
+        public HttpResponse parse() throws IOException, HttpException {
+            HttpResponse response = super.parse();
+            if (response != null && targetHeaderLog.isDebugEnabled()) {
+                targetHeaderLog.debug("<< " + response.getStatusLine().toString());
+                Header[] headers = response.getAllHeaders();
+                for (Header header : headers) {
+                    targetHeaderLog.debug("<< " + header.toString());
+                }
+            }
+            return response;
+        }
+
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingServerEventHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingServerEventHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingServerEventHandler.java	(revision 1512866)
@@ -0,0 +1,117 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.nio.NHttpServerEventHandler;
+
+import java.io.IOException;
+
+public class LoggingServerEventHandler implements NHttpServerEventHandler {
+
+    private final Log log;
+
+    private final NHttpServerEventHandler handler;
+
+    public LoggingServerEventHandler(final NHttpServerEventHandler handler) {
+        super();
+        if (handler == null) {
+            throw new IllegalArgumentException("HTTP service handler may not be null");
+        }
+        this.handler = handler;
+        this.log = LogFactory.getLog(handler.getClass());
+    }
+
+    public void connected(final NHttpServerConnection conn) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Connected");
+        }
+        this.handler.connected(conn);
+    }
+
+    public void closed(final NHttpServerConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed");
+        }
+        this.handler.closed(conn);
+    }
+
+    public void endOfInput(NHttpServerConnection conn) throws IOException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed at the remote end");
+        }
+        this.handler.endOfInput(conn);
+    }
+
+    public void exception(NHttpServerConnection conn, Exception ex) {
+        // No need to log errors at this level - Actual handler implementation
+        // should take care of that
+        this.handler.exception(conn, ex);
+    }
+
+    public void requestReceived(final NHttpServerConnection conn) throws IOException, HttpException {
+        HttpRequest request = conn.getHttpRequest();
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP InRequest Received on connection " + conn + ": "
+                    + request.getRequestLine());
+        }
+        this.handler.requestReceived(conn);
+    }
+
+    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Output ready");
+        }
+        this.handler.outputReady(conn, encoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
+        }
+    }
+
+    public void responseReady(final NHttpServerConnection conn) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Response ready");
+        }
+        this.handler.responseReady(conn);
+    }
+
+    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Input ready");
+        }
+        this.handler.inputReady(conn, decoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
+        }
+    }
+
+    public void timeout(final NHttpServerConnection conn) throws IOException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Timeout");
+        }
+        this.handler.timeout(conn);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnection.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpClientConnection.java	(revision 1512866)
@@ -0,0 +1,92 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.config.MessageConstraints;
+import org.apache.http.entity.ContentLengthStrategy;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.nio.NHttpClientEventHandler;
+import org.apache.http.nio.NHttpMessageParserFactory;
+import org.apache.http.nio.NHttpMessageWriterFactory;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.util.ByteBufferAllocator;
+
+import java.io.IOException;
+import java.nio.charset.CharsetDecoder;
+import java.nio.charset.CharsetEncoder;
+
+public class LoggingNHttpClientConnection extends DefaultNHttpClientConnection {
+
+    private final Log log;
+
+    public LoggingNHttpClientConnection(IOSession session,
+                                        int bufferSize,
+                                        int fragmentSizeHint,
+                                        ByteBufferAllocator allocator,
+                                        CharsetDecoder charDecoder,
+                                        CharsetEncoder charEncoder,
+                                        MessageConstraints constraints,
+                                        ContentLengthStrategy incomingContentStrategy,
+                                        ContentLengthStrategy outgoingContentStrategy,
+                                        NHttpMessageWriterFactory<HttpRequest> requestWriterFactory,
+                                        NHttpMessageParserFactory<HttpResponse> responseParserFactory,
+                                        Log log) {
+        super(session, bufferSize, fragmentSizeHint, allocator,
+                charDecoder, charEncoder, constraints, incomingContentStrategy,
+                outgoingContentStrategy, requestWriterFactory, responseParserFactory);
+        this.log = log;
+    }
+
+    @Override
+    public void close() throws IOException {
+        this.log.debug("Close connection");
+        super.close();
+    }
+
+    @Override
+    public void shutdown() throws IOException {
+        this.log.debug("Shutdown connection");
+        super.shutdown();
+    }
+
+    @Override
+    public void submitRequest(final HttpRequest request) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + this + ": "  + request.getRequestLine().toString());
+        }
+        super.submitRequest(request);
+    }
+
+    @Override
+    public void consumeInput(final NHttpClientEventHandler handler) {
+        this.log.debug("Consume input");
+        super.consumeInput(handler);
+    }
+
+    @Override
+    public void produceOutput(final NHttpClientEventHandler handler) {
+        this.log.debug("Produce output");
+        super.produceOutput(handler);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLServerConnectionFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLServerConnectionFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/utils/logging/LoggingNHttpSSLServerConnectionFactory.java	(revision 1512866)
@@ -0,0 +1,53 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.logging;
+
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.impl.nio.DefaultNHttpServerConnection;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.ssl.SSLIOSession;
+import org.apache.http.nio.reactor.ssl.SSLMode;
+import org.apache.http.nio.reactor.ssl.SSLSetupHandler;
+
+import javax.net.ssl.SSLContext;
+
+public class LoggingNHttpSSLServerConnectionFactory extends LoggingNHttpServerConnectionFactory {
+
+    private SSLContext sslContext;
+    private SSLSetupHandler sslSetupHandler;
+
+    public LoggingNHttpSSLServerConnectionFactory(ConnectionConfig config, SSLContext sslContext,
+                                                  SSLSetupHandler sslSetupHandler) {
+        super(config);
+        this.sslContext = sslContext;
+        this.sslSetupHandler = sslSetupHandler;
+    }
+
+    @Override
+    public DefaultNHttpServerConnection createConnection(IOSession session) {
+        final SSLIOSession ssliosession = new SSLIOSession(
+                session,
+                SSLMode.SERVER,
+                sslContext,
+                sslSetupHandler);
+        session.setAttribute(SSLIOSession.SESSION_KEY, ssliosession);
+        return super.createConnection(ssliosession);
+    }
+}
Index: java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/config/HttpTransportConfigurationTest.java
===================================================================
--- java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/config/HttpTransportConfigurationTest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/test/java/org/apache/synapse/transport/utils/config/HttpTransportConfigurationTest.java	(revision 1512866)
@@ -0,0 +1,83 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.utils.config;
+
+import junit.framework.TestCase;
+import org.apache.http.config.ConnectionConfig;
+import org.apache.http.impl.nio.reactor.IOReactorConfig;
+
+import java.nio.charset.CodingErrorAction;
+
+public class HttpTransportConfigurationTest extends TestCase {
+
+    public void testDefaults() {
+        HttpTransportConfiguration config = new SimpleHttpTransportConfiguration("bogus");
+        assertEquals(10, (int) config.getIntProperty("foo", 10));
+        assertEquals("barValue", config.getStringProperty("bar", "barValue"));
+        assertEquals(true, (boolean) config.getBooleanProperty("baz", true));
+
+        IOReactorConfig reactorConfig = config.getReactorConfig();
+        assertEquals(2, reactorConfig.getIoThreadCount());
+        assertEquals(0, reactorConfig.getConnectTimeout());
+        assertEquals(1024 * 8, reactorConfig.getRcvBufSize());
+        assertEquals(1024 * 8, reactorConfig.getSndBufSize());
+        assertEquals(60000, reactorConfig.getSoTimeout());
+        assertEquals(true, reactorConfig.isTcpNoDelay());
+        assertEquals(false, reactorConfig.isInterestOpQueued());
+
+        ConnectionConfig connConfig = config.getConnectionConfig();
+        assertEquals(1024 * 8, connConfig.getBufferSize());
+        assertEquals(CodingErrorAction.REPORT, connConfig.getMalformedInputAction());
+        assertEquals(CodingErrorAction.REPORT, connConfig.getUnmappableInputAction());
+    }
+
+    public void testNHttp() {
+        HttpTransportConfiguration config = new SimpleHttpTransportConfiguration("nhttp");
+        assertEquals(1000, (int) config.getIntProperty("test.foo", -1));
+        assertEquals("Testing", config.getStringProperty("test.bar", "NotTesting"));
+        assertEquals(true, (boolean) config.getBooleanProperty("test.baz", false));
+
+        IOReactorConfig reactorConfig = config.getReactorConfig();
+        assertEquals(true, reactorConfig.isSoReuseAddress());
+        assertEquals(2, reactorConfig.getIoThreadCount());
+        assertEquals(0, reactorConfig.getConnectTimeout());
+        assertEquals(1024 * 8, reactorConfig.getRcvBufSize());
+        assertEquals(1024 * 8, reactorConfig.getSndBufSize());
+        assertEquals(60000, reactorConfig.getSoTimeout());
+        assertEquals(true, reactorConfig.isTcpNoDelay());
+        assertEquals(false, reactorConfig.isInterestOpQueued());
+
+        ConnectionConfig connConfig = config.getConnectionConfig();
+        assertEquals(1024 * 8, connConfig.getBufferSize());
+        assertEquals(CodingErrorAction.REPORT, connConfig.getMalformedInputAction());
+        assertEquals(CodingErrorAction.REPORT, connConfig.getUnmappableInputAction());
+    }
+
+    class SimpleHttpTransportConfiguration extends HttpTransportConfiguration {
+        public SimpleHttpTransportConfiguration(String fileName) {
+            super(fileName);
+        }
+
+        @Override
+        protected int getThreadsPerReactor() {
+            return 2;
+        }
+    }
+}
Index: java/modules/integration/src/test/resources/passthru-http.properties
===================================================================
--- java/modules/integration/src/test/resources/passthru-http.properties	(revision 1512865)
+++ java/modules/integration/src/test/resources/passthru-http.properties	(revision 1512866)
@@ -1,6 +1,6 @@
 http.socket.timeout=60000
 http.connection.timeout=0
-http.socket.buffer-size=8096
+http.socket.buffer-size=8192
 http.tcp.nodelay=true
 http.nio.interest-ops-queueing=false
 
Index: java/modules/transports/core/nhttp/src/test/resources/nhttp.properties
===================================================================
--- java/modules/transports/core/nhttp/src/test/resources/nhttp.properties	(revision 1512865)
+++ java/modules/transports/core/nhttp/src/test/resources/nhttp.properties	(revision 1512866)
@@ -1,8 +1,13 @@
 http.socket.timeout=60000
 http.connection.timeout=0
-http.socket.buffer-size=8096
-http.tcp.nodelay=1
+http.socket.buffer-size=8192
+http.tcp.nodelay=true
 http.nio.interest-ops-queueing=false
 
 # This property is crucial for automated tests
-http.socket.reuseaddr=true
\ No newline at end of file
+http.socket.reuseaddr=true
+
+# Used by HttpTransportConfiguration tests
+test.foo=1000
+test.bar=Testing
+test.baz=true
\ No newline at end of file
Index: java/pom.xml
===================================================================
--- java/pom.xml	(revision 1512865)
+++ java/pom.xml	(revision 1512866)
@@ -1121,7 +1121,7 @@
         <truezip.version>6.6</truezip.version>
         <jsch.version>0.1.31</jsch.version>
         <jms-1.1-spec.version>1.1</jms-1.1-spec.version>
-        <httpcore.nio.version>4.2.4</httpcore.nio.version>
+        <httpcore.nio.version>4.3</httpcore.nio.version>
         <http.client.version>4.1</http.client.version>
         <aspectj.version>1.6.1</aspectj.version>
         <qfj.version>1.4.0</qfj.version>
-*-*-*-
Message: 1. Upgrading to HTTP Core 4.3 (Migrated both NHTTP and PTT transports out of deprecated APIs)
2. Unified the logging mechanism used by NHTTP and PTT transports
3. Improved the HTTP transport logging mechanism, to make the configuration more fine grained
4. Unified the configuration mechanism used by NHTTP and PTT transports


-*-*-*-
When: 2013-08-10 23:22:44 -0400 
-*-*-*-
Who: hiranya
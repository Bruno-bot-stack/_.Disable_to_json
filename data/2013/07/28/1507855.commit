Index: java/modules/documentation/src/site/xdoc/userguide/transports.xml
===================================================================
--- java/modules/documentation/src/site/xdoc/userguide/transports.xml	(revision 1507854)
+++ java/modules/documentation/src/site/xdoc/userguide/transports.xml	(revision 1507855)
@@ -49,6 +49,11 @@
                     exchanges, industry utilities and associations, institutional investors, and IT
                     providers around the world.
 				</li>
+                <li>
+                    A AMQP transport which support the AMQP protocol.
+                    <a class="externalLink" href="http://www.amqp.org/">AMQP</a>  is a messaging
+                    protocol.
+                </li>
 			</ul>
 			<p>Note that while these transports are developed as part of the Synapse project,
                 they can be used with any Axis2 based application.
@@ -141,6 +146,20 @@
 						</li>
 					</ul>
 				</li>
+                <li>
+                    <a href="#amqp_transport">AMQP transport</a>
+                    <ul>
+                        <li>
+                            <a href="#setting_up_the_amqp_transport">Setting up the AMQP Transport</a>
+                        </li>
+                        <li>
+                            <a href="#amqp_transport_parameters">AMQP Transport Parameters</a>
+                        </li>
+                        <li>
+                            <a href="#amqp_transport_ex">Sample Configurations</a>
+                        </li>
+                    </ul>
+                </li>
 			</ul>
 		</section>
 	    <section name="Non-blocking HTTP transport" id="Non-blocking_HTTP_transport">
@@ -815,6 +834,355 @@
 				</dl>
 			</subsection>
 		</section>
+        <section name="AMQP transport" id="amqp_transport">
+            <subsection name="Setting Up the Transport" id="setting_up_the_amqp_transport">
+                <p>
+                    AMQP transport is based on the excellent
+                    <a href="http://www.rabbitmq.com/java-client.html">Java AMQP client</a> library from
+                    <a class="externalLink" href="http://www.rabbitmq.com/">RabbitMQ</a>.
+                    Due to the license, the client library doesn't ship with Apache Synapse. In order to use
+                    the AMQP transport download the RabbitMQ Java client library and copy
+                    the client library(rabbitmq-client.jar) into Synapse classpath(lib folder).
+                </p>
+                <p>
+                    To enable the AMQP transport, uncomment the AMQP transport sender and AMQP transport
+                    receiver configurations in the SYNAPSE_HOME/repository/conf/axis2.xml.
+                </p>
+            </subsection>
+            <subsection name="AMQP Transport Parameters" id="amqp_transport_parameters">
+                <p>
+                    Following parameters can be configured as part of transport receiver, sender or
+                    as part of the proxy service parameter or amqp endpoint deceleration.
+                </p>
+                <dl>
+                    <dt>
+                        <tt>transport.amqp.Uri</tt>
+                    </dt>
+                    <dd>The connection URL for the broker of the form
+                        amqp://userName:password@hostName:portNumber/virtualHost</dd>
+                    <dt>
+                        <tt>transport.amqp.BrokerList</tt>
+                    </dt>
+                    <dd>The list of broker of the form, host1:port1,host2:port2... which will be used
+                        as the address array in AMQP connection to the broker</dd>
+                    <dt>
+                        <tt>transport.amqp.ExchangeName</tt>
+                    </dt>
+                    <dd>The name of the exchange to connect</dd>
+                    <dt>
+                        <tt>transport.amqp.IsExchangeDurable</tt>
+                    </dt>
+                    <dd>Should the exchange be declared as durable?</dd>
+                    <dt>
+                        <tt>transport.amqp.IsExchangeAutoDelete</tt>
+                    </dt>
+                    <dd>Should the exchange be auto delete? Possible values are true or false</dd>
+                    <dt>
+                        <tt>transport.amqp.ChannelPreFetchSize</tt>
+                    </dt>
+                    <dd>The channel pre fetch size for fair dispatch</dd>
+                    <dt>
+                        <tt>transport.amqp.ChannelPreFetchCountSize</tt>
+                    </dt>
+                    <dd>The channel prefetch count for fair dispatch</dd>
+                    <dt>
+                        <tt>transport.amqp.ExchangeType</tt>
+                    </dt>
+                    <dd>Type of the exchange to use. Possible values are, fanout, direct, header or topic</dd>
+                    <dt>
+                        <tt>transport.amqp.ExchangeInternal</tt>
+                    </dt>
+                    <dd>Should the exchange be declared as internal? Possible values are true or false </dd>
+                    <dt>
+                        <tt>transport.amqp.BindExchange</tt>
+                    </dt>
+                    <dd>The name of the exchange that the publisher/consumer should publish/consume message to.</dd>
+                    <dt>
+                        <tt>transport.amqp.BindingKeys</tt>
+                    </dt>
+                    <dd>The comma separated binding keys this queue should be bound into exchange</dd>
+                    <dt>
+                        <tt>transport.amqp.RoutingKey</tt>
+                    </dt>
+                    <dd>The routing key to be used by the publisher.</dd>
+                    <dt>
+                        <tt>transport.amqp.ConsumerTx</tt>
+                    </dt>
+                    <dd>Use transactions at consumer side if set to true. By default this will be
+                        considered false and explicit acknowledgement will be done</dd>
+                    <dt>
+                        <tt>transport.amqp.QueueName</tt>
+                    </dt>
+                    <dd>The name of the queue</dd>
+                    <dt>
+                        <tt>transport.amqp.IsQueueDurable</tt>
+                    </dt>
+                    <dd>Should the queue declare as durable? Possible values are true or false.</dd>
+                    <dt>
+                        <tt>transport.amqp.IsQueueRestricted</tt>
+                    </dt>
+                    <dd>Should the queue declare as restricted? Possible values are true or false.</dd>
+                    <dt>
+                        <tt>transport.amqp.IsQueueAutoDelete</tt>
+                    </dt>
+                    <dd>Should the queue declare as auto delete when it's no longer in use?.
+                    Possible values are true or false.</dd>
+                    <dt>
+                        <tt>transport.amqp.OperateOnBlockingMode</tt>
+                    </dt>
+                    <dd>True if the polling task should wait until it process  the accepted
+                        messages. This can be used in conjunction with a single thread polling
+                        task(in the whole transport, i.e. only a single AMQP proxy per flow)
+                        to achieve in order delivery</dd>
+                    <dt>
+                        <tt>transport.amqp.InitialReconnectDuration</tt>
+                    </dt>
+                    <dd>If a polling task encounter an exception due to some reason(most probably
+                        due to broker outage) the number of milliseconds it should be suspended
+                        before next re-try</dd>
+                    <dt>
+                        <tt>transport.amqp.ReconnectionProgressionFactor</tt>
+                    </dt>
+                    <dd>If the polling task fails again after the initial re-connection duration,
+                        next suspend duration will be calculated using this.</dd>
+                    <dt>
+                        <tt>transport.amqp.MaximumReconnectionDuration</tt>
+                    </dt>
+                    <dd>The maximum duration to suspend the polling task in case of an error. The
+                        current suspend duration will reach this value by following the series;
+                        transport.amqp.ReconnectionProgressionFactor * transport.amqp.InitialReconnectDuration.
+                        This upper bound is there because nobody wants to wait a long time until the
+                        next re-try if the broker is alive.
+                    </dd>
+                    <dt>
+                        <tt>transport.amqp.ConnectionFactoryName</tt>
+                    </dt>
+                    <dd>The connection factory to be used either with consumer or producer.</dd>
+                    <dt>
+                        <tt>transport.amqp.ResponseConnectionFactoryName</tt>
+                    </dt>
+                    <dd>In a two-way scenario which connection factory of the senders' should be used
+                        to send the response</dd>
+                    <dt>
+                        <tt>transport.amqp.ScheduledTaskInitialDelay</tt>
+                    </dt>
+                    <dd>The initial delay(in milliseconds) that the polling task should delay before initial attempt</dd>
+                    <dt>
+                        <tt>transport.amqp.ScheduledTaskDelay</tt>
+                    </dt>
+                    <dd>The delay(in milliseconds) that the polling task should delay before next attempt.</dd>
+                    <dt>
+                        <tt>transport.amqp.ScheduledTaskTimeUnit</tt>
+                    </dt>
+                    <dd>The time unit which should use to calculate,
+                        transport.amqp.ScheduledTaskInitialDelay and transport.amqp.ScheduledTaskDelay.</dd>
+                    <dt>
+                    <tt>transport.amqp.NoOfConcurrentConsumers</tt>
+                    </dt>
+                    <dd>Number of concurrent consumers per polling task.</dd>
+                    <dt>
+                        <tt>transport.amqp.NoOfDispatchingTask</tt>
+                    </dt>
+                    <dd>Number of dispatching task to use any request messages to actual processing task.</dd>
+                    <dt>
+                        <tt>transport.amqp.ContentType</tt>
+                    </dt>
+                    <dd>Configure the content type as a service parameter.</dd>
+                    <dt>
+                        <tt>AMQP_CONTENT_TYPE</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP message content type.</dd>
+                    <dt>
+                        <tt>AMQP_CONTENT_ENCODING</tt>
+                    </dt>
+                    <dd> Message context property to set the AMQP message encoding</dd>
+                    <dt>
+                        <tt>AMQP_HEADER_*</tt>
+                    </dt>
+                    <dd>Specify any AMQP headers as message context properties using AMQP_HEADER_*</dd>
+                    <dt>
+                        <tt>AMQP_DELIVERY_MODE</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP message delivery mode</dd>
+                    <dt>
+                        <tt>AMQP_PRIORITY</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP message priority.</dd>
+                    <dt>
+                        <tt>AMQP_CORRELATION_ID</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP message correlation id</dd>
+                    <dt>
+                        <tt>AMQP_REPLY_TO</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP message reply to header.</dd>
+                    <dt>
+                        <tt>AMQP_EXPIRATION</tt>
+                    </dt>
+                    <dd>Message context property to set the AMQP expiration.</dd>
+                    <dt>
+                        <tt>AMQP_MESSAGE_ID</tt>
+                    </dt>
+                    <dd>Message context property to set the message id of the AMQP message</dd>
+                    <dt>
+                        <tt>AMQP_TIME_STAMP</tt>
+                    </dt>
+                    <dd>Message context property to set the timestamp of the AMQP message.</dd>
+                    <dt>
+                        <tt>AMQP_TYPE</tt>
+                    </dt>
+                    <dd>Message context property to set the type of the AMQP message</dd>
+                    <dt>
+                        <tt>connection-factory-pool-size</tt>
+                    </dt>
+                    <dd>A system property to set the worker pool size of the connection factory executor service.</dd>
+                    <dt>
+                        <tt>worker-pool-size</tt>
+                    </dt>
+                    <dd>A system property to set the worker pool size used by deployed services for polling broker.</dd>
+                    <dt>
+                        <tt>semaphore-time-out</tt>
+                    </dt>
+                    <dd>A system property to set the time out(in seconds) of semaphore which waits for
+                    a response.</dd>
+                    <dt>
+                        <tt>AMQP_PRODUCER_TX</tt>
+                    </dt>
+                    <dd>Use transactions at producer side. Possible values are tx(for blocking transactions),
+                        lwpc(for light weight producer connections).</dd>
+                </dl>
+            </subsection>
+            <subsection name="Sample Configurations" id="amqp_transport_ex">
+                    <p>Producer example</p>
+                    <div class="xmlConf">
+&lt;proxy name="ProducerProxy" transports="http"&gt;
+    &lt;target&gt;
+        &lt;inSequence&gt;
+            &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+            &lt;property name="PRESERVE_WS_ADDRESSING" value="true"/&gt;"
+            &lt;log level="custom"&gt;
+                &lt;property name="status" value="At ProducerProxy"/&gt;
+            &lt;/log&gt;
+        &lt;/inSequence&gt;
+        &lt;endpoint&gt;
+            &lt;!--use the defined connection factory in AMQP transport sender--&gt;
+            &lt;address
+                uri="amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=ProducerProxy"/&gt;
+        &lt;/endpoint&gt;
+        &lt;outSequence&gt;
+            &lt;send/&gt;
+        &lt;/outSequence&gt;
+    &lt;/target&gt;
+&lt;/proxy&gt;
+                    </div>
+                    <p>Consumer example</p>
+                    <div class="xmlConf">
+&lt;proxy name="ConsumerProxy" transports="amqp"&gt;
+    &lt;target&gt;
+        &lt;inSequence&gt;
+            &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+            &lt;log level="custom"&gt;
+                &lt;property name="status" value="At ConsumerProxy"/&gt;
+            &lt;/log&gt;
+        &lt;/inSequence&gt;
+        &lt;endpoint&gt;
+            &lt;address uri="http://localhost:9000/services/SimpleStockQuoteService"/&gt;
+        &lt;/endpoint&gt;
+        &lt;outSequence&gt;
+            &lt;send/&gt;
+        &lt;/outSequence&gt;
+    &lt;/target&gt;
+    &lt;parameter name="transport.amqp.ConnectionFactoryName"&gt;consumer&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.QueueName"&gt;ProducerProxy&lt;/parameter&gt;
+&lt;/proxy&gt;
+                    </div>
+                    <p>Routing example</p>
+                    <div class="xmlConf">
+&lt;proxy name="DirectPublisherProxy" transports="http"&gt;
+    &lt;target&gt;
+    &lt;inSequence&gt;
+        &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+        &lt;log level="custom"&gt;
+            &lt;property name="status" value="At DirectPublisherProxy"/&gt;
+        &lt;/log&gt;
+    &lt;/inSequence&gt;
+    &lt;endpoint&gt;
+        &lt;!--use the defined connection factory in AMQP transport sender, note how we don't provide
+            any queue name because this is bind to the exchange--&gt;
+        &lt;address
+            uri="amqp://?transport.amqp.ConnectionFactoryName=publisher&amp;transport.amqp.ExchangeName=direct_logs&amp;transport.amqp.ExchangeType=direct&amp;transport.amqp.RoutingKey=error"/&gt;
+    &lt;/endpoint&gt;
+    &lt;outSequence&gt;
+        &lt;send/&gt;
+    &lt;/outSequence&gt;
+    &lt;/target&gt;
+&lt;/proxy&gt;
 
+&lt;proxy name="DirectSubscriberProxy1" transports="amqp"&gt;
+    &lt;target&gt;
+        &lt;inSequence&gt;
+            &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+            &lt;log level="custom"&gt;
+                &lt;property name="status" value="At DirectSubscriberProxy 1"/&gt;
+            &lt;/log&gt;
+        &lt;/inSequence&gt;
+        &lt;endpoint&gt;
+            &lt;address uri="http://localhost:9000/services/SimpleStockQuoteService"/&gt;
+        &lt;/endpoint&gt;
+        &lt;outSequence&gt;
+            &lt;send/&gt;
+        &lt;/outSequence&gt;
+    &lt;/target&gt;
+    &lt;parameter name="transport.amqp.ConnectionFactoryName"&gt;subscriber&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.ExchangeName"&gt;direct_logs&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.ExchangeType"&gt;direct&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.BindingKeys"&gt;warning,error&lt;/parameter&gt;
+&lt;/proxy&gt;
+
+&lt;proxy name="DirectSubscriberProxy2" transports="amqp"&gt;
+    &lt;target&gt;
+        &lt;inSequence&gt;
+            &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+            &lt;log level="custom"&gt;
+                &lt;property name="status" value="At DirectSubscriberProxy 2"/&gt;
+            &lt;/log&gt;
+        &lt;/inSequence&gt;
+        &lt;endpoint&gt;
+            &lt;address uri="http://localhost:9000/services/SimpleStockQuoteService"/&gt;
+        &lt;/endpoint&gt;
+        &lt;outSequence&gt;
+            &lt;send/&gt;
+        &lt;/outSequence&gt;
+    &lt;/target&gt;
+    &lt;parameter name="transport.amqp.ConnectionFactoryName"&gt;subscriber&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.ExchangeName"&gt;direct_logs&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.ExchangeType"&gt;direct&lt;/parameter&gt;
+    &lt;parameter name="transport.amqp.BindingKeys"&gt;error&lt;/parameter&gt;
+&lt;/proxy&gt;
+                    </div>
+                    <p>Producer transactions</p>
+                    <div class="xmlConf">
+&lt;proxy name="ProducerTxProxy1" transports="http"&gt;
+    &lt;target&gt;
+        &lt;inSequence&gt;
+            &lt;property action="set" name="OUT_ONLY" value="true"/&gt;
+            &lt;property action="set" name="AMQP_PRODUCER_TX" scope="axis2" value="lwpc"/&gt;
+            &lt;log level="custom"&gt;
+                &lt;property name="status" value="At ProducerTxProxy1, use light weight producer confirm..."/&gt;
+            &lt;/log&gt;
+        &lt;/inSequence&gt;
+        &lt;endpoint&gt;
+            &lt;!--use the defined connection factory in AMQP transport sender--&gt;
+            &lt;address
+                uri="amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=ProducerProxy"/&gt;
+        &lt;/endpoint&gt;
+        &lt;outSequence&gt;
+            &lt;send/&gt;
+        &lt;/outSequence&gt;
+    &lt;/target&gt;
+&lt;/proxy&gt;
+                    </div>
+            </subsection>
+        </section>
 	</body>
 </document>
\ No newline at end of file
Index: java/modules/distribution/pom.xml
===================================================================
--- java/modules/distribution/pom.xml	(revision 1507854)
+++ java/modules/distribution/pom.xml	(revision 1507855)
@@ -132,6 +132,10 @@
             <groupId>org.apache.synapse</groupId>
             <artifactId>synapse-vfs-transport</artifactId>
         </dependency>
+        <dependency>
+            <groupId>org.apache.synapse</groupId>
+            <artifactId>synapse-amqp-transport</artifactId>
+        </dependency>
 
         <dependency>
             <groupId>com.oopsconsultancy</groupId>
Index: java/modules/transports/pom.xml
===================================================================
--- java/modules/transports/pom.xml	(revision 1507854)
+++ java/modules/transports/pom.xml	(revision 1507855)
@@ -47,6 +47,7 @@
         <module>core/pipe</module>
         <module>core/vfs</module>
         <module>optional/fix</module>
+		<module>optional/amqp</module>
     </modules>
 
     <dependencies>
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactoryManager.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactoryManager.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactoryManager.java	(revision 1507855)
@@ -0,0 +1,115 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp.connectionfactory;
+
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.ParameterInclude;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.amqp.AMQPTransportException;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Holds a list of {@link AMQPTransportConnectionFactory}.
+ */
+public class AMQPTransportConnectionFactoryManager {
+
+    private static Log log = LogFactory.getLog(AMQPTransportConnectionFactoryManager.class);
+
+    /**
+     * Keeps the list of connection factories defined.
+     */
+    private ConcurrentHashMap<String, AMQPTransportConnectionFactory> factories =
+            new ConcurrentHashMap<String, AMQPTransportConnectionFactory>();
+
+    /**
+     * Add the list of defined connection factories definition.
+     *
+     * @param transportInDescription The connection factory definition in axis2.xml
+     * @param es An instance of java.util.concurrent.ExecutorService to use with AMQP connection
+     *           factory
+     */
+    public void addConnectionFactories(ParameterInclude transportInDescription, ExecutorService es) {
+        for (Parameter p : transportInDescription.getParameters()) {
+            try {
+                addConnectionFactory(p, es);
+            } catch (AMQPTransportException e) {
+                log.error("Error whiling adding the connection factory with name '" + p.getName() +
+                        "'. ", e);
+            }
+        }
+    }
+
+    /**
+     * Add a connection factory definition into store.
+     */
+    public void addConnectionFactory(Parameter parameter, ExecutorService es)
+            throws AMQPTransportException {
+        factories.put(parameter.getName(), new AMQPTransportConnectionFactory(parameter, es));
+    }
+
+    /**
+     * Get the connection factory with this name.
+     *
+     * @param name connection factory name.
+     * @return the connection factory with this name.
+     * @throws AMQPTransportException throws in case of an error.
+     */
+    public AMQPTransportConnectionFactory getConnectionFactory(final String name)
+            throws AMQPTransportException {
+        if (factories.containsKey(name)) {
+            return factories.get(name);
+        }
+        throw new AMQPTransportException("No connection factory found with the name '" + name + "'");
+    }
+
+    /**
+     * Remove and return the connection factory with this name.
+     *
+     * @param name connection factory name.
+     * @throws AMQPTransportException throws in case of an error.
+     */
+    public void removeConnectionFactory(final String name) throws AMQPTransportException {
+        if (factories.containsKey(name)) {
+            try {
+                // shutdown and remove
+                AMQPTransportConnectionFactory factory = factories.remove(name);
+                factory.shutDownChannel();
+                factory.shutDownConnection();
+            } catch (IOException e) {
+                throw new AMQPTransportException("Could not remove the connection '" + name + "'", e);
+            }
+        }
+        throw new AMQPTransportException("No connection factory found with the name '" + name + "'");
+    }
+
+    /**
+     * Shutdown the open connections to the broker via the connection factory
+     */
+    public void shutDownConnectionFactories() throws AMQPTransportException {
+        try {
+            for (Map.Entry<String, AMQPTransportConnectionFactory> entry : factories.entrySet()) {
+                AMQPTransportConnectionFactory connectionFactory = entry.getValue();
+                connectionFactory.shutDownChannel();
+                connectionFactory.shutDownConnection();
+            }
+        } catch (IOException e) {
+            throw new AMQPTransportException("Error occurred whiling shutting down connections", e);
+        }
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactory.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactory.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/connectionfactory/AMQPTransportConnectionFactory.java	(revision 1507855)
@@ -0,0 +1,228 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp.connectionfactory;
+
+import com.rabbitmq.client.Address;
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.ParameterIncludeImpl;
+import org.apache.synapse.transport.amqp.AMQPTransportConstant;
+import org.apache.synapse.transport.amqp.AMQPTransportException;
+import org.apache.synapse.transport.amqp.AMQPTransportUtils;
+
+import java.io.IOException;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * This wrap the connection factory definition in axis2.xml. See below for an example definition.
+ * <pre>
+ * {@code
+ * <transportReceiver name="amqp" class="org.wso2.carbon.transports.amqp.AMQPTransportListener">
+ * <parameter name="example-connection-factory1" locked="false">
+ *      <parameter name="transport.amqp.Uri" locked="false">amqp://userName:password@hostName:portNumber/virtualHost</parameter>
+ *      <parameter name="transport.amqp.BrokerList" locked="false">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>
+ * </parameter>
+ *
+ * <parameter name="example-connection-factory2" locked="false">
+ *     <parameter name="example-connection-factory1" locked="false">
+ *     <parameter name="transport.amqp.Uri" locked="false">amqp://userName:password@hostName:portNumber/virtualHost</parameter>
+ *     <parameter name="transport.amqp.BrokerList" locked="false">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>
+ * </parameter>
+ *
+ * <parameter name="default" locked="false">
+ *     <parameter name="example-connection-factory1" locked="false">
+ *     <parameter name="transport.amqp.Uri" locked="false">amqp://userName:password@hostName:portNumber/virtualHost</parameter>
+ *     <parameter name="transport.amqp.BrokerList" locked="false">hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3</parameter>
+ * </parameter>
+ * </transportReceiver>
+ * }
+ * </pre>
+ */
+public class AMQPTransportConnectionFactory {
+
+    /**
+     * The name of the connection factory definition.
+     */
+    private String name = null;
+
+    /**
+     * The list of parameters(see above) in the connection factory definition.
+     */
+    private Hashtable<String, String> parameters = new Hashtable<String, String>();
+
+    /**
+     * The AMQP connection to the broker maintain per connection factory.
+     */
+    private Connection connection = null;
+
+    /**
+     * The AMQP channel for this connection, maintains per connection.
+     */
+    private Channel channel = null;
+
+
+    public AMQPTransportConnectionFactory(Parameter parameter, ExecutorService es)
+            throws AMQPTransportException {
+        try {
+            this.name = parameter.getName();
+
+            ParameterIncludeImpl pi = new ParameterIncludeImpl();
+
+            if (!(parameter.getValue() instanceof OMElement)) {
+                throw new AMQPTransportException("The connection factory '" + parameter.getName() +
+                        "' is in valid. It's required to have the least connection factory definition with '" +
+                        AMQPTransportConstant.PARAMETER_CONNECTION_URI + "' parameter. Example: \n" +
+                        "\n<transportReceiver name=\"amqp\" class=\"org.wso2.carbon.transports.amqp.AMQPTransportListener\">\n" +
+                        "   <parameter name=\"default\" locked=\"false\">\n" +
+                        "      <parameter name=\"transport.amqp.Uri\" locked=\"false\">amqp://rajika:rajika123@localhost:5672/default</parameter>\n" +
+                        "   </parameter>\n" +
+                        "</transportReceiver>\n");
+            }
+            try {
+                pi.deserializeParameters(parameter.getParameterElement());
+            } catch (AxisFault axisFault) {
+                throw new AMQPTransportException("Error reading connection factory configuration from '" +
+                        parameter.getName() + "'", axisFault);
+            }
+
+            for (Parameter entry : pi.getParameters()) {
+                parameters.put(entry.getName(), (String) entry.getValue());
+            }
+
+            ConnectionFactory connectionFactory = new ConnectionFactory();
+            connectionFactory.setUri(parameters.get(AMQPTransportConstant.PARAMETER_CONNECTION_URI));
+
+            if (parameters.get(AMQPTransportConstant.PARAMETER_BROKER_LIST) != null) {
+                Address[] addresses = AMQPTransportUtils.getAddressArray(
+                        parameters.get(AMQPTransportConstant.PARAMETER_BROKER_LIST), ",", ':');
+                connection = connectionFactory.newConnection(es, addresses);
+            } else {
+                connection = connectionFactory.newConnection(es);
+            }
+
+            if (parameters.get(AMQPTransportConstant.PARAMETER_AMQP_CHANNEL_NUMBER) != null) {
+                int index = 0;
+                try {
+                    index = Integer.parseInt(parameters.get(
+                            AMQPTransportConstant.PARAMETER_AMQP_CHANNEL_NUMBER));
+                } catch (NumberFormatException e) {
+                    index = 1; // assume default,
+                    // fair dispatch see http://www.rabbitmq.com/tutorials/tutorial-two-java.html
+                }
+                channel = connection.createChannel(index);
+
+            } else {
+                channel = connection.createChannel();
+            }
+
+
+            int prefetchSize = 1024;
+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_SIZE) != null) {
+                try {
+                    prefetchSize = Integer.parseInt(
+                            parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_SIZE));
+                } catch (NumberFormatException e) {
+                    prefetchSize = 1024; // assume default
+                }
+            }
+
+            int prefetchCount = 0;
+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_COUNT) != null) {
+                try {
+                    prefetchCount = Integer.parseInt(
+                            parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_PREFETCH_COUNT));
+                    channel.basicQos(prefetchCount);
+                } catch (NumberFormatException e) {
+                    prefetchCount = 0; // assume default
+                }
+            }
+
+            boolean useGlobally = false;
+            if (parameters.get(AMQPTransportConstant.PARAMETER_CHANNEL_QOS_GLOBAL) != null) {
+                useGlobally = Boolean.parseBoolean(parameters.get(
+                        AMQPTransportConstant.PARAMETER_CHANNEL_QOS_GLOBAL));
+            }
+
+
+        } catch (Exception e) {
+            throw new AMQPTransportException("" +
+                    "Could not initialize the connection factory '" + parameter.getName() + "'", e);
+        }
+    }
+
+    /**
+     * Shutdown this connection.
+     *
+     * @throws IOException
+     */
+    public void shutDownConnection() throws IOException {
+        if (connection != null && connection.isOpen()) {
+            connection.close();
+        }
+    }
+
+    /**
+     * Shutdown this channel.
+     *
+     * @throws IOException
+     */
+    public void shutDownChannel() throws IOException {
+        if (channel != null && channel.isOpen()) {
+            channel.close();
+        }
+    }
+
+    /**
+     * Get the channel in this connection.
+     *
+     * @return channel associated with this
+     */
+    public Channel getChannel() {
+        return channel;
+    }
+
+    /**
+     * Return the name of this connection factory(the name given in axis2.xml)
+     *
+     * @return name of this connection factory
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns the value of parameter.
+     *
+     * @param parameterName name of the parameter.
+     * @return the value of the parameter.
+     */
+    public String getParameterValue(final String parameterName) {
+        return parameters.get(parameterName);
+    }
+
+    /**
+     * Returns the list of all parameters in this connection factory.
+     *
+     * @return the list of parameters.
+     */
+    public Map<String, String> getParameters() {
+        return parameters;
+    }
+}
Index: java/modules/transports/optional/amqp/src/test/resources/amqp-transport.properties
===================================================================
--- java/modules/transports/optional/amqp/src/test/resources/amqp-transport.properties	(nonexistent)
+++ java/modules/transports/optional/amqp/src/test/resources/amqp-transport.properties	(revision 1507855)
@@ -0,0 +1,7 @@
+# Do not edit. This is for JUnit tests.
+string=username@domain.com
+int=10
+long=13
+double=14.4
+boolean1=true
+boolean2=false
\ No newline at end of file
Index: java/pom.xml
===================================================================
--- java/pom.xml	(revision 1507854)
+++ java/pom.xml	(revision 1507855)
@@ -392,6 +392,11 @@
                 <artifactId>synapse-vfs-transport</artifactId>
                 <version>${project.version}</version>
             </dependency>
+            <dependency>
+                <groupId>org.apache.synapse</groupId>
+                <artifactId>synapse-amqp-transport</artifactId>
+                <version>${project.version}</version>
+            </dependency>
 
             <!-- Apache Axis2 -->
             <dependency>
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTask.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTask.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTask.java	(revision 1507855)
@@ -0,0 +1,707 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp.pollingtask;
+
+import com.rabbitmq.client.AMQP;
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.QueueingConsumer;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMDocument;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.*;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.builder.Builder;
+import org.apache.axis2.builder.BuilderUtil;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.transport.http.HTTPTransportUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.amqp.*;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The polling task deploy for each services exposed on AMQP transport. This task
+ */
+public class AMQPTransportPollingTask {
+
+    private static Log log = LogFactory.getLog(AMQPTransportPollingTask.class);
+
+    /**
+     * State of the current polling task.
+     */
+    private enum TASK_STATE {
+        STOPPED, STARTED, FAILURE
+
+    }
+
+    /**
+     * The name of the service this polling task belongs to.
+     */
+    private String serviceName;
+
+    /**
+     * The exchange of this polling task belongs to.
+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_NAME}
+     */
+    private String exchangeName = null;
+
+
+    /**
+     * The durability of this exchange. Default non durable(i.e. transient).
+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_IS_DURABLE}
+     */
+    private boolean isExchangeDurable = false;
+
+
+    /**
+     * Should the exchange that will be declared by this polling task should be auto deleted ?
+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_IS_AUTO_DELETE}
+     */
+    private boolean isExchangeAutoDelete = true;
+
+
+    /**
+     * The type of the exchange. Default to direct type.
+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_TYPE}
+     */
+    private String exchangeType = "direct";
+
+    /**
+     * True if this is an internal exchange.
+     * {@link AMQPTransportConstant#PARAMETER_EXCHANGE_INTERNAL}
+     */
+    private boolean isInternalExchange = false;
+
+    /**
+     * The name of the exchange to which the consumer should bind into.
+     * {@link AMQPTransportConstant#PARAMETER_BIND_EXCHANGE} at consumer side.
+     */
+    private String consumerExchangeName = null;
+
+    /**
+     * The list of binding keys at consumer side.
+     * {@link AMQPTransportConstant#PARAMETER_BINDING_KEYS}
+     */
+    private String[] bindingsKeys = null;
+
+    /**
+     * Should this task manager be participated in a tx(not distributed)?, by default this is false
+     * and auto acknowledgment will be used
+     */
+    private boolean isUseTx = false;
+
+
+    /**
+     * The name of the queue this consumer should bind to.{@link AMQPTransportConstant#PARAMETER_QUEUE_NAME}
+     */
+    private String queueName = null;
+
+
+    /**
+     * True if this queue should be durable. {@link AMQPTransportConstant#PARAMETER_QUEUE_DURABLE}
+     */
+    private boolean isQueueDurable = false;
+
+    /**
+     * True if this queue should be restricted.
+     * {@link AMQPTransportConstant#PARAMETER_QUEUE_RESTRICTED}
+     */
+    private boolean isQueueRestricted = false;
+
+    /**
+     * True if this queue should be deleted automatically.
+     * {@link AMQPTransportConstant#PARAMETER_QUEUE_AUTO_DELETE}
+     */
+    private boolean isQueueAutoDelete = true;
+
+    /**
+     * Should this polling task should wait until processed the current message.
+     * {@link AMQPTransportConstant#PARAMETER_OPERATE_ON_BLOCKING_MODE}
+     */
+    private boolean isBlockingMode = false;
+
+
+    /**
+     * Number of concurrent consumers per this polling task.
+     * {@link AMQPTransportConstant#PARAMETER_NO_OF_CONCURRENT_CONSUMERS}
+     */
+    private int noOfConcurrentConsumers = 2;
+
+    /**
+     * Initial duration(in milliseconds) to suspend the polling task in case of an error.
+     * {@link org.apache.synapse.transport.amqp.AMQPTransportConstant#PARAMETER_INITIAL_RE_CONNECTION_DURATION}.
+     */
+    private int initialReconnectDuration = 1000;
+
+    /**
+     * The progression factor for next re-try calculation.
+     * {@link AMQPTransportConstant#PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR}
+     */
+    private double reconnectionFactor = 2.0;
+
+    /**
+     * The maximum duration to suspend the polling task. This is to make sure there is an upper
+     * bound for the suspending the polling task in case of an error.
+     * {@link AMQPTransportConstant#PARAMETER_MAX_RE_CONNECTION_DURATION}
+     */
+    private int maxReconnectionDuration = 1000 * 60 * 10;
+
+    /**
+     * The name of the connectionFactory this service is bound to.
+     * {@link AMQPTransportConstant#PARAMETER_CONNECTION_FACTORY_NAME}
+     */
+    private String connectionFactoryName;
+
+    /**
+     * The name of the connection factory that this service should be using to send
+     * the response in a two way scenario. Default to null
+     * {@link AMQPTransportConstant#PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME}
+     */
+    private String responseConnectionFactory = null;
+
+    /**
+     * The initial delay the scheduled task should wait. Don't wait by default.
+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_INITIAL_DELAY}
+     */
+    private long scheduledTaskInitialDelay = 0;
+
+    /**
+     * The delay that the scheduled task should wait.
+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_DELAY}
+     */
+    private long scheduledTaskDelay = 1;
+
+    /**
+     * The time unit for scheduled task delay.
+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_TIME_UNIT}.
+     */
+    private TimeUnit scheduledTaskTimeUnit = TimeUnit.MILLISECONDS;
+
+    /**
+     * The number of tasks per deployed service for dispatching request messages into worker tasks.
+     */
+    private int noOfDispatchingTask = 2;
+
+    /**
+     * The worker pool for I/O, dispatching and actual processing.
+     */
+    private ScheduledExecutorService pollingTaskScheduler = null;
+
+    private AMQPTransportEndpoint endpoint = null;
+
+    /**
+     * The buffers which keeps request/response messages until pick by processing/response tasks.
+     */
+    private AMQPTransportBuffers buffers = null;
+
+    /**
+     * The AMQP channel to use.
+     */
+    private Channel channel;
+
+    private String configuredContentType = AMQPTransportConstant.DEFAULT_CONTENT_TYPE;
+
+    private ScheduledFuture<?> pollingTaskFuture;
+
+    public void setUseTx(boolean useTx) {
+        isUseTx = useTx;
+    }
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setConfiguredContentType(String configuredContentType) {
+        this.configuredContentType = configuredContentType;
+    }
+
+    public void setBuffers(AMQPTransportBuffers buffers) {
+        this.buffers = buffers;
+    }
+
+    public void setEndpoint(AMQPTransportEndpoint endpoint) {
+        this.endpoint = endpoint;
+    }
+
+    public void setServiceName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    public void setExchangeName(String exchangeName) {
+        this.exchangeName = exchangeName;
+    }
+
+    public void setExchangeDurable(boolean isExchangeDurable) {
+        this.isExchangeDurable = isExchangeDurable;
+    }
+
+    public void setExchangeAutoDelete(boolean exchangeAutoDelete) {
+        isExchangeAutoDelete = exchangeAutoDelete;
+    }
+
+    public void setExchangeType(String exchangeType) {
+        this.exchangeType = exchangeType;
+    }
+
+    public void setInternalExchange(boolean internalExchange) {
+        isInternalExchange = internalExchange;
+    }
+
+    public void setConsumerExchangeName(String consumerExchangeName) {
+        this.consumerExchangeName = consumerExchangeName;
+    }
+
+    public void setBindingsKeys(String[] bindingsKeys) {
+        this.bindingsKeys = bindingsKeys;
+    }
+
+    public void setQueueName(String queueName) {
+        this.queueName = queueName;
+    }
+
+    public void setQueueDurable(boolean queueDurable) {
+        isQueueDurable = queueDurable;
+    }
+
+    public void setQueueRestricted(boolean queueRestricted) {
+        isQueueRestricted = queueRestricted;
+    }
+
+    public void setQueueAutoDelete(boolean queueAutoDelete) {
+        isQueueAutoDelete = queueAutoDelete;
+    }
+
+    public void setBlockingMode(boolean blockingMode) {
+        isBlockingMode = blockingMode;
+    }
+
+    public void setNoOfConcurrentConsumers(int noOfConcurrentConsumers) {
+        this.noOfConcurrentConsumers = noOfConcurrentConsumers;
+    }
+
+    public void setInitialReconnectDuration(int initialReconnectDuration) {
+        this.initialReconnectDuration = initialReconnectDuration;
+    }
+
+    public void setReconnectionFactor(double reconnectionFactor) {
+        this.reconnectionFactor = reconnectionFactor;
+    }
+
+    public void setMaxReconnectionDuration(int maxReconnectionDuration) {
+        this.maxReconnectionDuration = maxReconnectionDuration;
+    }
+
+    public void setConnectionFactoryName(String connectionFactoryName) {
+        this.connectionFactoryName = connectionFactoryName;
+    }
+
+    public void setScheduledTaskInitialDelay(int scheduledTaskInitialDelay) {
+        this.scheduledTaskInitialDelay = scheduledTaskInitialDelay;
+    }
+
+    public void setScheduledTaskDelay(int scheduledTaskDelay) {
+        this.scheduledTaskDelay = scheduledTaskDelay;
+    }
+
+    public void setScheduledTaskTimeUnit(TimeUnit scheduledTaskTimeUnit) {
+        this.scheduledTaskTimeUnit = scheduledTaskTimeUnit;
+    }
+
+    public void setNoOfDispatchingTask(int noOfDispatchingTask) {
+        this.noOfDispatchingTask = noOfDispatchingTask;
+    }
+
+    public void setPollingTaskScheduler(ScheduledExecutorService pollingTaskScheduler) {
+        this.pollingTaskScheduler = pollingTaskScheduler;
+    }
+
+    public String getServiceName() {
+        return serviceName;
+    }
+
+    public String getExchangeName() {
+        return exchangeName;
+    }
+
+    public boolean isExchangeDurable() {
+        return isExchangeDurable;
+    }
+
+    public boolean isExchangeAutoDelete() {
+        return isExchangeAutoDelete;
+    }
+
+    public String getExchangeType() {
+        return exchangeType;
+    }
+
+    public boolean isInternalExchange() {
+        return isInternalExchange;
+    }
+
+    public String getConsumerExchangeName() {
+        return consumerExchangeName;
+    }
+
+    public String[] getBindingsKeys() {
+        return bindingsKeys;
+    }
+
+    public String getQueueName() {
+        return queueName;
+    }
+
+    public boolean isQueueDurable() {
+        return isQueueDurable;
+    }
+
+    public boolean isQueueRestricted() {
+        return isQueueRestricted;
+    }
+
+    public boolean isQueueAutoDelete() {
+        return isQueueAutoDelete;
+    }
+
+    public boolean isBlockingMode() {
+        return isBlockingMode;
+    }
+
+    public int getNoOfConcurrentConsumers() {
+        return noOfConcurrentConsumers;
+    }
+
+    public int getInitialReconnectDuration() {
+        return initialReconnectDuration;
+    }
+
+    public double getReconnectionFactor() {
+        return reconnectionFactor;
+    }
+
+    public int getMaxReconnectionDuration() {
+        return maxReconnectionDuration;
+    }
+
+    public String getConnectionFactoryName() {
+        return connectionFactoryName;
+    }
+
+    public TimeUnit getScheduledTaskTimeUnit() {
+        return scheduledTaskTimeUnit;
+    }
+
+    public int getNoOfDispatchingTask() {
+        return noOfDispatchingTask;
+    }
+
+    public ExecutorService getPollingTaskScheduler() {
+        return pollingTaskScheduler;
+    }
+
+    public AMQPTransportEndpoint getEndpoint() {
+        return endpoint;
+    }
+
+    public void setResponseConnectionFactory(String responseConnectionFactory) {
+        this.responseConnectionFactory = responseConnectionFactory;
+    }
+
+    /**
+     * Start the polling task for this service
+     */
+    public synchronized void start() throws AMQPTransportException {
+
+        try {
+            if (exchangeName != null) {
+
+                channel.exchangeDeclare(
+                        exchangeName,
+                        exchangeType,
+                        isExchangeDurable,
+                        isExchangeAutoDelete,
+                        isInternalExchange,
+                        null);
+
+                String newQueueName = channel.queueDeclare().getQueue();
+                log.info("QueueName is set to '" + newQueueName + "' for service '" + serviceName + "'");
+                queueName = newQueueName; // when there is an exchange, it generates a queue name for us
+
+                if (bindingsKeys != null) {
+                    // routing
+                    for (String bindingKey : bindingsKeys) {
+                        channel.queueBind(queueName, exchangeName, bindingKey);
+                    }
+                } else {
+                    // subscriber
+                    channel.queueBind(queueName, exchangeName, "");
+                }
+
+            } else {
+                // assume default exchange and bindings - simple consumer
+                channel.queueDeclare(queueName, isQueueDurable, isQueueRestricted, isQueueAutoDelete, null);
+
+            }
+        } catch (IOException e) {
+            handleException(e.getMessage(), e);
+        }
+
+        // schedule dispatching tasks to handover messages from the internal buffer to actual processing task
+        for (int i = 0; i < noOfDispatchingTask; i++) {
+            pollingTaskScheduler.execute(new MessageDispatchTask(buffers));
+        }
+
+        // schedule IO task to pull messages from the broker
+        for (int i = 0; i < noOfConcurrentConsumers; i++) {
+            // only channels are thread safe, so create consumer per thread
+            try {
+                QueueingConsumer consumer = new QueueingConsumer(channel);
+                boolean isAutoAck = isUseTx == true ? false : true; // increase readability
+                channel.basicConsume(queueName, isAutoAck, consumer);
+                pollingTaskFuture = pollingTaskScheduler.scheduleWithFixedDelay(
+                        new MessageIOTask(consumer, buffers, isUseTx),
+                        scheduledTaskInitialDelay,
+                        scheduledTaskDelay,
+                        scheduledTaskTimeUnit);
+            } catch (IOException e) {
+                handleException(e.getMessage(), e);
+            }
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("A polling task started listening on the queue '" + queueName + "' on behalf of the service '" +
+                    serviceName + "'");
+        }
+    }
+
+    /**
+     * Stop the polling task
+     */
+    public synchronized void stop() {
+        pollingTaskFuture.cancel(false);
+    }
+
+    /**
+     * The message dispatch task which dispatch messages from the source buffers to actual
+     * processing logic
+     */
+    private final class MessageIOTask implements Runnable {
+
+        private AMQPTransportBuffers buffers;
+        private QueueingConsumer queueingConsumer;
+        private boolean isUseTx;
+
+        private MessageIOTask(QueueingConsumer queueingConsumer,
+                              AMQPTransportBuffers buffers,
+                              boolean isAutoAck) {
+            this.queueingConsumer = queueingConsumer;
+            this.buffers = buffers;
+            this.isUseTx = isAutoAck;
+        }
+
+        public void run() {
+            try {
+                if (isUseTx) {
+                    channel.txSelect();
+                }
+                QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
+                if (delivery != null) {
+                    buffers.addRequestMessage(new AMQPTransportMessage(delivery));
+                    if (isUseTx) {
+                        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
+                        channel.txCommit();
+                    }
+                } else {
+                    if (isUseTx) {
+                        channel.txRollback();
+                    }
+                }
+            } catch (InterruptedException e) {
+                log.error("Polling task was interrupted for service '" + serviceName + "'", e);
+                Thread.currentThread().interrupt();
+            } catch (IOException e) {
+                log.error("I/O error occurs for the polling tasks for service '" + serviceName +
+                        "'", e);
+            }
+        }
+    }
+
+    /**
+     * The message dispatch task which dispatch messages from the source buffers to actual
+     * processing logic
+     */
+    private final class MessageDispatchTask implements Runnable {
+        private AMQPTransportBuffers buffers;
+
+        private MessageDispatchTask(AMQPTransportBuffers buffers) {
+            this.buffers = buffers;
+        }
+
+        public void run() {
+            while (true) {
+                AMQPTransportMessage msg = buffers.getRequestMessage();
+                if (msg != null) {
+                    pollingTaskScheduler.execute(new MessageProcessingTask(msg, buffers));
+                }
+            }
+        }
+    }
+
+    /**
+     * Process any request messages
+     */
+    private final class MessageProcessingTask implements Runnable {
+
+        private AMQPTransportMessage message;
+        private AMQPTransportBuffers buffers;
+        private boolean isSOAP11;
+
+        private MessageProcessingTask(
+                AMQPTransportMessage message,
+                AMQPTransportBuffers buffers) {
+
+            this.message = message;
+            this.buffers = buffers;
+        }
+
+        public void run() {
+            try {
+                handleIncomingMessage(message, buffers);
+            } catch (AxisFault axisFault) {
+                // there seems to be a fault while trying to execute the back end service
+                // send a fault to the client
+                try {
+                    handleFaultMessage(message, buffers, axisFault);
+                } catch (Exception e) {
+                    // do not let the task die
+                    log.error("Error while sending the fault message to the client. Client will not" +
+                            " receive any errors!", e);
+                }
+            }
+        }
+
+        private boolean handleIncomingMessage(AMQPTransportMessage message,
+                                              AMQPTransportBuffers buffers) throws AxisFault {
+            if (message == null) {
+                throw new AxisFault("A null message received!");
+            } else {
+                try {
+                    MessageContext msgContext = endpoint.createMessageContext();
+                    String msgId = message.getMessageId();
+                    msgContext.setMessageID(msgId);
+                    msgContext.setProperty(AMQPTransportConstant.AMQP_CORRELATION_ID,
+                            message.getCorrelationId());
+                    msgContext.setProperty(AMQPTransportConstant.AMQP_TRANSPORT_BUFFER_KEY, buffers);
+
+                    String contentType = message.getContentType();
+                    if (contentType == null) {
+                        // use the configured value for content type
+                        contentType = configuredContentType;
+                    }
+
+                    Map<String, Object> trpHeaders = message.getHeaders();
+
+                    if (message.getReplyTo() != null) {
+                        // this may not be the optimal way to check if this message should send a reply
+                        // a one way message can be send with 'reply to' set
+                        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO,
+                                new AMQPOutTransportInfo(contentType, responseConnectionFactory,
+                                        message.getReplyTo()));
+                        msgContext.setProperty(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO,
+                                message.getReplyTo());
+                        // cache the connection factory so that it can be used for sending the response
+                        msgContext.setProperty(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME,
+                                responseConnectionFactory);
+                    }
+
+                    HTTPTransportUtils.initializeMessageContext(
+                            msgContext,
+                            message.getSoapAction(),
+                            null,
+                            contentType);
+
+                    ByteArrayInputStream inputStream = new ByteArrayInputStream(message.getBody());
+
+                    msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+                    msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, trpHeaders);
+
+                    Builder builder = BuilderUtil.getBuilderFromSelector(contentType, msgContext);
+                    InputStream gzipInputStream = HTTPTransportUtils.handleGZip(msgContext, inputStream);
+                    OMElement documentElement = builder.processDocument(gzipInputStream, contentType, msgContext);
+                    msgContext.setEnvelope(TransportUtils.createSOAPEnvelope(documentElement));
+                    isSOAP11 = msgContext.isSOAP11();
+
+                    AxisEngine.receive(msgContext);
+
+                    return true;
+
+                } catch (IOException e) {
+                    throw new AxisFault(e.getMessage(), e);
+                }
+            }
+        }
+
+        private void handleFaultMessage(AMQPTransportMessage originalMsg,
+                                        AMQPTransportBuffers buffers,
+                                        AxisFault axisFault) throws Exception {
+
+            SOAPFactory factory = (isSOAP11 ?
+                    OMAbstractFactory.getSOAP11Factory() : OMAbstractFactory.getSOAP12Factory());
+            OMDocument soapFaultDocument = factory.createOMDocument();
+            SOAPEnvelope faultEnvelope = factory.getDefaultFaultEnvelope();
+            soapFaultDocument.addChild(faultEnvelope);
+
+            // create the fault element  if it is needed
+            SOAPFault fault = faultEnvelope.getBody().getFault();
+            if (fault == null) {
+                fault = factory.createSOAPFault();
+            }
+            SOAPFaultCode code = factory.createSOAPFaultCode();
+            code.setText(axisFault.getMessage());
+            fault.setCode(code);
+
+            SOAPFaultReason reason = factory.createSOAPFaultReason();
+            reason.setText(axisFault.getMessage());
+            fault.setReason(reason);
+
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            faultEnvelope.serialize(out);
+            AMQPTransportMessage msg = new AMQPTransportMessage(
+                    new AMQP.BasicProperties(), out.toByteArray());
+            try {
+                buffers.addResponseMessage(msg);
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        }
+
+    }
+
+    private void handleException(String msg, Throwable t) throws AMQPTransportException {
+        log.error(msg, t);
+        throw new AMQPTransportException(msg, t);
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPSimpleConsumerTask.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPSimpleConsumerTask.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPSimpleConsumerTask.java	(revision 1507855)
@@ -0,0 +1,110 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.transport.amqp.pollingtask;
+
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.QueueingConsumer;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.amqp.AMQPTransportMessage;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Semaphore;
+
+public class AMQPSimpleConsumerTask {
+
+    private static Log log = LogFactory.getLog(AMQPSimpleConsumerTask.class);
+
+    private Channel channel;
+
+    private String queueName;
+
+    private Map<String, Semaphore> responseTracker;
+
+    private Map<String, AMQPTransportMessage> responseMessage;
+
+    private ExecutorService workerPool;
+
+    public AMQPSimpleConsumerTask(
+            ExecutorService workerPool,
+            Channel channel,
+            String queueName,
+            Map<String, Semaphore> responseTracker,
+            Map<String, AMQPTransportMessage> responseMessage) {
+        this.workerPool = workerPool;
+        this.channel = channel;
+        this.queueName = queueName;
+        this.responseTracker = responseTracker;
+        this.responseMessage = responseMessage;
+    }
+
+    public void consume() {
+        workerPool.submit(new Consumer(channel, queueName, responseTracker, responseMessage));
+    }
+
+    private static class Consumer implements Runnable {
+        Channel channel;
+        String queueName;
+        Map<String, Semaphore> responseTracker;
+        Map<String, AMQPTransportMessage> responseMessage;
+
+
+        private Consumer(
+                Channel channel,
+                String queueName,
+                Map<String, Semaphore> responseTracker,
+                Map<String, AMQPTransportMessage> responseMessage) {
+            this.channel = channel;
+            this.queueName = queueName;
+            this.responseTracker = responseTracker;
+            this.responseMessage = responseMessage;
+        }
+
+        @Override
+        public void run() {
+            try {
+                channel.queueDeclare(queueName, false, false, false, null);
+                QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
+                channel.basicConsume(queueName, true, queueingConsumer);
+
+                QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
+                AMQPTransportMessage msg = new AMQPTransportMessage(delivery);
+                responseMessage.put(msg.getCorrelationId(), msg);
+                Semaphore semaphore = responseTracker.get(msg.getCorrelationId());
+                semaphore.release();
+
+            } catch (IOException e) {
+                log.error("I/O error occurred while retrieving the", e);
+            } catch (InterruptedException e) {
+                log.error("Retrieving task was interrupted", e);
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTaskFactory.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTaskFactory.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/pollingtask/AMQPTransportPollingTaskFactory.java	(revision 1507855)
@@ -0,0 +1,272 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp.pollingtask;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.AxisService;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.amqp.*;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;
+
+import java.util.Map;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The factory implementation for {@link AMQPTransportPollingTask}. Polling task(with multiple)
+ * consumers will be deployed for each deployed service.
+ */
+public class AMQPTransportPollingTaskFactory {
+
+    private static Log log = LogFactory.getLog(AMQPTransportPollingTaskFactory.class);
+
+    public static AMQPTransportPollingTask createPollingTaskForService(
+            AxisService service,
+            ScheduledExecutorService pool,
+            AMQPTransportEndpoint endpoint,
+            AMQPTransportConnectionFactory connectionFactory) throws AxisFault {
+
+        Map<String, String> svcParam =
+                AMQPTransportUtils.getServiceStringParameters(service.getParameters());
+        Map<String, String> conFacParam = connectionFactory.getParameters();
+
+
+        AMQPTransportPollingTask pt = new AMQPTransportPollingTask();
+
+        pt.setServiceName(service.getName());
+        pt.setEndpoint(endpoint);
+        pt.setPollingTaskScheduler(pool);
+
+        // set buffers to hold request/response messages for this task
+        pt.setBuffers(new AMQPTransportBuffers());
+
+        String exchangeName = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, svcParam, conFacParam);
+        pt.setExchangeName(exchangeName);
+
+        Boolean isDurable = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_DURABLE, svcParam, conFacParam);
+        if (isDurable != null) {
+            pt.setExchangeDurable(isDurable);
+        }
+
+        Boolean isAutoDelete = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_AUTO_DELETE, svcParam, conFacParam);
+        if (isAutoDelete != null) {
+            pt.setExchangeAutoDelete(isAutoDelete);
+        }
+
+        String exchangeType = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, svcParam, conFacParam);
+        if (exchangeType != null) {
+            if (exchangeName == null) {
+                throw new AxisFault("Possible configuration error. No exchange name provided but " +
+                        "exchange type is set to '" + exchangeType + "'");
+            }
+
+            pt.setExchangeType(exchangeType);
+        }
+
+        Boolean isInternalExchange = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, svcParam, conFacParam);
+        if (isInternalExchange != null) {
+            if (exchangeName == null) {
+                throw new AxisFault("Possible configuration error. No exchange name provided but " +
+                        "exchange restricted as " + (isInternalExchange ? "internal." : "external."));
+            }
+            pt.setInternalExchange(isInternalExchange);
+        }
+
+
+        pt.setChannel(connectionFactory.getChannel());
+        pt.setConnectionFactoryName(connectionFactory.getName());
+
+        String responseConFac = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME, svcParam, conFacParam);
+        if (responseConFac != null) {
+            pt.setResponseConnectionFactory(responseConFac);
+        }
+
+        String consumerExchange = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_BIND_EXCHANGE, svcParam, conFacParam);
+        if (consumerExchange != null) {
+            if (exchangeName != null && !consumerExchange.equals(exchangeName)) {
+                log.warn("Possible configuration error? Exchange name is set to '" +
+                        exchangeName + "' and consumer's exchange name is set to '" +
+                        consumerExchange + "'");
+            }
+            pt.setConsumerExchangeName(consumerExchange);
+        }
+
+        String bindingKeyString = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_BINDING_KEYS, svcParam, conFacParam);
+
+        if (bindingKeyString != null) {
+            pt.setBindingsKeys(AMQPTransportUtils.split(
+                    bindingKeyString, AMQPTransportConstant.ROUTING_KEY_DELIMITER));
+        }
+
+        String queueName = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_NAME, svcParam, conFacParam);
+        if (queueName == null) {
+            queueName = service.getName(); // set the service name as the queue name for default.
+        }
+        pt.setQueueName(queueName);
+
+        String configuredContentType = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_CONFIGURED_CONTENT_TYPE, svcParam, conFacParam);
+        if (configuredContentType != null) {
+            pt.setConfiguredContentType(configuredContentType);
+        }
+
+        Boolean isQueueDurable = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, svcParam, conFacParam);
+        if (isDurable != null) {
+            pt.setQueueDurable(isQueueDurable);
+        }
+
+        Boolean isQueueRestricted = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_RESTRICTED, svcParam, conFacParam);
+        if (isQueueRestricted != null) {
+            pt.setQueueRestricted(isQueueRestricted);
+        }
+
+        Boolean isQueueAutoDelete = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_AUTO_DELETE, svcParam, conFacParam);
+        if (isQueueAutoDelete != null) {
+            pt.setQueueAutoDelete(isQueueAutoDelete);
+        }
+
+        Boolean isBlockingMode = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_OPERATE_ON_BLOCKING_MODE, svcParam, conFacParam);
+        if (isBlockingMode != null) {
+            pt.setBlockingMode(isBlockingMode);
+        }
+
+        try {
+            Integer noOfConsumers = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, svcParam, conFacParam);
+            if (noOfConsumers != null) {
+                pt.setNoOfConcurrentConsumers(noOfConsumers);
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign the number of concurrent consumers", e);
+        }
+
+        try {
+            Integer initialReconectionDuration = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, svcParam, conFacParam);
+            if (initialReconectionDuration != null) {
+                pt.setInitialReconnectDuration(initialReconectionDuration);
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign the initial re-connection duration", e);
+        }
+
+        try {
+            Integer reconnectionFactor = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR, svcParam, conFacParam);
+            if (reconnectionFactor != null) {
+                pt.setReconnectionFactor(reconnectionFactor);
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign reconnection factor", e);
+        }
+
+        try {
+            Integer dispatchingTask = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_DISPATCHING_TASK_SIZE, svcParam, conFacParam);
+            if (dispatchingTask != null) {
+                pt.setNoOfDispatchingTask(dispatchingTask);
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign number of dispatching task value", e);
+        }
+
+        Boolean isUseTx = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_CONSUMER_TX, svcParam, conFacParam);
+        if (isUseTx != null) {
+            pt.setUseTx(isUseTx);
+        }
+
+        try {
+            Integer initialDelay = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_INITIAL_DELAY, svcParam, conFacParam);
+            if (initialDelay != null) {
+                pt.setScheduledTaskInitialDelay(initialDelay.intValue());
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign the scheduled task initial delay value", e);
+        }
+
+        try {
+            Integer delay = AMQPTransportUtils.getOptionalIntParameter(
+                    AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_INITIAL_DELAY, svcParam, conFacParam);
+            if (delay != null) {
+                pt.setScheduledTaskDelay(delay.intValue());
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not assign the scheduled task delay value", e);
+        }
+
+        String timeUnit = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_SCHEDULED_TASK_TIME_UNIT, svcParam, conFacParam);
+
+        if (timeUnit != null) {
+            pt.setScheduledTaskTimeUnit(getTimeUnit(timeUnit));
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("A polling task for the service '" + service.getName() + "' was produced with " +
+                    "following parameters.\n" +
+                    "Exchange Name: '" + pt.getExchangeName() + "'\n" +
+                    "Exchange Type: '" + pt.getExchangeType() + "'\n" +
+                    "Exchange Durable?: '" + pt.isExchangeDurable() + "'\n" +
+                    "Exchange AutoDelete?: '" + pt.isExchangeAutoDelete() + "\n" +
+                    "Is internal exchange: '" + pt.isInternalExchange() + "'\n" +
+                    "Consumer Exchange: " + pt.getConsumerExchangeName() + "'\n" +
+                    "Routing Keys: '" + bindingKeyString + "'\n" +
+                    "QueueName: '" + pt.getQueueName() + "'\n" +
+                    "Is queue durable: '" + pt.isQueueDurable() + "'\n" +
+                    "Is queue restricted: '" + pt.isQueueRestricted() + "'\n" +
+                    "Is queue auto deleted: '" + pt.isQueueAutoDelete() + "'\n" +
+                    "Is blocking mode: '" + pt.isBlockingMode() + "'\n" +
+                    "Initial re-connection duration: '" + pt.getInitialReconnectDuration() + "(ms)'\n" +
+                    "Re-connection progression factor: '" + pt.getReconnectionFactor() + "'\n" +
+                    "Maximum re-connection duration: '" + pt.getMaxReconnectionDuration() + "'\n" +
+                    "Number of concurrent consumers: '" + pt.getNoOfConcurrentConsumers() + "'\n" +
+                    "Number of dispatching task: '" + pt.getNoOfDispatchingTask() + "'");
+        }
+
+        return pt;
+    }
+
+    private static TimeUnit getTimeUnit(String timeUnit) {
+
+        if ("days".equals(timeUnit)) {
+            return TimeUnit.DAYS;
+        } else if ("hours".equals(timeUnit)) {
+            return TimeUnit.HOURS;
+        } else if ("minutes".equals(timeUnit)) {
+            return TimeUnit.MINUTES;
+        } else if ("seconds".equals(timeUnit)) {
+            return TimeUnit.SECONDS;
+        } else if ("milliseconds".equals(timeUnit)) {
+            return TimeUnit.MILLISECONDS;
+        } else {
+            return TimeUnit.MICROSECONDS;
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportBuffers.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportBuffers.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportBuffers.java	(revision 1507855)
@@ -0,0 +1,101 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import org.apache.axis2.AxisFault;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+/**
+ * Keeps the request/response messages until pick by the processing/response dispatching tasks.
+ * These buffers(an instance of
+ * http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html) are used in
+ * order to define an asynchronous architecture between the polling tak and actual processing which
+ * will lead to higher performance.
+ */
+public class AMQPTransportBuffers {
+    /**
+     * The request message buffer which holds the request messages
+     */
+    private BlockingQueue<AMQPTransportMessage> requestBuffer =
+            new LinkedBlockingQueue<AMQPTransportMessage>();
+
+    /**
+     * The response message buffer which holds the responses for processed messages
+     */
+    private BlockingQueue<AMQPTransportMessage> responseBuffer =
+            new LinkedBlockingQueue<AMQPTransportMessage>();
+
+    /**
+     * Returns the response messages as a list
+     *
+     * @param blockSize the block blockSize of the response message list
+     * @return the block of the response messages of blockSize
+     * @throws AMQPTransportException in case of an error
+     */
+    public List<AMQPTransportMessage> getResponseMessageList(final int blockSize) throws AMQPTransportException {
+        List<AMQPTransportMessage> msgList = new ArrayList<AMQPTransportMessage>();
+        if (responseBuffer.size() > 0) {
+            AMQPTransportUtils.moveElements(responseBuffer, msgList, blockSize);
+        }
+        return msgList;
+    }
+
+    /**
+     * Add a response message to the response buffer
+     *
+     * @param msg the response message
+     * @throws InterruptedException throws in case of an error
+     */
+    public void addResponseMessage(AMQPTransportMessage msg) throws InterruptedException {
+        // it's ok to block here until space available,
+        responseBuffer.put(msg);
+    }
+
+    /**
+     * Returns the request message buffer in transport
+     *
+     * @return the request message buffer
+     */
+    public BlockingQueue<AMQPTransportMessage> getRequestMessageBuffer() {
+        return requestBuffer;
+    }
+
+    /**
+     * Add a message to the request message buffer
+     *
+     * @param msg the message to add into the buffer
+     */
+    public void addRequestMessage(AMQPTransportMessage msg) {
+        requestBuffer.add(msg);
+    }
+
+    /**
+     * Returns a request message from the request message buffer
+     *
+     * @return the request message
+     */
+    public AMQPTransportMessage getRequestMessage() {
+        try {
+            // block if there is no messages
+            return requestBuffer.take();
+        } catch (InterruptedException e) {
+            // ignore
+        }
+        return null;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportException.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportException.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportException.java	(revision 1507855)
@@ -0,0 +1,32 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+/**
+ * Defines an exception class for AMQP transport
+ */
+public class AMQPTransportException extends Exception {
+
+    public AMQPTransportException(final String message) {
+        super(message);
+    }
+
+    public AMQPTransportException(final String message, Throwable t) {
+        super(message, t);
+    }
+
+    public AMQPTransportException(Throwable t) {
+        super(t);
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/tx/AMQPTransportProducerTx.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/tx/AMQPTransportProducerTx.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/tx/AMQPTransportProducerTx.java	(revision 1507855)
@@ -0,0 +1,69 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.transport.amqp.tx;
+
+import com.rabbitmq.client.Channel;
+
+import java.io.IOException;
+
+/**
+ * Wrap the normal transaction API and the light weight publisher confirm apis'.
+ * See http://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/,
+ *
+ */
+public class AMQPTransportProducerTx {
+
+    /**
+     * Use light weight publisher confirm to handle transaction ? Default is
+     * set to true for high performance
+     */
+    private boolean isLightWeightPublisherConfirm = true;
+
+    private Channel channel;
+
+    public AMQPTransportProducerTx(boolean lightWeightPublisherConfirm,
+                                   Channel channel) {
+        isLightWeightPublisherConfirm = lightWeightPublisherConfirm;
+        this.channel = channel;
+    }
+
+    public void start() throws IOException {
+        if (isLightWeightPublisherConfirm) {
+            channel.confirmSelect();
+        } else {
+            channel.txSelect();
+        }
+    }
+
+    public void end() throws InterruptedException, IOException {
+        if (isLightWeightPublisherConfirm) {
+            channel.waitForConfirms();
+        } else {
+            channel.txCommit();
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportEndpoint.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportEndpoint.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportEndpoint.java	(revision 1507855)
@@ -0,0 +1,93 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.ParameterInclude;
+import org.apache.axis2.transport.base.ProtocolEndpoint;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;
+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTask;
+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTaskFactory;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ScheduledExecutorService;
+
+/**
+ * Represent and endpoint in AMQP transport implementation.
+ */
+public class AMQPTransportEndpoint extends ProtocolEndpoint {
+
+    private Set<EndpointReference> endpointReferences = new HashSet<EndpointReference>();
+
+    private ScheduledExecutorService workerPool;
+
+    private AMQPTransportPollingTask pollingTask;
+
+    private AMQPTransportListener transportReceiver;
+
+    public AMQPTransportEndpoint(ScheduledExecutorService workerPool,
+                                 AMQPTransportListener receiver) {
+        this.workerPool = workerPool;
+        this.transportReceiver = receiver;
+    }
+
+    public AMQPTransportPollingTask getPollingTask() {
+        return pollingTask;
+    }
+
+    @Override
+    public boolean loadConfiguration(ParameterInclude params) throws AxisFault {
+        if (!(params instanceof AxisService)) {
+            return false;
+        }
+        try {
+            AxisService service = (AxisService) params;
+
+            String conFacName;
+            if (service.getParameter(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME) != null) {
+                conFacName = (String) service.getParameter(
+                        AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME).getValue();
+
+            } else {
+                conFacName = AMQPTransportConstant.DEFAULT_CONNECTION_FACTORY_NAME;
+            }
+
+            AMQPTransportConnectionFactory conFac =
+                    transportReceiver.getConnectionFactory(conFacName);
+            if (conFac == null) {
+                throw new AxisFault("No connection factory definition found");
+            }
+
+            pollingTask = AMQPTransportPollingTaskFactory.createPollingTaskForService(
+                    service,
+                    workerPool,
+                    this,
+                    conFac);
+
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not load the AMQP endpoint configuration, " + e.getMessage(), e);
+        }
+        return true;
+    }
+
+    @Override
+    public EndpointReference[] getEndpointReferences(AxisService service, String ip)
+            throws AxisFault {
+        return endpointReferences.toArray(new EndpointReference[endpointReferences.size()]);
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportSender.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportSender.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportSender.java	(revision 1507855)
@@ -0,0 +1,343 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.builder.Builder;
+import org.apache.axis2.builder.BuilderUtil;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.description.WSDL2Constants;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.transport.OutTransportInfo;
+import org.apache.axis2.transport.base.AbstractTransportSender;
+import org.apache.axis2.util.MessageContextBuilder;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;
+import org.apache.synapse.transport.amqp.pollingtask.AMQPSimpleConsumerTask;
+import org.apache.synapse.transport.amqp.sendertask.AMQPSender;
+import org.apache.synapse.transport.amqp.sendertask.AMQPSenderCache;
+import org.apache.synapse.transport.amqp.sendertask.AMQPSenderFactory;
+import org.apache.synapse.transport.amqp.tx.AMQPTransportProducerTx;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.*;
+
+/**
+ * The transport sender implementation for AMQP transport. A message can end up here as
+ * part of directly calling an AMQP endpoint or sending a response to a two way request message.
+ */
+public class AMQPTransportSender extends AbstractTransportSender {
+
+    /**
+     * The connection factory definitions defined in axis2.xml for transport sender section
+     */
+    private AMQPTransportConnectionFactoryManager connectionFactoryManager;
+
+    private ExecutorService connectionFactoryES;
+
+    private AMQPSenderCache cache;
+
+    /**
+     * Keep tracks of the responses for two in/out messages
+     */
+    private Map<String, Semaphore> responseTracker;
+
+    /**
+     * Store the response messages for in/out messages until further process
+     */
+    private Map<String, AMQPTransportMessage> responseMessage;
+
+    private ExecutorService responseHandlingPool;
+
+    private long semaphoreTimeOut;
+
+    @Override
+    public void init(ConfigurationContext cfgCtx, TransportOutDescription transportOut)
+            throws AxisFault {
+        super.init(cfgCtx, transportOut);
+
+        connectionFactoryES = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty(
+                AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE,
+                AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));
+
+        responseHandlingPool = Executors.newFixedThreadPool(AMQPTransportUtils.getIntProperty(
+                AMQPTransportConstant.PARAM_RESPONSE_HANDLING_POOL_SIZE,
+                AMQPTransportConstant.RESPONSE_HANDLING_POOL_DEFAULT));
+
+        connectionFactoryManager = new AMQPTransportConnectionFactoryManager();
+        connectionFactoryManager.addConnectionFactories(transportOut, connectionFactoryES);
+
+        semaphoreTimeOut = AMQPTransportUtils.getLongProperty(
+                AMQPTransportConstant.PARAM_SEMAPHORE_TIME_OUT, 86400L);
+
+        cache = new AMQPSenderCache(new ConcurrentHashMap<Integer, AMQPSender>());
+        responseTracker = new ConcurrentHashMap<String, Semaphore>();
+        responseMessage = new ConcurrentHashMap<String, AMQPTransportMessage>();
+//        MBeanRegister.getInstance().registerMBean(
+//                new TransportView(null, this), "Transport", "amqp-tx-receiver");
+
+        log.info("AMQP transport sender initializing..");
+    }
+
+    @Override
+    public void stop() {
+        super.stop();
+        try {
+            connectionFactoryManager.shutDownConnectionFactories();
+        } catch (AMQPTransportException e) {
+            log.error("Error while shutting down connection factories, continue anyway...", e);
+        }
+        cache.clean();
+        responseTracker.clear();
+        responseMessage.clear();
+        connectionFactoryES.shutdown();
+        responseHandlingPool.shutdown();
+    }
+
+    @Override
+    public void sendMessage(MessageContext msgCtx,
+                            String targetEPR,
+                            OutTransportInfo outTransportInfo) throws AxisFault {
+
+        AMQPSender amqpSender;
+        Integer hashKey = null;
+        Map<String, String> params = null;
+        String replyTo = null;
+        AMQPTransportProducerTx tx;
+        MessageContext replyMsgCtx = msgCtx.getOperationContext().getMessageContext(
+                WSDL2Constants.MESSAGE_LABEL_IN);
+        if (replyMsgCtx != null) {
+            replyTo = (String) replyMsgCtx.getProperty(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO);
+        }
+
+        if (replyTo != null) {
+            // this is a response for a request message(request/response semantic message)
+            hashKey = replyTo.hashCode();
+            params = new HashMap<String, String>();
+            params.put(AMQPTransportConstant.PARAMETER_QUEUE_NAME, replyTo);
+
+            String conFacName = (String) msgCtx.getOperationContext().
+                    getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN).
+                    getProperty(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME);
+            if (conFacName == null) {
+                throw new AxisFault("A message was received with 'reply to' set. But no reply " +
+                        "connection factory name found. Define the parameter '" +
+                        AMQPTransportConstant.PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME +
+                        "' as a service parameter. This response message will be dropped!");
+            } else {
+                params.put(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME, conFacName);
+            }
+        } else {
+            // this is a normal one way out message
+            if (targetEPR != null) {
+                hashKey = new Integer(targetEPR.hashCode());
+                try {
+                    params = AMQPTransportUtils.parseAMQPUri(targetEPR);
+                } catch (AMQPTransportException e) {
+                    throw new AxisFault("Error while parsing the AMQP epr '" + targetEPR + "'", e);
+                }
+            } else if (outTransportInfo != null && outTransportInfo instanceof AMQPOutTransportInfo) {
+                AMQPOutTransportInfo info = (AMQPOutTransportInfo) outTransportInfo;
+                params = info.getParams();
+
+            } else {
+                throw new AxisFault("Could not determine the endpoint information to deliver the message");
+            }
+        }
+
+        if (cache.hit(hashKey)) {
+            amqpSender = cache.get(hashKey);
+        } else {
+            try {
+                amqpSender = AMQPSenderFactory.createAMQPSender(connectionFactoryManager, params);
+                cache.add(hashKey, amqpSender);
+            } catch (IOException e) {
+                throw new AxisFault("Could not create the AMQP sender", e);
+            }
+        }
+
+        try {
+            String correlationId = (String)
+                    msgCtx.getProperty(AMQPTransportConstant.PROPERTY_AMQP_CORRELATION_ID);
+            if (correlationId == null) {
+                correlationId = msgCtx.getMessageID();
+            }
+
+            boolean isInOut = waitForSynchronousResponse(msgCtx);
+            Semaphore available = null;
+            if (isInOut) {
+                replyTo = (String) msgCtx.getProperty(
+                        AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO);
+                if (replyTo == null) {
+                    replyTo = UUID.randomUUID().toString();
+                }
+                available = new Semaphore(0, true);
+                responseTracker.put(correlationId, available);
+            }
+
+            String useTx = (String) msgCtx.getProperty(AMQPTransportConstant.PROPERTY_PRODUCER_TX);
+
+            if (AMQPTransportConstant.AMQP_USE_LWPC.equals(useTx)) {
+                tx = new AMQPTransportProducerTx(true, amqpSender.getChannel());
+            } else if (AMQPTransportConstant.AMQP_USE_TX.equals(useTx)) {
+                tx = new AMQPTransportProducerTx(false, amqpSender.getChannel());
+            } else {
+                tx = null;
+            }
+
+            if (tx != null) {
+                try {
+                    tx.start();
+                } catch (IOException e) {
+                    throw new AxisFault("Error while initiation tx for message '" +
+                            msgCtx.getMessageID() + "'", e);
+                }
+            }
+
+            amqpSender.sendAMQPMessage(msgCtx, correlationId, replyTo);
+
+            if (tx != null) {
+                try {
+                    tx.end();
+                } catch (IOException e) {
+                    throw new AxisFault("Error while terminating tx for message '" +
+                            msgCtx.getMessageID() + "'", e);
+                } catch (InterruptedException e) {
+                    log.error("Error while terminating tx for message '" +
+                            msgCtx.getMessageID() + "'", e);
+                    Thread.currentThread().interrupt();
+                }
+            }
+
+            if (isInOut) {
+                // block and process the response
+                new AMQPSimpleConsumerTask(
+                        responseHandlingPool,
+                        amqpSender.getChannel(),
+                        replyTo,
+                        responseTracker,
+                        responseMessage).
+                        consume();
+                try {
+                    available.tryAcquire(semaphoreTimeOut, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+
+                responseTracker.remove(correlationId);
+                AMQPTransportMessage msg = responseMessage.get(correlationId);
+                if (msg != null) {
+                    handleSyncResponse(msgCtx, msg, msg.getContentType());
+                } else {
+                    // we don't have a response yet, so send a fault to client
+                    log.warn("The semaphore with id '" + correlationId + "' was time out while "
+                            + "waiting for a response, sending a fault to client..");
+                    sendFault(msgCtx,
+                            new Exception("Times out occurs while waiting for a response"));
+                }
+            }
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not retrieve the connection factory information", e);
+        } catch (IOException e) {
+            throw new AxisFault("Could not produce the message into the destination", e);
+        }
+    }
+
+    private void handleSyncResponse(
+            MessageContext requestMsgCtx,
+            AMQPTransportMessage message,
+            String requestContentType)
+            throws AxisFault {
+        try {
+            MessageContext responseMsgCtx = createResponseMessageContext(requestMsgCtx);
+            responseMsgCtx.setProperty(Constants.Configuration.MESSAGE_TYPE,
+                    requestMsgCtx.getProperty(Constants.Configuration.MESSAGE_TYPE));
+
+            responseMsgCtx.setProperty(Constants.Configuration.CONTENT_TYPE,
+                    requestMsgCtx.getProperty(Constants.Configuration.CONTENT_TYPE));
+
+            String contentType = message.getContentType();
+            if (contentType == null) {
+                contentType = inferContentType(requestContentType, responseMsgCtx);
+            }
+
+            ByteArrayInputStream inputStream = new ByteArrayInputStream(message.getBody());
+            Builder builder = BuilderUtil.getBuilderFromSelector(contentType, requestMsgCtx);
+            SOAPEnvelope envelope = (SOAPEnvelope) builder.processDocument(
+                    inputStream, contentType, responseMsgCtx);
+            responseMsgCtx.setEnvelope(envelope);
+
+            String charSetEnc = BuilderUtil.getCharSetEncoding(contentType);
+            if (charSetEnc == null) {
+                charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+            }
+            responseMsgCtx.setProperty(
+                    Constants.Configuration.CHARACTER_SET_ENCODING,
+                    contentType.indexOf(HTTP.CHARSET_PARAM) > 0
+                            ? charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);
+            responseMsgCtx.setProperty(
+                    MessageContext.TRANSPORT_HEADERS, message.getHeaders());
+
+            if (message.getSoapAction() != null) {
+                responseMsgCtx.setSoapAction(message.getSoapAction());
+            }
+            AxisEngine.receive(responseMsgCtx);
+
+        } catch (AxisFault axisFault) {
+            handleException("Could not handle the response message ", axisFault);
+        }
+    }
+
+    private void sendFault(MessageContext msgContext, Exception e) {
+        try {
+            MessageContext faultContext = MessageContextBuilder.createFaultMessageContext(
+                    msgContext, e);
+            faultContext.setProperty("ERROR_MESSAGE", e.getMessage());
+            faultContext.setProperty("SENDING_FAULT", Boolean.TRUE);
+            AxisEngine.sendFault(faultContext);
+        } catch (AxisFault axisFault) {
+            log.fatal("Could not create the fault message.", axisFault);
+        }
+    }
+
+    private String inferContentType(String requestContentType, MessageContext responseMsgCtx) {
+        // Try to get the content type from the message context
+        Object cTypeProperty = responseMsgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);
+        if (cTypeProperty != null) {
+            return cTypeProperty.toString();
+        }
+        // Try to get the content type from the axis configuration
+        Parameter cTypeParam = cfgCtx.getAxisConfiguration().getParameter(
+                Constants.Configuration.CONTENT_TYPE);
+        if (cTypeParam != null) {
+            return cTypeParam.getValue().toString();
+        }
+
+        if (requestContentType != null) {
+            return requestContentType;
+        }
+
+        // Unable to determine the content type - Return default value
+        return AMQPTransportConstant.DEFAULT_CONTENT_TYPE;
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportUtils.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportUtils.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportUtils.java	(revision 1507855)
@@ -0,0 +1,288 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import com.rabbitmq.client.Address;
+import org.apache.axis2.description.Parameter;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.concurrent.BlockingQueue;
+
+/**
+ * Contains some utility methods for the AMQP transport implementation
+ */
+public final class AMQPTransportUtils {
+
+    private static final Log log = LogFactory.getLog(AMQPTransportUtils.class);
+
+    private static Properties prop;
+
+    static {
+        prop = loadProperties("amqp-transport.properties");
+    }
+
+    private static Properties loadProperties(String filePath) {
+        Properties properties = new Properties();
+        ClassLoader cl = Thread.currentThread().getContextClassLoader();
+
+        if (log.isDebugEnabled()) {
+            log.debug("Loading a file '" + filePath + "' from classpath");
+        }
+
+        InputStream in = cl.getResourceAsStream(filePath);
+        if (in == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Unable to load file  ' " + filePath + " '");
+            }
+
+            filePath = "repository/conf" +
+                    File.separatorChar + filePath;
+            if (log.isDebugEnabled()) {
+                log.debug("Loading a file '" + filePath + "' from classpath");
+            }
+
+            in = cl.getResourceAsStream(filePath);
+            if (in == null) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unable to load file  ' " + filePath + " '");
+                }
+            }
+        }
+        if (in != null) {
+            try {
+                properties.load(in);
+            } catch (IOException e) {
+                String msg = "Error loading properties from a file at :" + filePath;
+                log.error(msg, e);
+            }
+        }
+        return properties;
+    }
+
+    /**
+     * Read the value of a string property.
+     *
+     * @param name name of the property.
+     * @param def  default value.
+     * @return the string value
+     * @throws NumberFormatException in case invalid property value.
+     */
+    public static String getStringProperty(String name, String def) throws NumberFormatException {
+        String val = System.getProperty(name);
+        return val == null ?
+                (prop.get(name) == null ? def : (String) prop.get(name)) :
+                val;
+    }
+
+    /**
+     * Read the value of a int property.
+     *
+     * @param name name of the property.
+     * @param def  default value if no value is found.
+     * @return the property value.
+     * @throws NumberFormatException in case of an invalid property value.
+     */
+    public static int getIntProperty(String name, int def) throws NumberFormatException {
+        String val = System.getProperty(name);
+        return val == null ?
+                (prop.get(name) == null ? def : Integer.parseInt((String) prop.get(name))) :
+                Integer.parseInt(val);
+    }
+
+    /**
+     * Read the value of a property of type long
+     *
+     * @param name name of the property
+     * @param def  value of the property
+     * @return value of property
+     * @throws NumberFormatException throws in case of an error.
+     */
+    public static long getLongProperty(String name, long def) throws NumberFormatException {
+        String val = System.getProperty(name);
+        return val == null ?
+                (prop.get(name) == null ? def : Long.parseLong((String) prop.get(name))) :
+                Long.parseLong(val);
+    }
+
+    public static double getDoubleProperty(String name, double def) throws NumberFormatException {
+        String val = System.getProperty(name);
+        return val == null ?
+                (prop.get(name) == null ? def : Double.parseDouble((String) prop.get(name))) :
+                Double.parseDouble(val);
+    }
+
+    public static Boolean getBooleanProperty(String name, boolean def) throws NumberFormatException {
+        String val = System.getProperty(name);
+        return val == null ?
+                (prop.get(name) == null ? def : Boolean.parseBoolean((String) prop.get(name))) :
+                Boolean.parseBoolean(val);
+    }
+
+    public static Map<String, String> getServiceStringParameters(List<Parameter> list) {
+        Map<String, String> map = new HashMap<String, String>();
+        for (Parameter p : list) {
+            if (p.getValue() instanceof String) {
+                map.put(p.getName(), (String) p.getValue());
+            }
+        }
+        return map;
+    }
+
+    public static String getOptionalStringParameter(String key, Map<String, String> srcMap1,
+                                                    Map<String, String> srcMap2) {
+
+        String value = srcMap1.get(key);
+        if (value == null) {
+            value = srcMap2.get(key);
+        }
+        return value;
+    }
+
+    public static Boolean getOptionalBooleanParameter(String key, Map<String, String> srcMap1,
+                                                      Map<String, String> srcMap2) {
+        String value = srcMap1.get(key);
+        if (value == null) {
+            value = srcMap2.get(key);
+        }
+        if (value == null) {
+            return null;
+        } else {
+            return Boolean.valueOf(value);
+        }
+    }
+
+    public static Integer getOptionalIntParameter(String key,
+                                                  Map<String, String> srcMap1,
+                                                  Map<String, String> srcMap2)
+            throws AMQPTransportException {
+        String value = srcMap1.get(key);
+        if (value == null) {
+            value = srcMap2.get(key);
+        }
+        if (value != null) {
+            try {
+                return Integer.parseInt(value);
+            } catch (NumberFormatException e) {
+                throw new AMQPTransportException(
+                        "Invalid value '" + value + "' for the key '" + key + "'");
+            }
+        }
+        return null;
+    }
+
+    public static Double getOptionalDoubleParameter(String key,
+                                                    Map<String, String> srcMap1,
+                                                    Map<String, String> srcMap2)
+            throws AMQPTransportException {
+        String value = srcMap1.get(key);
+        if (value == null) {
+            value = srcMap2.get(key);
+        }
+        if (value != null) {
+            try {
+                return Double.parseDouble(value);
+            } catch (NumberFormatException e) {
+                throw new AMQPTransportException(
+                        "Invalid value '" + value + "' for the key '" + key + "'");
+            }
+        }
+        return null;
+    }
+
+    public static String[] split(String src, final String delimiter) {
+        return src.split(delimiter);
+    }
+
+    /**
+     * Digest the address array in the form hostName1:portNumber1,hostName2:portNumber2,hostName3:portNumber3
+     *
+     * @param addressString Address array string
+     * @param regex         the first regex to split the string
+     * @param subRegex      the sub regex to split the string
+     * @return the address array
+     * @throws NumberFormatException in case an invalid port.
+     */
+    public static Address[] getAddressArray(String addressString,
+                                            final String regex,
+                                            final char subRegex) throws NumberFormatException {
+        String[] hosts = addressString.split(regex);
+        Address[] addresses = new Address[hosts.length];
+        for (int i = 0; i < hosts.length; i++) {
+            addresses[i] = new Address(
+                    hosts[i].substring(0, hosts[i].indexOf(subRegex)),
+                    Integer.parseInt(hosts[i].substring(hosts[i].indexOf(subRegex) + 1)));
+
+        }
+        return addresses;
+    }
+
+    /**
+     * Move elements between buffers. No need of additional synchronization locks,
+     * BlockingQueue#drainTo is thread safe, but not atomic, which is not a problem.
+     * See {@link BlockingQueue#drainTo(java.util.Collection, int)}
+     *
+     * @param src       source buffer
+     * @param dest      destination buffer
+     * @param blockSize blockSize of message bulk that need to move
+     * @throws AMQPTransportException in case of drains fails
+     */
+
+    public static void moveElements(BlockingQueue<AMQPTransportMessage> src,
+                                    List<AMQPTransportMessage> dest,
+                                    final int blockSize) throws AMQPTransportException {
+        try {
+            src.drainTo(dest, blockSize);
+        } catch (Exception e) {
+            throw new AMQPTransportException(e.getMessage(), e);
+        }
+    }
+
+    public static Map<String, String> parseAMQPUri(String amqpUri) throws AMQPTransportException {
+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&amp;transport.amqp.QueueName=producer
+
+        // amqp epr has the following format
+        // amqp://[string]?key1=value1&key2=value2&key3=value*
+        // valid epr definitions
+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer
+        // amqp://?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer
+        // amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer
+
+        // the parameter 'transport.amqp.QueueName' has high precedence over the value given between
+        // amqp:// and ?, if the parameter transport.amqp.QueueName is missing consider the value
+        // between amqp:// and ?, as the queue/exchange name
+
+        Map<String, String> params = new HashMap<String, String>();
+        String svcName = amqpUri.substring(7, amqpUri.indexOf('?'));
+        String kv = amqpUri.substring(amqpUri.indexOf('?') + 1);
+        String[] values = kv.split("&");
+
+        for (String str : values) {
+            str  = str.trim();
+            params.put(str.substring(0, str.indexOf('=')), str.substring(str.indexOf('=') + 1));
+        }
+        if (!params.keySet().contains(AMQPTransportConstant.PARAMETER_QUEUE_NAME)) {
+            params.put(AMQPTransportConstant.PARAMETER_QUEUE_NAME, svcName);
+        }
+
+        return params;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPOutTransportInfo.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPOutTransportInfo.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPOutTransportInfo.java	(revision 1507855)
@@ -0,0 +1,44 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import org.apache.axis2.transport.OutTransportInfo;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class AMQPOutTransportInfo implements OutTransportInfo {
+
+    private String contentType;
+
+    private Map<String, String> params = new HashMap<String, String>();
+
+    public AMQPOutTransportInfo(String contentType, String connFacName, String queueName) {
+        this.contentType = contentType;
+        params.put(AMQPTransportConstant.PROPERTY_AMQP_REPLY_TO, queueName);
+        params.put(AMQPTransportConstant.RESPONSE_CONNECTION_FACTORY_NAME, connFacName);
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public void setContentType(String contentType) {
+        this.contentType = contentType;
+    }
+
+    public Map<String, String> getParams() {
+        return params;
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportMessage.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportMessage.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportMessage.java	(revision 1507855)
@@ -0,0 +1,173 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import com.rabbitmq.client.BasicProperties;
+import com.rabbitmq.client.Envelope;
+import com.rabbitmq.client.QueueingConsumer;
+import org.apache.axis2.transport.base.BaseConstants;
+
+import java.util.Date;
+import java.util.Map;
+
+/**
+ * Represent a AMQP message transfer between the broker and the consumer/producer.
+ */
+public class AMQPTransportMessage {
+
+    private String soapAction;
+
+    private String messageId;
+
+    private String contentType;
+
+    private String contentEncoding;
+
+    private Integer deliveryMode;
+
+    private Integer priority;
+
+    private String correlationId;
+
+    private String replyTo;
+
+    private String expiration;
+
+    private Date timestamp;
+
+    private String type;
+
+    private String userId;
+
+    private String appId;
+
+    private String clusterId;
+
+    private Map<String, Object> headers;
+
+    /**
+     * Keeps a reference to the AMQP message.
+     */
+    private byte[] body;
+
+    private Envelope envelope;
+
+    private BasicProperties basicProperties;
+
+    private QueueingConsumer.Delivery delivery;
+
+    public AMQPTransportMessage(QueueingConsumer.Delivery delivery) {
+        this.delivery = delivery;
+        this.body = delivery.getBody();
+        this.envelope = delivery.getEnvelope();
+        this.basicProperties = delivery.getProperties();
+        this.messageId = delivery.getProperties().getMessageId();
+        this.contentType = delivery.getProperties().getContentType();
+        this.contentEncoding = delivery.getProperties().getContentEncoding();
+        this.deliveryMode = delivery.getProperties().getDeliveryMode();
+        this.priority = delivery.getProperties().getPriority();
+        this.correlationId = delivery.getProperties().getCorrelationId();
+        this.replyTo = delivery.getProperties().getReplyTo();
+        this.expiration = delivery.getProperties().getExpiration();
+        this.timestamp = delivery.getProperties().getTimestamp();
+        this.type = delivery.getProperties().getType();
+        this.userId = delivery.getProperties().getUserId();
+        this.appId = delivery.getProperties().getAppId();
+        this.clusterId = delivery.getProperties().getClusterId();
+        this.headers = delivery.getProperties().getHeaders();
+
+        if (delivery.getProperties().getHeaders() != null) {
+            this.soapAction = (String) delivery.getProperties().getHeaders().get(BaseConstants.SOAPACTION);
+        }
+    }
+
+    public AMQPTransportMessage(BasicProperties basicProperties, byte[] message) {
+        this.body = message;
+        this.basicProperties = basicProperties;
+    }
+
+    public String getSoapAction() {
+        return soapAction;
+    }
+
+    public String getMessageId() {
+        return messageId;
+    }
+
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public String getContentEncoding() {
+        return contentEncoding;
+    }
+
+
+    public Integer getDeliveryMode() {
+        return deliveryMode;
+    }
+
+    public Integer getPriority() {
+        return priority;
+    }
+
+    public String getCorrelationId() {
+        return correlationId;
+    }
+
+    public String getReplyTo() {
+        return replyTo;
+    }
+
+    public String getExpiration() {
+        return expiration;
+    }
+
+    public Date getTimestamp() {
+        return timestamp;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public String getUserId() {
+        return userId;
+    }
+
+    public String getAppId() {
+        return appId;
+    }
+
+    public String getClusterId() {
+        return clusterId;
+    }
+
+    public Map<String, Object> getHeaders() {
+        return headers;
+    }
+
+    public byte[] getBody() {
+        return body;
+    }
+
+    public QueueingConsumer.Delivery getDelivery() {
+        return delivery;
+    }
+
+    public Envelope getEnvelope() {
+        return envelope;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportListener.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportListener.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportListener.java	(revision 1507855)
@@ -0,0 +1,118 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.transport.base.AbstractTransportListenerEx;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;
+import org.apache.synapse.transport.amqp.pollingtask.AMQPTransportPollingTask;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+
+/**
+ * The AMQP transport receiver implementation.
+ */
+public class AMQPTransportListener extends AbstractTransportListenerEx<AMQPTransportEndpoint> {
+
+    /**
+     * The worker pool for polling tasks
+     */
+    private ScheduledExecutorService workerPool;
+
+    /**
+     * The connection factories defined in axis2.xml for transport receiver section.
+     */
+    private AMQPTransportConnectionFactoryManager connectionFactoryManager;
+
+    private ExecutorService connectionFactoryES;
+
+    @Override
+    protected void doInit() throws AxisFault {
+
+        // pass a custom executor service instance into the AMQP connection factory for better
+        // control see http://www.rabbitmq.com/api-guide.html
+        connectionFactoryES = Executors.newFixedThreadPool(
+                AMQPTransportUtils.getIntProperty(
+                        AMQPTransportConstant.PARAM_CONNECTION_FACTORY_POOL_SIZE,
+                        AMQPTransportConstant.CONNECTION_FACTORY_POOL_DEFAULT));
+
+        connectionFactoryManager = new AMQPTransportConnectionFactoryManager();
+        connectionFactoryManager.addConnectionFactories(
+                getTransportInDescription(), connectionFactoryES);
+
+        workerPool = Executors.newScheduledThreadPool(
+                AMQPTransportUtils.getIntProperty(AMQPTransportConstant.PARAM_WORKER_POOL_SIZE,
+                        AMQPTransportConstant.WORKER_POOL_DEFAULT));
+
+        log.info("AMQP transport listener initializing..");
+    }
+
+    @Override
+    protected AMQPTransportEndpoint createEndpoint() {
+        return new AMQPTransportEndpoint(workerPool, this);
+    }
+
+    @Override
+    protected void startEndpoint(AMQPTransportEndpoint endpoint) throws AxisFault {
+        AMQPTransportPollingTask ptm = endpoint.getPollingTask();
+        try {
+            ptm.start();
+        } catch (AMQPTransportException e) {
+            throw new AxisFault(e.getMessage(), e);
+        }
+
+        log.info("AMQP transport polling task started listen for service '" +
+                ptm.getServiceName() + "'");
+    }
+
+    @Override
+    protected void stopEndpoint(AMQPTransportEndpoint endpoint) {
+        AMQPTransportPollingTask ptm = endpoint.getPollingTask();
+        ptm.stop();
+
+        log.info("AMQP transport polling task stopped listen for service '" +
+                ptm.getServiceName() + "'");
+    }
+
+    @Override
+    public void stop() throws AxisFault {
+        super.stop();
+        workerPool.shutdown();
+        try {
+            connectionFactoryManager.shutDownConnectionFactories();
+        } catch (AMQPTransportException e) {
+            log.error("Error while shutting down connection factories, continue anyway...", e);
+        }
+        connectionFactoryES.shutdown();
+    }
+
+    /**
+     * Returns the connection factory with this name.
+     *
+     * @param name Name of the connection factory.
+     * @return The connection factory with this name.
+     * @throws AMQPTransportException throws in case of an error.
+     */
+    public AMQPTransportConnectionFactory getConnectionFactory(final String name)
+            throws AMQPTransportException {
+        if (connectionFactoryManager.getConnectionFactory(name) != null) {
+            return connectionFactoryManager.getConnectionFactory(name);
+        }
+        return connectionFactoryManager.getConnectionFactory(
+                AMQPTransportConstant.DEFAULT_CONNECTION_FACTORY_NAME);
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderFactory.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderFactory.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderFactory.java	(revision 1507855)
@@ -0,0 +1,154 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.transport.amqp.sendertask;
+
+import com.rabbitmq.client.Channel;
+import org.apache.axis2.AxisFault;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.amqp.AMQPTransportConstant;
+import org.apache.synapse.transport.amqp.AMQPTransportException;
+import org.apache.synapse.transport.amqp.AMQPTransportUtils;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactory;
+import org.apache.synapse.transport.amqp.connectionfactory.AMQPTransportConnectionFactoryManager;
+
+import java.io.IOException;
+import java.util.Map;
+
+public class AMQPSenderFactory {
+
+    private static Log log = LogFactory.getLog(AMQPSenderFactory.class);
+
+    public synchronized static AMQPSender createAMQPSender(
+            AMQPTransportConnectionFactoryManager connectionFactoryManager,
+            Map<String, String> params) throws IOException {
+
+        boolean isQueueDurable = false;
+
+        boolean isQueueRestricted = false;
+
+        boolean isQueueAutoDelete = true;
+
+        String exchangeType;
+
+        boolean isExchangeDurable = false;
+
+        boolean isExchangeAutoDelete = true;
+
+        boolean isInternalExchange = false;
+
+        String exchangeName;
+
+        Channel channel;
+
+        AMQPSender as = new AMQPSender();
+
+        AMQPTransportConnectionFactory connFac;
+
+        try {
+            connFac = connectionFactoryManager.getConnectionFactory(
+                    params.get(AMQPTransportConstant.PARAMETER_CONNECTION_FACTORY_NAME));
+            channel = connFac.getChannel();
+            as.setChannel(channel);
+        } catch (AMQPTransportException e) {
+            throw new AxisFault("Could not retrieve the channel", e);
+        }
+
+        exchangeName = params.get(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME);
+        if (exchangeName != null) {
+            as.setExchangeName(exchangeName);
+        }
+        exchangeType = params.get(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE);
+        if (exchangeType == null) {
+            exchangeType = "direct";
+        }
+
+        Map<String, String> conFacParam = connFac.getParameters();
+
+        Boolean value;
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_DURABLE, params, conFacParam);
+        if (value != null) {
+            isExchangeDurable = value.booleanValue();
+        }
+
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_IS_AUTO_DELETE, params, conFacParam);
+        if (value != null) {
+            isExchangeAutoDelete = value.booleanValue();
+        }
+
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, params, conFacParam);
+        if (value != null) {
+            isInternalExchange = value.booleanValue();
+        }
+
+        String queueName = params.get(AMQPTransportConstant.PARAMETER_QUEUE_NAME);
+        as.setQueueName(queueName);
+
+        String routingKey = AMQPTransportUtils.getOptionalStringParameter(
+                AMQPTransportConstant.PARAMETER_ROUTING_KEY, params, conFacParam);
+        if (routingKey != null) {
+            as.setRoutingKey(routingKey);
+        }
+
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, params, conFacParam);
+        if (value != null) {
+            isQueueDurable = value.booleanValue();
+        }
+
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_RESTRICTED, params, conFacParam);
+        if (value != null) {
+            isQueueRestricted = value.booleanValue();
+        }
+
+        value = AMQPTransportUtils.getOptionalBooleanParameter(
+                AMQPTransportConstant.PARAMETER_QUEUE_AUTO_DELETE, params, conFacParam);
+        if (value != null) {
+            isQueueAutoDelete = value.booleanValue();
+        }
+
+        /* use available, otherwise declare
+        if (exchangeName != null) {
+            channel.exchangeDeclare(
+                    exchangeName,
+                    exchangeType,
+                    isExchangeDurable,
+                    isExchangeAutoDelete,
+                    isInternalExchange,
+                    null);
+        } else {
+            channel.queueDeclare(queueName, isQueueDurable, isQueueRestricted, isQueueAutoDelete, null);
+        }
+        */
+
+        return as;
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSender.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSender.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSender.java	(revision 1507855)
@@ -0,0 +1,195 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.transport.amqp.sendertask;
+
+import com.rabbitmq.client.AMQP;
+import com.rabbitmq.client.Channel;
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.base.BaseUtils;
+import org.apache.axis2.util.MessageProcessorSelector;
+import org.apache.synapse.transport.amqp.AMQPTransportConstant;
+import org.apache.synapse.transport.amqp.AMQPTransportException;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Performs the actual sending of the AMQP message, this class is designed to be cached
+ * ,so it accepts the message context from out side rather than from the constructor.
+ *
+ */
+public class AMQPSender {
+
+    private Channel channel = null;
+
+    private String queueName = null;
+
+    private String exchangeName = null;
+
+    private String routingKey = null;
+
+    public void setChannel(Channel channel) {
+        this.channel = channel;
+    }
+
+    public void setExchangeName(String exchangeName) {
+        this.exchangeName = exchangeName;
+    }
+
+    public void setRoutingKey(String routingKey) {
+        this.routingKey = routingKey;
+    }
+
+    public void setQueueName(String queueName) {
+        this.queueName = queueName;
+    }
+
+    public Channel getChannel() {
+        return channel;
+    }
+
+    public void sendAMQPMessage(MessageContext mc, String correlationId, String replyTo)
+            throws AMQPTransportException, IOException {
+
+        OMOutputFormat format = BaseUtils.getOMOutputFormat(mc);
+        MessageFormatter formatter;
+        try {
+            formatter = MessageProcessorSelector.getMessageFormatter(mc);
+        } catch (AxisFault axisFault) {
+            throw new AxisFault("Unable to get the message formatter to use");
+        }
+
+        AMQP.BasicProperties.Builder builder = new
+                AMQP.BasicProperties().builder();
+
+        String msgId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_MESSAGE_ID);
+        if (msgId == null) {
+            msgId = mc.getMessageID();
+        }
+        builder.messageId(msgId);
+
+        String contentType = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CONTENT_TYPE);
+        if (contentType == null) {
+            contentType = getProperty(mc, Constants.Configuration.CONTENT_TYPE);
+        }
+        if (contentType != null) {
+            builder.contentType(contentType);
+        }
+
+        if (correlationId != null) {
+            builder.correlationId(correlationId);
+        }
+
+        if (replyTo != null) {
+            builder.replyTo(replyTo);
+        }
+
+        String encoding = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CONTENT_ENCODING);
+        if (encoding == null) {
+            encoding = getProperty(mc, Constants.Configuration.CHARACTER_SET_ENCODING);
+        }
+        if (encoding != null) {
+            builder.contentEncoding(encoding);
+        }
+
+        String deliverMode = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_DELIVER_MODE);
+        if (deliverMode != null) {
+            builder.deliveryMode(Integer.parseInt(deliverMode));
+        }
+
+        String priority = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_PRIORITY);
+        if (priority != null) {
+            builder.priority(Integer.parseInt(priority));
+        }
+
+
+        String expiration = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_EXPIRATION);
+        if (expiration != null) {
+            builder.expiration(expiration);
+        }
+
+        String timeStamp = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_TIME_STAMP);
+        if (timeStamp != null) {
+            builder.timestamp(new Date(Long.parseLong(timeStamp)));
+        }
+
+        String type = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_TYPE);
+        if (type != null) {
+            builder.type(type);
+        }
+
+        String userId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_USER_ID);
+        if (userId != null) {
+            builder.type(userId);
+        }
+
+        String appId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_APP_ID);
+        if (appId != null) {
+            builder.appId(appId);
+        }
+
+        String clusterId = getProperty(mc, AMQPTransportConstant.PROPERTY_AMQP_CLUSTER_ID);
+        if (clusterId != null) {
+            builder.clusterId(clusterId);
+        }
+
+        // add any custom properties set with AMQP_HEADER_* as headers
+        Map<String, Object> headers = new HashMap<String, Object>();
+        Map<String, Object> prop = mc.getProperties();
+        for (String key : prop.keySet()) {
+            if (key.contains(AMQPTransportConstant.AMQP_HEADER)) {
+                headers.put(key, prop.get(key));
+            }
+        }
+        builder.headers(headers);
+
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        formatter.writeTo(mc, format, out, false);
+        byte[] msg = out.toByteArray();
+
+        if (exchangeName != null) {
+            if (routingKey != null) {
+                channel.basicPublish(exchangeName, routingKey, builder.build(), msg);
+            } else {
+                channel.basicPublish(exchangeName, "", builder.build(), msg);
+            }
+        } else {
+            channel.basicPublish("", queueName, builder.build(), msg);
+        }
+    }
+
+    private String getProperty(MessageContext mc, String key) {
+        return (String) mc.getProperty(key);
+    }
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderCache.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderCache.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/sendertask/AMQPSenderCache.java	(revision 1507855)
@@ -0,0 +1,62 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.transport.amqp.sendertask;
+
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Simple cache for caching AMQP senders
+ *
+ */
+public class AMQPSenderCache {
+
+    private ConcurrentMap<Integer, AMQPSender> cache;
+
+    public AMQPSenderCache(ConcurrentMap<Integer, AMQPSender> cache) {
+        this.cache = cache;
+    }
+
+    public boolean hit(Integer hashKey) {
+        return cache.containsKey(hashKey);
+    }
+
+    public void add(Integer hashKey, AMQPSender entry) {
+        cache.put(hashKey, entry);
+    }
+
+    public void remove(Integer hashKey) {
+        cache.remove(hashKey);
+    }
+
+    public AMQPSender get(Integer hashKey) {
+        return cache.get(hashKey);
+    }
+
+    public void clean() {
+        cache.clear();
+    }
+}
Index: java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportConstant.java
===================================================================
--- java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportConstant.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/main/java/org/apache/synapse/transport/amqp/AMQPTransportConstant.java	(revision 1507855)
@@ -0,0 +1,346 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.transport.amqp;
+
+/**
+ * Constant decelerations for the AMQP transport.
+ */
+public final class AMQPTransportConstant {
+
+    /**
+     * The transport prefix for AMQP transport.
+     */
+    public static final String AMQP_TRANSPORT_PREFIX = "amqp://";
+
+    /**
+     * The default connection factory name.
+     */
+    public static final String DEFAULT_CONNECTION_FACTORY_NAME = "default";
+
+    /**
+     * The parameter to specify the Uri of the form amqp://userName:password@hostName:portNumber/virtualHost.
+     */
+    public static final String PARAMETER_CONNECTION_URI = "transport.amqp.Uri";
+
+
+    /**
+     * The list of broker of the form, host1:port1,host2:port2... which will be used as the address array in AMQP
+     * connection to the broker.
+     */
+    public static final String PARAMETER_BROKER_LIST = "transport.amqp.BrokerList";
+
+
+    /**
+     * The name of the exchange to be used.
+     */
+    public static final String PARAMETER_EXCHANGE_NAME = "transport.amqp.ExchangeName";
+
+
+    /**
+     * The durability of the exchange. One of durable, transient or auto-deleted.
+     */
+    public static final String PARAMETER_EXCHANGE_IS_DURABLE = "transport.amqp.IsExchangeDurable";
+
+
+    /**
+     * Should the exchange be deleted if it is no longer in use
+     */
+    public static final String PARAMETER_EXCHANGE_IS_AUTO_DELETE = "transport.amqp.IsExchangeAutoDelete";
+
+    /**
+     * The channel pre fetch size for fair dispatch
+     */
+    public static final String PARAMETER_CHANNEL_PREFETCH_SIZE = "transport.amqp.ChannelPreFetchSize";
+
+    /**
+     * The channel prefetch count for fair dispatch
+     */
+    public static final String PARAMETER_CHANNEL_PREFETCH_COUNT = "transport.amqp.ChannelPreFetchCountSize";
+
+    /**
+     * Should the configuration be used in globally ?
+     */
+    public static final String PARAMETER_CHANNEL_QOS_GLOBAL = "transport.amqp.IsQoSGlobally";
+
+    /**
+     * The type of the exchange. One of fanout, direct, header or topic.
+     */
+    public static final String PARAMETER_EXCHANGE_TYPE = "transport.amqp.ExchangeType";
+
+
+    /**
+     * Should the exchange be declared as internal? One of true of false.
+     */
+    public static final String PARAMETER_EXCHANGE_INTERNAL = "transport.amqp.ExchangeInternal";
+
+
+    /**
+     * The name of the exchange that the publisher/consumer should publish/consume message to.
+     */
+    public static final String PARAMETER_BIND_EXCHANGE = "transport.amqp.BindExchange";
+
+
+    /**
+     * The comma separated binding keys this queue should be bound into exchange.
+     */
+    public static final String PARAMETER_BINDING_KEYS = "transport.amqp.BindingKeys";
+
+
+    /**
+     * The routing key to be used by the publisher
+     */
+    public static final String PARAMETER_ROUTING_KEY = "transport.amqp.RoutingKey";
+
+    /**
+     * True if requesting a mandatory publishing.
+     */
+    public static final String PARAMETER_PUBLISHER_MANDATORY_PUBLISH = "transport.amqp.MandatoryPublish";
+
+
+    /**
+     * True if requesting an immediate publishing.
+     */
+    public static final String PARAMETER_PUBLISHER_IMMEDIATE_PUBLISH = "transport.amqp.ImmediatePublish";
+
+
+    /**
+     * Use transactions at consumer side if set to true. By default this will be considered false
+     * and explicit acknowledgement will be done
+     */
+    public static final String PARAMETER_CONSUMER_TX = "transport.amqp.ConsumerTx";
+
+    /**
+     * Use transactions at producer side, possible values are lwpc(light weight publisher confirm),
+     * tx(transaction). tx should be able to set per message basis
+     */
+    public static final String PROPERTY_PRODUCER_TX = "AMQP_PRODUCER_TX";
+
+    /**
+     * The name of the queue
+     */
+    public static final String PARAMETER_QUEUE_NAME = "transport.amqp.QueueName";
+
+    /**
+     * True if the queue is durable
+     */
+    public static final String PARAMETER_QUEUE_DURABLE = "transport.amqp.IsQueueDurable";
+
+
+    /**
+     * True of the queue is restricted(only within this connection)
+     */
+    public static final String PARAMETER_QUEUE_RESTRICTED = "transport.amqp.IsQueueRestricted";
+
+
+    /**
+     * True if the queue should be auto deleted
+     */
+    public static final String PARAMETER_QUEUE_AUTO_DELETE = "transport.amqp.IsQueueAutoDelete";
+
+
+    /**
+     * True if the polling task should wait until the she processed the accepted message. This can be used
+     * in conjunction with a single thread polling task(in the whole transport, i.e. only a single AMQP proxy per flow)
+     * to achieve in order delivery.
+     */
+    public static final String PARAMETER_OPERATE_ON_BLOCKING_MODE = "transport.amqp.OperateOnBlockingMode";
+
+
+    /**
+     * If a polling task encounter an exception due to some reason(most probably due to broker outage) the number of
+     * milliseconds it should be suspended before next re-try.
+     */
+    public static final String PARAMETER_INITIAL_RE_CONNECTION_DURATION = "transport.amqp.InitialReconnectDuration";
+
+    /**
+     * If the polling task fails again after the initial re-connection duration
+     * {@link AMQPTransportConstant#PARAMETER_INITIAL_RE_CONNECTION_DURATION}
+     * next suspend duration will be calculated using this
+     * (PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR * PARAMETER_INITIAL_RE_CONNECTION_DURATION).
+     */
+    public static final String PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR = "transport.amqp.ReconnectionProgressionFactor";
+
+
+    /**
+     * The maximum duration to suspend the polling task in case of an error. The current suspend duration will reach this
+     * value by following the series,
+     * PARAMETER_RE_CONNECTION_PROGRESSION_FACTOR * PARAMETER_INITIAL_RE_CONNECTION_DURATION. This upper bound is there
+     * because nobody wants to wait a long time until the next re-try if the broker is alive.
+     */
+    public static final String PARAMETER_MAX_RE_CONNECTION_DURATION = "transport.amqp.MaximumReconnectionDuration";
+
+
+    /**
+     * The connection factory to be used either with consumer or producer.
+     */
+    public static final String PARAMETER_CONNECTION_FACTORY_NAME = "transport.amqp.ConnectionFactoryName";
+
+    /**
+     * In a two-way scenario which connection factory of the senders' should be used to send the response
+     */
+    public static final String PARAMETER_RESPONSE_CONNECTION_FACTORY_NAME =
+            "transport.amqp.ResponseConnectionFactoryName";
+
+
+    /**
+     * The initial delay(in milliseconds) that the polling task should delay before initial attempt.
+     * http://docs.oracle.com/javase/6/docs/api/index.html?java/util/concurrent/ScheduledExecutorService.html
+     */
+    public static final String PARAMETER_SCHEDULED_TASK_INITIAL_DELAY =
+            "transport.amqp.ScheduledTaskInitialDelay";
+
+    /**
+     * The delay(in milliseconds) that the polling task should delay before next attempt.
+     * http://docs.oracle.com/javase/6/docs/api/index.html?java/util/concurrent/ScheduledExecutorService.html
+     */
+    public static final String PARAMETER_SCHEDULED_TASK_DELAY = "transport.amqp.ScheduledTaskDelay";
+
+    /**
+     * The time unit which should use to calculate,
+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_INITIAL_DELAY} and
+     * {@link AMQPTransportConstant#PARAMETER_SCHEDULED_TASK_DELAY}.
+     */
+    public static final String PARAMETER_SCHEDULED_TASK_TIME_UNIT = "transport.amqp.ScheduledTaskTimeUnit";
+
+    /**
+     * Number of concurrent consumers per polling task.
+     */
+    public static final String PARAMETER_NO_OF_CONCURRENT_CONSUMERS = "transport.amqp.NoOfConcurrentConsumers";
+
+    /**
+     * Number of dispatching task to use any request messages to actual processing task.
+     */
+    public static final String PARAMETER_DISPATCHING_TASK_SIZE = "transport.amqp.NoOfDispatchingTask";
+
+    /**
+     * Use the given channel number if possible. See
+     * http://www.rabbitmq.com/releases/rabbitmq-java-client/v3.0.1/rabbitmq-java-client-javadoc-3.0.1/com/rabbitmq/client/Connection.html#createChannel(int)
+     */
+    public static final String PARAMETER_AMQP_CHANNEL_NUMBER = "transport.amqp.ChannelNumber";
+
+    /**
+     * Configure the content type as a service parameter
+     */
+    public static final String PARAMETER_CONFIGURED_CONTENT_TYPE = "transport.amqp.ContentType";
+
+    /**
+     * Message context property to set the AMQP message content type.
+     */
+    public static final String PROPERTY_AMQP_CONTENT_TYPE = "AMQP_CONTENT_TYPE";
+
+    /**
+     * Message context property to set the AMQP message encoding.
+     */
+    public static final String PROPERTY_AMQP_CONTENT_ENCODING = "AMQP_CONTENT_ENCODING";
+
+
+    public static final String AMQP_HEADER = "AMQP_HEADER";
+
+    /**
+     * Message context property to set the AMQP message delivery mode.
+     */
+    public static final String PROPERTY_AMQP_DELIVER_MODE = "AMQP_DELIVERY_MODE";
+
+    /**
+     * Message context property to set the AMQP message priority.
+     */
+    public static final String PROPERTY_AMQP_PRIORITY = "AMQP_PRIORITY";
+
+    /**
+     * Message context property to set the AMQP message correlation id.
+     */
+    public static final String PROPERTY_AMQP_CORRELATION_ID = "AMQP_CORRELATION_ID";
+
+
+    /**
+     * Message context property to set the AMQP message reply to header.
+     */
+    public static final String PROPERTY_AMQP_REPLY_TO = "AMQP_REPLY_TO";
+
+
+    /**
+     * Message context property to set the AMQP expiration.
+     */
+    public static final String PROPERTY_AMQP_EXPIRATION = "AMQP_EXPIRATION";
+
+
+    /**
+     * Message context property to set the message id of the AMQP message.
+     */
+    public static final String PROPERTY_AMQP_MESSAGE_ID = "AMQP_MESSAGE_ID";
+
+
+    /**
+     * Message context property to set the timestamp of the AMQP message.
+     */
+    public static final String PROPERTY_AMQP_TIME_STAMP = "AMQP_TIME_STAMP";
+
+
+    /**
+     * Message context property to set the type of the AMQP message.
+     */
+    public static final String PROPERTY_AMQP_TYPE = "AMQP_TYPE";
+
+
+    /**
+     * Message context property to set the AMQP user id.
+     */
+    public static final String PROPERTY_AMQP_USER_ID = "AMQP_USER_ID";
+
+
+    /**
+     * Message context property to set the AMQP app id.
+     */
+    public static final String PROPERTY_AMQP_APP_ID = "AMQP_APP_ID";
+
+
+    /**
+     * Message context property to set the AMQP cluster id.
+     */
+    public static final String PROPERTY_AMQP_CLUSTER_ID = "AMQP_CLUSTER_ID";
+
+
+    /**
+     * Configure the executor service worker pool size.
+     */
+
+    public static final String PARAM_CONNECTION_FACTORY_POOL_SIZE = "connection-factory-pool-size";
+
+    public static final int CONNECTION_FACTORY_POOL_DEFAULT = 20;
+
+    public static final String PARAM_RESPONSE_HANDLING_POOL_SIZE = "response-handling-pool-size";
+
+    public static final int RESPONSE_HANDLING_POOL_DEFAULT = 20;
+
+    public static final String PARAM_WORKER_POOL_SIZE = "worker-pool-size";
+
+    public static final int WORKER_POOL_DEFAULT = 1000;
+
+    public static final String PARAM_SEMAPHORE_TIME_OUT = "semaphore-time-out";
+
+    public static final String AMQP_CORRELATION_ID = "AMQP_CORRELATION_ID";
+
+    public static final String AMQP_TRANSPORT_BUFFER_KEY = "AMQP_TRANSPORT_BUFFER_KEY";
+
+    public static final String AMQP_USE_TX = "tx";
+
+    public static final String AMQP_USE_LWPC = "lwpc";
+
+    public static final String DEFAULT_CONTENT_TYPE = "application/xml";
+
+    public static final String ROUTING_KEY_DELIMITER = ",";
+
+    public static final String RESPONSE_CONNECTION_FACTORY_NAME = "RESPONSE_CONNECTION_FACTORY_NAME";
+
+}
\ No newline at end of file
Index: java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPConsumerClient.java
===================================================================
--- java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPConsumerClient.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPConsumerClient.java	(revision 1507855)
@@ -0,0 +1,34 @@
+package org.apache.synapse.tranport.amqp;
+
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+import com.rabbitmq.client.QueueingConsumer;
+
+import java.io.IOException;
+
+/**
+ * The consumer client for AMQP transport
+ */
+public class AMQPConsumerClient {
+
+    public static final String QUEUE_NAME = "ProducerProxy";
+
+    public static void main(String[] args) throws IOException, InterruptedException {
+
+        ConnectionFactory factory = new ConnectionFactory();
+        factory.setHost("localhost");
+        Connection connection = factory.newConnection();
+
+        Channel channel = connection.createChannel();
+        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
+
+        QueueingConsumer consumer = new QueueingConsumer(channel);
+        channel.basicConsume(QUEUE_NAME, true, consumer);
+        System.out.println("Waiting for message on queue '" + QUEUE_NAME + "'");
+
+        QueueingConsumer.Delivery delivery = consumer.nextDelivery();
+        String message = new String(delivery.getBody());
+        System.out.println("[x] received '" + message + "'");
+    }
+}
Index: java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTransportUtilsTest.java
===================================================================
--- java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTransportUtilsTest.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTransportUtilsTest.java	(revision 1507855)
@@ -0,0 +1,155 @@
+/*
+ * Copyright WSO2, Inc. (http://wso2.com)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.synapse.tranport.amqp;
+
+import com.rabbitmq.client.Address;
+import junit.framework.TestCase;
+import org.apache.axis2.description.AxisService;
+import org.apache.synapse.transport.amqp.AMQPTransportConstant;
+import org.apache.synapse.transport.amqp.AMQPTransportUtils;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class AMQPTransportUtilsTest extends TestCase {
+
+    private Map<String, String> svcMap = new HashMap<String, String>();
+
+    private Map<String, String> cfMap = new HashMap<String, String>();
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        // Do not edit the values, test may fail!
+        svcMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, "directExchange");
+        svcMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, "true");
+        svcMap.put(AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, "2");
+
+        cfMap.put(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, "direct");
+        cfMap.put(AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, "true");
+        cfMap.put(AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, "10");
+    }
+
+    public void testGetStringProperty() throws Exception {
+        assertEquals("In valid string value received,",
+                "username@domain.com", AMQPTransportUtils.getStringProperty("string", null));
+    }
+
+    public void testGetIntProperty() throws Exception {
+        assertEquals("In valid int value received,", 10, AMQPTransportUtils.getIntProperty("int", -1));
+    }
+
+    public void testGetLongProperty() throws Exception {
+        assertEquals("In valid long value received,", 13, AMQPTransportUtils.getLongProperty("long", -1));
+    }
+
+    public void testGetDoubleProperty() throws Exception {
+        assertEquals("In valid double value received,", 14.4, AMQPTransportUtils.getDoubleProperty("double", -1));
+    }
+
+    public void testGetBooleanProperty() throws Exception {
+        assertEquals(
+                "In valid boolean value received,",
+                false,
+                AMQPTransportUtils.getBooleanProperty("boolean2", true).booleanValue());
+
+        assertEquals(
+                "In valid boolean value received,",
+                true,
+                AMQPTransportUtils.getBooleanProperty("boolean1", false).booleanValue());
+    }
+
+    public void testGetServiceStringParameters() throws Exception {
+        AxisService service = new AxisService();
+        service.addParameter("param1", "value1");
+
+        Map<String, String> paramMap =
+                AMQPTransportUtils.getServiceStringParameters(service.getParameters());
+        assertEquals("In valid parameter for key param1", "value1", paramMap.get("param1"));
+    }
+
+    public void testGetOptionalStringParameter() throws Exception {
+        assertEquals(
+                "In valid value received",
+                svcMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_NAME),
+                AMQPTransportUtils.getOptionalStringParameter(
+                        AMQPTransportConstant.PARAMETER_EXCHANGE_NAME, svcMap, cfMap));
+
+        assertEquals(
+                "In valid value received",
+                cfMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE),
+                AMQPTransportUtils.getOptionalStringParameter(
+                        AMQPTransportConstant.PARAMETER_EXCHANGE_TYPE, svcMap, cfMap));
+    }
+
+    public void testGetOptionalBooleanParameter() throws Exception {
+        assertEquals("Invalid value",
+                Boolean.valueOf(svcMap.get(AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL)),
+                AMQPTransportUtils.getOptionalBooleanParameter(
+                        AMQPTransportConstant.PARAMETER_EXCHANGE_INTERNAL, svcMap, cfMap));
+
+        assertEquals("Invalid value",
+                Boolean.valueOf(cfMap.get(AMQPTransportConstant.PARAMETER_QUEUE_DURABLE)),
+                AMQPTransportUtils.getOptionalBooleanParameter(
+                        AMQPTransportConstant.PARAMETER_QUEUE_DURABLE, svcMap, cfMap));
+    }
+
+    public void testGetOptionalIntParameter() throws Exception {
+        assertEquals("Invalid value",
+                Integer.parseInt(cfMap.get(AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION)),
+                AMQPTransportUtils.getOptionalIntParameter(
+                        AMQPTransportConstant.PARAMETER_INITIAL_RE_CONNECTION_DURATION, svcMap, cfMap).intValue());
+
+        assertEquals("Invalid value",
+                Integer.parseInt(svcMap.get(AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS)),
+                AMQPTransportUtils.getOptionalIntParameter(
+                        AMQPTransportConstant.PARAMETER_NO_OF_CONCURRENT_CONSUMERS, svcMap, cfMap).intValue());
+    }
+
+    public void testGetBindingKeys() throws Exception {
+        String keys[] = AMQPTransportUtils.split("ERROR,WARN,DEBUG", ",");
+        assertEquals("Invalid value", "ERROR", keys[0]);
+        assertEquals("Invalid value", "WARN", keys[1]);
+        assertEquals("Invalid value", "DEBUG", keys[2]);
+    }
+
+    public void testGetAddressArray() throws Exception {
+        try {
+            Address[] addresses1 = AMQPTransportUtils.getAddressArray(
+                    "wso2.org:443,rajika.org:25", ",", ':');
+            assertEquals("Invalid value", "wso2.org", addresses1[0].getHost());
+            assertEquals("Invalid value", 25, addresses1[1].getPort());
+            assertEquals("Invalid value", "rajika.org", addresses1[1].getHost());
+        } catch (NumberFormatException e) {
+            fail("Should not throw an exception, " + e.getMessage());
+        }
+
+        try {
+            AMQPTransportUtils.getAddressArray(
+                    "hostName1:443,hostName2:25,hostName3:invalidPort", ",", ':');
+            fail("Should not come here because above should throw an exception");
+        } catch (NumberFormatException e) {
+            // expected
+        }
+    }
+
+    public void testParseAMQPUri() throws Exception {
+        String url = "amqp://SimpleStockQuoteService?transport.amqp.ConnectionFactoryName=producer&transport.amqp.QueueName=producer" ;
+        Map<String, String> uriParam = AMQPTransportUtils.parseAMQPUri(url);
+        assertEquals("Invalid value", "producer", uriParam.get(AMQPTransportConstant.PARAMETER_QUEUE_NAME));
+
+    }
+}
Index: java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTwoWayProducerClient.java
===================================================================
--- java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTwoWayProducerClient.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPTwoWayProducerClient.java	(revision 1507855)
@@ -0,0 +1,109 @@
+/*
+ * ====================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ */
+package org.apache.synapse.tranport.amqp;
+
+import com.rabbitmq.client.*;
+
+import java.io.IOException;
+
+/**
+ * A request/response producer client
+ * author : rajika.kumarasiri@gmail.com
+ */
+public class AMQPTwoWayProducerClient {
+
+    private static final String MESSAGE =
+            "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                    "   <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n" +
+                    "      <soapenv:Header xmlns:wsa=\"http://www.w3.org/2005/08/addressing\">\n" +
+                    "         <wsa:To>http://localhost:8281/services/StockQuoteProxy</wsa:To>\n" +
+                    "         <wsa:MessageID>urn:uuid:44d578a8-20e9-4ee4-8407-9b0a0768e5a8</wsa:MessageID>\n" +
+                    "         <wsa:Action>urn:getQuote</wsa:Action>\n" +
+                    "      </soapenv:Header>\n" +
+                    "      <soapenv:Body>\n" +
+                    "         <m0:getQuote xmlns:m0=\"http://services.samples\">\n" +
+                    "            <m0:request>\n" +
+                    "               <m0:symbol>IBM</m0:symbol>\n" +
+                    "            </m0:request>\n" +
+                    "         </m0:getQuote>\n" +
+                    "      </soapenv:Body>\n" +
+                    "   </soapenv:Envelope>";
+
+    private static final String MESSAGE2 =
+            "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                    "         <m0:getQuote xmlns:m0=\"http://services.samples\">\n" +
+                    "            <m0:request>\n" +
+                    "               <m0:symbol>IBM</m0:symbol>\n" +
+                    "            </m0:request>\n" +
+                    "         </m0:getQuote>";
+
+    public static void main(String[] args) throws IOException, InterruptedException {
+
+        ConnectionFactory factory = new ConnectionFactory();
+        factory.setHost("localhost");
+        Connection connection = factory.newConnection();
+
+        Channel channel = connection.createChannel();
+
+        AMQPTwoWayProducerClient.produceAndConsume(
+                MESSAGE2, channel, "consumer", "consumerReply");
+
+        channel.close();
+        connection.close();
+
+    }
+
+
+    private static void produceAndConsume(
+            String message,
+            Channel channel,
+            String requestQueueName,
+            String replyQueueName) throws IOException, InterruptedException {
+
+        AMQP.BasicProperties.Builder builder = new
+                AMQP.BasicProperties().builder();
+        String restCoID = Math.random() + "";
+        builder.correlationId(restCoID);
+        System.out.println("Request correlation Id : " + restCoID);
+        builder.replyTo(replyQueueName);
+        channel.basicPublish("", requestQueueName, builder.build(), message.getBytes());
+        System.out.println("[x] sent to '" + requestQueueName + "' the message '\n" + message + "'");
+
+        channel.queueDeclare(replyQueueName, false, false, false, null);
+        QueueingConsumer consumer = new QueueingConsumer(channel);
+        channel.basicConsume(replyQueueName, true, consumer);
+        System.out.println("Waiting for message on queue '" + replyQueueName + "'");
+        while (true) {
+            QueueingConsumer.Delivery delivery = consumer.nextDelivery();
+            String replyMessage = new String(delivery.getBody());
+            System.out.println("[x] received '" + replyMessage + "'");
+            System.out.println("Response correlation Id : " + delivery.getProperties().getCorrelationId());
+            break;
+
+        }
+    }
+}
Index: java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPProducerClient.java
===================================================================
--- java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPProducerClient.java	(nonexistent)
+++ java/modules/transports/optional/amqp/src/test/java/org/apache/synapse/tranport/amqp/AMQPProducerClient.java	(revision 1507855)
@@ -0,0 +1,75 @@
+package org.apache.synapse.tranport.amqp;
+
+import com.rabbitmq.client.Channel;
+import com.rabbitmq.client.Connection;
+import com.rabbitmq.client.ConnectionFactory;
+
+import java.io.IOException;
+
+/**
+ * The producer for AMQP transport.
+ */
+public class AMQPProducerClient {
+
+    //    private static final String QUEUE_NAME = "ConsumerTxProxy";
+//    private static final String QUEUE_NAME = "worker-queue";
+    private static final String QUEUE_NAME = "ProducerProxy";
+
+    private static final String MESSAGE =
+            "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                    "   <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n" +
+                    "      <soapenv:Header xmlns:wsa=\"http://www.w3.org/2005/08/addressing\">\n" +
+                    "         <wsa:To>http://localhost:8281/services/StockQuoteProxy</wsa:To>\n" +
+                    "         <wsa:MessageID>urn:uuid:44d578a8-20e9-4ee4-8407-9b0a0768e5a8</wsa:MessageID>\n" +
+                    "         <wsa:Action>urn:getQuote</wsa:Action>\n" +
+                    "      </soapenv:Header>\n" +
+                    "      <soapenv:Body>\n" +
+                    "         <m0:getQuote xmlns:m0=\"http://services.samples\">\n" +
+                    "            <m0:request>\n" +
+                    "               <m0:symbol>IBM</m0:symbol>\n" +
+                    "            </m0:request>\n" +
+                    "         </m0:getQuote>\n" +
+                    "      </soapenv:Body>\n" +
+                    "   </soapenv:Envelope>";
+
+    private static final String MESSAGE2 =
+            "<?xml version='1.0' encoding='UTF-8'?>\n" +
+                    "         <m0:getQuote xmlns:m0=\"http://services.samples\">\n" +
+                    "            <m0:request>\n" +
+                    "               <m0:symbol>IBM</m0:symbol>\n" +
+                    "            </m0:request>\n" +
+                    "         </m0:getQuote>";
+
+    public static void main(String[] args) throws IOException {
+
+        ConnectionFactory factory = new ConnectionFactory();
+        factory.setHost("localhost");
+        Connection connection = factory.newConnection();
+
+        Channel channel = connection.createChannel();
+
+        //channel.queueDeclare(QUEUE_NAME, false, false, false, null);
+        AMQPProducerClient.produce(MESSAGE2, channel, QUEUE_NAME);
+//        AMQPProducerClient.publish(MESSAGE2, channel, "subscriber-exchange");
+//        AMQPProducerClient.route(MESSAGE2, channel, "route-exchange", "fatal");
+//        AMQPProducerClient.route(MESSAGE2, channel, "topic-exchange", "kern.critical");
+
+        channel.close();
+        connection.close();
+
+    }
+
+
+    private static void produce(String message, Channel channel, String queueName) throws IOException {
+        channel.basicPublish("", queueName, null, message.getBytes());
+    }
+
+    private static void publish(String message, Channel channel, String exchangeName) throws IOException {
+        channel.basicPublish(exchangeName, "", null, message.getBytes());
+    }
+
+    private static void route(String message, Channel channel, String exchangeName, String routeKey) throws IOException {
+        channel.basicPublish(exchangeName, routeKey, null, message.getBytes());
+    }
+
+}
Index: java/modules/transports/optional/amqp/pom.xml
===================================================================
--- java/modules/transports/optional/amqp/pom.xml	(nonexistent)
+++ java/modules/transports/optional/amqp/pom.xml	(revision 1507855)
@@ -0,0 +1,94 @@
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+	<parent>
+        <groupId>org.apache.synapse</groupId>
+        <artifactId>synapse-transports</artifactId>
+        <version>2.2.0-SNAPSHOT</version>
+        <relativePath>../../pom.xml</relativePath>
+    </parent>
+
+    <groupId>org.apache.synapse</groupId>
+    <artifactId>synapse-amqp-transport</artifactId>
+    <name>Apache Synapse - AMQP transport</name>
+    <packaging>bundle</packaging>
+    <url>http://maven.apache.org</url>
+
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+    </properties>
+
+
+	<scm>
+        <connection>scm:svn:http://svn.apache.org/repos/asf/synapse/trunk/java/modules/transports/optional/amqp</connection>
+        <developerConnection>scm:svn:https://svn.apache.org/repos/asf/synapse/trunk/java/modules/transports/optional/amqp</developerConnection>
+        <url>http://svn.apache.org/viewvc/synapse/trunk/java/modules/transports/core/optional/amqp</url>
+    </scm>
+
+    <build>
+        <plugins>
+
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <version>2.3.2</version>
+                <configuration>
+                    <source>1.6</source>
+                    <target>1.6</target>
+                </configuration>
+            </plugin>
+
+            <plugin>
+                <groupId>org.apache.felix</groupId>
+                <artifactId>maven-bundle-plugin</artifactId>
+                <version>1.4.0</version>
+                <extensions>true</extensions>
+                <configuration>
+                    <instructions>
+                        <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>
+                        <Bundle-Name>${project.artifactId}</Bundle-Name>
+                        <Private-Package></Private-Package>
+                        <Export-Package>org.apache.synapse.transport.amqp.*</Export-Package>
+                        <Import-Package>
+                            *;resolution:=optional
+                        </Import-Package>
+                        <DynamicImport-Package>*</DynamicImport-Package>
+                    </instructions>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+    <dependencies>
+        <dependency>
+            <groupId>junit</groupId>
+            <artifactId>junit</artifactId>
+            <version>3.8.1</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.rabbitmq</groupId>
+            <artifactId>amqp-client</artifactId>
+            <version>3.1.2</version>
+            <scope>compile</scope>
+            <!-- put a compile time dependency due to license -->
+        </dependency>
+        <dependency>
+            <groupId>org.apache.axis2</groupId>
+            <artifactId>axis2-transport-base</artifactId>
+            <version>${axis2.transport.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.axis2</groupId>
+            <artifactId>axis2-kernel</artifactId>
+            <version>${axis2.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.axis2</groupId>
+            <artifactId>axis2-transport-http</artifactId>
+            <version>${axis2.version}</version>
+        </dependency>
+    </dependencies>
+</project>
Index: java/repository/conf/axis2.xml
===================================================================
--- java/repository/conf/axis2.xml	(revision 1507854)
+++ java/repository/conf/axis2.xml	(revision 1507855)
@@ -266,6 +266,22 @@
     <!--Uncomment this for UDP transport support
     <transportReceiver name="udp" class="org.apache.axis2.transport.udp.UDPListener"/>-->
 
+    <!--Uncomment this for AMQP transport support-->
+    <!--<transportReceiver name="amqp" class="org.apache.synapse.transport.amqp.AMQPTransportListener">-->
+        <!--<parameter name="consumer" locked="false">-->
+            <!--<parameter name="transport.amqp.Uri" locked="false">amqp://localhost:5672</parameter>-->
+        <!--</parameter>-->
+        <!--<parameter name="worker-queue" locked="false">-->
+            <!--<parameter name="transport.amqp.Uri" locked="false">amqp://localhost:5672</parameter>-->
+            <!--<parameter name="transport.amqp.ChannelPreFetchCountSize" locked="false">1</parameter>-->
+        <!--</parameter>-->
+        <!--<parameter name="subscriber" locked="false">-->
+            <!--<parameter name="transport.amqp.Uri" locked="false">amqp://localhost:5672</parameter>-->
+        <!--</parameter>-->
+    <!--</transportReceiver>-->
+
+    <!--Uncomment this for AMQP transport support -->
+
     <!-- ================================================= -->
     <!-- Transport Outs -->
     <!-- ================================================= -->
@@ -348,6 +364,18 @@
     <!--Uncomment this for UDP transport support
     <transportSender name="udp" class="org.apache.axis2.transport.udp.UDPSender"/>-->
 
+
+    <!--Uncomment this for AMQP transport support-->
+    <!--<transportSender name="amqp" class="org.apache.synapse.transport.amqp.AMQPTransportSender">-->
+        <!--<parameter name="producer" locked="false">-->
+            <!--<parameter name="transport.amqp.Uri" locked="false">amqp://localhost:5672</parameter>-->
+        <!--</parameter>-->
+        <!--<parameter name="publisher" locked="false">-->
+            <!--<parameter name="transport.amqp.Uri" locked="false">amqp://localhost:5672</parameter>-->
+        <!--</parameter>-->
+    <!--</transportSender>-->
+
+
     <!-- ================================================= -->
     <!-- Global Modules  -->
     <!-- ================================================= -->
-*-*-*-
Message: added amqp transport.
-*-*-*-
When: 2013-07-28 17:35:59 -0400 
-*-*-*-
Who: rajikak
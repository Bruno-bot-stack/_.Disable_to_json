Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HttpGetRequestProcessor.java	(revision 1502663)
@@ -0,0 +1,65 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpResponse;
+import org.apache.http.nio.NHttpServerConnection;
+
+import java.io.OutputStream;
+
+/**
+ * This Passthrough transport level interface is used for plugging in different implementations for special processing of some
+ * HTTP GET requests.
+ * <p/>
+ * e.g. ?wsdl, ?wsdl2 etc.
+ * <p/>
+ * If you need to handle a special HTTP GET request, you have to write an implementation of this
+ * interface.
+ */
+public interface HttpGetRequestProcessor {
+    /**
+     * Initialize the HttpGetProcessor
+     * @param cfgCtx servers configuration context
+     * @param serverHandler dispatching handler
+     * @throws AxisFault if an error occurs
+     */
+    void init(ConfigurationContext cfgCtx, SourceHandler handler) throws AxisFault;
+
+    /**
+     * Process the HTTP GET request.
+     *
+     * @param request       The HttpRequest
+     * @param response      The HttpResponse
+     * @param msgContext    The MessageContext
+     * @param conn          The NHttpServerConnection
+     * @param os            The OutputStream
+     * @param isRestDispatching Rest dispatching
+     */
+    void process(HttpRequest request,
+                 HttpResponse response,
+                 MessageContext msgContext,
+                 NHttpServerConnection conn,
+                 OutputStream os,
+                 boolean isRestDispatching);
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceHandler.java	(revision 1502663)
@@ -0,0 +1,478 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.nio.*;
+import org.apache.http.nio.entity.ContentOutputStream;
+import org.apache.http.nio.util.ContentOutputBuffer;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+import org.apache.http.nio.util.SharedOutputBuffer;
+import org.apache.http.nio.util.SimpleOutputBuffer;
+import org.apache.http.*;
+import org.apache.http.protocol.*;
+import org.apache.http.params.DefaultedHttpParams;
+import org.apache.http.impl.DefaultHttpResponseFactory;
+import org.apache.http.message.BasicHttpResponse;
+import org.apache.axis2.AxisFault;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+import org.apache.synapse.transport.passthru.jmx.LatencyView;
+import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This is the class where transport interacts with the client. This class
+ * receives events for a particular connection. These events give information
+ * about the message and its various states.
+ */
+public class SourceHandler implements NHttpServiceHandler {
+    private static Log log = LogFactory.getLog(SourceHandler.class);
+
+    private final SourceConfiguration sourceConfiguration;
+
+    private PassThroughTransportMetricsCollector metrics = null;
+    
+    private LatencyView latencyView = null;
+    
+    private LatencyView s2sLatencyView = null;
+
+    public SourceHandler(SourceConfiguration sourceConfiguration) {
+        this.sourceConfiguration = sourceConfiguration;
+        this.metrics = sourceConfiguration.getMetrics();
+        
+		try {
+			if (!sourceConfiguration.isSsl()) {
+				this.latencyView = new LatencyView(sourceConfiguration.isSsl());
+			} else {
+				this.s2sLatencyView = new LatencyView(sourceConfiguration.isSsl());
+			}
+		} catch (AxisFault e) {
+			log.error(e.getMessage(), e);
+		}
+    }
+
+    public void connected(NHttpServerConnection conn) {
+        // we have to have these two operations in order
+        sourceConfiguration.getSourceConnections().addConnection(conn);
+        SourceContext.create(conn, ProtocolState.REQUEST_READY, sourceConfiguration);
+
+        metrics.connected();
+    }
+
+    public void requestReceived(NHttpServerConnection conn) {
+        try {
+        	
+        	HttpContext _context = conn.getContext();
+        	_context.setAttribute(PassThroughConstants.REQ_ARRIVAL_TIME, System.currentTimeMillis());
+        	 
+            if (!SourceContext.assertState(conn, ProtocolState.REQUEST_READY) && !SourceContext.assertState(conn, ProtocolState.WSDL_RESPONSE_DONE)) {
+                handleInvalidState(conn, "Request received");
+                return;
+            }
+            // we have received a message over this connection. So we must inform the pool
+            sourceConfiguration.getSourceConnections().useConnection(conn);
+
+            // at this point we have read the HTTP Headers
+            SourceContext.updateState(conn, ProtocolState.REQUEST_HEAD);
+
+            SourceRequest request = new SourceRequest(
+                    sourceConfiguration, conn.getHttpRequest(), conn);
+
+            SourceContext.setRequest(conn, request);
+
+            request.start(conn);
+
+            metrics.incrementMessagesReceived();
+            
+            /******/
+            String method = request.getRequest() != null ? request.getRequest().getRequestLine().getMethod().toUpperCase():"";
+            OutputStream os = null;
+			if ("GET".equals(method)) {
+				HttpContext context = request.getConnection().getContext();
+				ContentOutputBuffer outputBuffer = new SimpleOutputBuffer(8192,	new HeapByteBufferAllocator());
+				// ContentOutputBuffer outputBuffer
+				// = new SharedOutputBuffer(8192, conn, new
+				// HeapByteBufferAllocator());
+				context.setAttribute("synapse.response-source-buffer",outputBuffer);
+				os = new ContentOutputStream(outputBuffer);
+			} 
+
+            sourceConfiguration.getWorkerPool().execute(
+                    new ServerWorker(request, sourceConfiguration,os));
+        } catch (HttpException e) {
+            log.error(e.getMessage(), e);
+
+            informReaderError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        } catch (IOException e) {
+            logIOException(e);
+
+            informReaderError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        }
+    }
+
+    public void inputReady(NHttpServerConnection conn,
+                           ContentDecoder decoder) {
+        try {
+            ProtocolState protocolState = SourceContext.getState(conn);
+
+            if (protocolState != ProtocolState.REQUEST_HEAD
+                    && protocolState != ProtocolState.REQUEST_BODY) {
+                handleInvalidState(conn, "Request message body data received");
+                return;
+            }
+
+            SourceContext.updateState(conn, ProtocolState.REQUEST_BODY);
+
+            SourceRequest request = SourceContext.getRequest(conn);
+
+            int readBytes = request.read(conn, decoder);
+            if (readBytes > 0) {
+                metrics.incrementBytesReceived(readBytes);
+            }
+        } catch (IOException e) {
+            logIOException(e);
+
+            informReaderError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        }
+    }
+
+    public void responseReady(NHttpServerConnection conn) {
+        try {
+            ProtocolState protocolState = SourceContext.getState(conn);
+            if (protocolState.compareTo(ProtocolState.REQUEST_DONE) < 0) {                
+                return;
+            }
+
+            if (protocolState.compareTo(ProtocolState.CLOSING) >= 0) {
+                return;
+            }
+
+            if (protocolState != ProtocolState.REQUEST_DONE) {
+                handleInvalidState(conn, "Writing a response");
+                return;
+            }
+
+            // because the duplex nature of http core we can reach hear without a actual response
+            SourceResponse response = SourceContext.getResponse(conn);
+            if (response != null) {
+                response.start(conn);
+
+                metrics.incrementMessagesSent();
+            }
+        } catch (IOException e) {
+            logIOException(e);
+
+            informWriterError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSING);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        } catch (HttpException e) {
+            log.error(e.getMessage(), e);
+
+            informWriterError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSING);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        }
+    }
+
+    public void outputReady(NHttpServerConnection conn,
+                            ContentEncoder encoder) {
+        try {
+            ProtocolState protocolState = SourceContext.getState(conn);
+            
+            //special case to handle WSDLs
+            if(protocolState == ProtocolState.WSDL_RESPONSE_DONE){
+            	// we need to shut down if the shutdown flag is set
+            	 HttpContext context = conn.getContext();
+            	 ContentOutputBuffer outBuf = (ContentOutputBuffer) context.getAttribute(
+                         "synapse.response-source-buffer");
+            	  int bytesWritten = outBuf.produceContent(encoder);
+                  if (metrics != null && bytesWritten > 0) {
+                      metrics.incrementBytesSent(bytesWritten);
+                  }
+                
+                  conn.requestInput();
+                  if(outBuf instanceof SimpleOutputBuffer && !((SimpleOutputBuffer)outBuf).hasData()){
+                	  sourceConfiguration.getSourceConnections().releaseConnection(conn);
+                  }
+                  
+            	return;
+            }
+            
+                        
+            if (protocolState != ProtocolState.RESPONSE_HEAD
+                    && protocolState != ProtocolState.RESPONSE_BODY) {
+                log.warn("Illegal incoming connection state: "
+                        + protocolState + " . Possibly two send backs " +
+                        "are happening for the same request");
+
+                handleInvalidState(conn, "Trying to write response body");
+                return;
+            }
+
+            SourceContext.updateState(conn, ProtocolState.RESPONSE_BODY);
+
+            SourceResponse response = SourceContext.getResponse(conn);
+
+            int bytesSent = response.write(conn, encoder);
+            
+			if (encoder.isCompleted()) {
+				HttpContext context = conn.getContext();
+				if (context.getAttribute(PassThroughConstants.REQ_ARRIVAL_TIME) != null &&
+				    context.getAttribute(PassThroughConstants.REQ_DEPARTURE_TIME) != null &&
+				    context.getAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME) != null) {
+
+					if (latencyView != null) {
+						latencyView.notifyTimes((Long) context.getAttribute(PassThroughConstants.REQ_ARRIVAL_TIME),
+						                        (Long) context.getAttribute(PassThroughConstants.REQ_DEPARTURE_TIME),
+						                        (Long) context.getAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME),
+						                        System.currentTimeMillis());
+					} else if (s2sLatencyView != null) {
+						s2sLatencyView.notifyTimes((Long) context.getAttribute(PassThroughConstants.REQ_ARRIVAL_TIME),
+						                           (Long) context.getAttribute(PassThroughConstants.REQ_DEPARTURE_TIME),
+						                           (Long) context.getAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME),
+						                           System.currentTimeMillis());
+					}
+				}
+
+				context.removeAttribute(PassThroughConstants.REQ_ARRIVAL_TIME);
+				context.removeAttribute(PassThroughConstants.REQ_DEPARTURE_TIME);
+				context.removeAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME);
+			}
+            
+            metrics.incrementBytesSent(bytesSent);
+        } catch (IOException e) {
+            logIOException(e);
+
+            informWriterError(conn);
+
+            SourceContext.updateState(conn, ProtocolState.CLOSING);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        } 
+    }
+
+    public void exception(NHttpServerConnection conn, IOException e) {        
+        logIOException(e);
+
+        metrics.incrementFaultsReceiving();
+
+        ProtocolState state = SourceContext.getState(conn);
+        if (state == ProtocolState.REQUEST_BODY ||
+                state == ProtocolState.REQUEST_HEAD) {
+            informReaderError(conn);
+        } else if (state == ProtocolState.RESPONSE_BODY ||
+                state == ProtocolState.RESPONSE_HEAD) {
+            informWriterError(conn);
+        } else if (state == ProtocolState.REQUEST_DONE) {
+            informWriterError(conn);
+        } else if (state == ProtocolState.RESPONSE_DONE) {
+            informWriterError(conn);
+        }
+        
+        SourceContext.updateState(conn, ProtocolState.CLOSED);
+        sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+    }
+
+    private void logIOException(IOException e) {
+        // this check feels like crazy! But weird things happened, when load testing.
+        if (e == null) {
+            return;
+        }
+        if (e instanceof ConnectionClosedException || (e.getMessage() != null && (
+                e.getMessage().toLowerCase().contains("connection reset by peer") ||
+                e.getMessage().toLowerCase().contains("forcibly closed")))) {
+            if (log.isDebugEnabled()) {
+                log.debug("I/O error (Probably the keepalive connection " +
+                        "was closed):" + e.getMessage());
+            }
+        } else if (e.getMessage() != null) {
+            String msg = e.getMessage().toLowerCase();
+            if (msg.indexOf("broken") != -1) {
+                log.warn("I/O error (Probably the connection " +
+                        "was closed by the remote party):" + e.getMessage());
+            } else {
+                log.error("I/O error: " + e.getMessage(), e);
+            }
+
+            metrics.incrementFaultsReceiving();
+        } else {
+            log.error("Unexpected I/O error: " + e.getClass().getName(), e);
+
+            metrics.incrementFaultsReceiving();
+        }
+    }
+
+    public void exception(NHttpServerConnection conn, HttpException e) {        
+        try {
+            if (conn.isResponseSubmitted()) {
+                sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+                return;
+            }
+            HttpContext httpContext = conn.getContext();
+
+            HttpResponse response = new BasicHttpResponse(
+                    HttpVersion.HTTP_1_1, HttpStatus.SC_BAD_REQUEST, "Bad request");
+            response.setParams(
+                    new DefaultedHttpParams(sourceConfiguration.getHttpParameters(),
+                            response.getParams()));
+            response.addHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);
+
+            // Pre-process HTTP request
+            httpContext.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
+            httpContext.setAttribute(ExecutionContext.HTTP_REQUEST, null);
+            httpContext.setAttribute(ExecutionContext.HTTP_RESPONSE, response);
+
+            sourceConfiguration.getHttpProcessor().process(response, httpContext);
+
+            conn.submitResponse(response);            
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            conn.close();
+        } catch (Exception e1) {
+            log.error(e.getMessage(), e);
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        }
+    }
+
+    public void timeout(NHttpServerConnection conn) {
+        ProtocolState state = SourceContext.getState(conn);
+
+        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {
+            if (log.isDebugEnabled()) {
+                log.debug("Keep-Alive connection was time out: " + conn);
+            }
+        } else if (state == ProtocolState.REQUEST_BODY ||
+                state == ProtocolState.REQUEST_HEAD) {
+
+            metrics.incrementTimeoutsReceiving();
+
+            informReaderError(conn);
+            log.warn("Connection time out while reading the request: " + conn);
+        } else if (state == ProtocolState.RESPONSE_BODY ||
+                state == ProtocolState.RESPONSE_HEAD) {
+            informWriterError(conn);
+            log.warn("Connection time out while writing the response: " + conn);
+        } else if (state == ProtocolState.REQUEST_DONE){
+            log.warn("Connection time out after request is read: " + conn);
+        }
+
+        SourceContext.updateState(conn, ProtocolState.CLOSED);
+        sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+    }
+
+    public void closed(NHttpServerConnection conn) {
+        ProtocolState state = SourceContext.getState(conn);
+
+        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {
+            if (log.isDebugEnabled()) {
+                log.debug("Keep-Alive connection was closed: " + conn);
+            }
+        } else if (state == ProtocolState.REQUEST_BODY ||
+                state == ProtocolState.REQUEST_HEAD) {
+            informReaderError(conn);
+            log.warn("Connection closed while reading the request: " + conn);
+        } else if (state == ProtocolState.RESPONSE_BODY ||
+                state == ProtocolState.RESPONSE_HEAD) {
+            informWriterError(conn);
+            log.warn("Connection closed while writing the response: " + conn);
+        } else if (state == ProtocolState.REQUEST_DONE) {
+            log.warn("Connection closed by the client after request is read: " + conn);
+        }
+
+        metrics.disconnected();
+
+        SourceContext.updateState(conn, ProtocolState.CLOSED);
+        sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+    }
+
+    private void handleInvalidState(NHttpServerConnection conn, String action) {
+        log.warn(action + " while the handler is in an inconsistent state " +
+                SourceContext.getState(conn));
+        SourceContext.updateState(conn, ProtocolState.CLOSED);
+        sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+    }
+
+    private void informReaderError(NHttpServerConnection conn) {
+        Pipe reader = SourceContext.get(conn).getReader();
+
+        metrics.incrementFaultsReceiving();
+
+        if (reader != null) {
+            reader.producerError();
+        }
+    }
+
+    private void informWriterError(NHttpServerConnection conn) {
+        Pipe writer = SourceContext.get(conn).getWriter();
+
+        metrics.incrementFaultsSending();
+
+        if (writer != null) {
+            writer.consumerError();
+        }
+    }
+    
+    
+    /**
+     * Commit the response to the connection. Processes the response through the configured
+     * HttpProcessor and submits it to be sent out. This method hides any exceptions and is targetted
+     * for non critical (i.e. browser requests etc) requests, which are not core messages
+     * @param conn the connection being processed
+     * @param response the response to commit over the connection
+     */
+    public void commitResponseHideExceptions(
+            final NHttpServerConnection conn, final HttpResponse response) {
+        try {
+            conn.suspendInput();
+            sourceConfiguration.getHttpProcessor().process(response, conn.getContext());
+            conn.submitResponse(response);
+        } catch (HttpException e) {
+            handleException("Unexpected HTTP protocol error : " + e.getMessage(), e, conn);
+        } catch (IOException e) {
+            handleException("IO error submiting response : " + e.getMessage(), e, conn);
+        }
+    }
+    
+    
+    // ----------- utility methods -----------
+
+    private void handleException(String msg, Exception e, NHttpServerConnection conn) {
+        log.error(msg, e);
+        if (conn != null) {
+            //shutdownConnection(conn);
+        }
+    }
+    
+    
+    
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetIOEventDispatch.java	(revision 1502663)
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.impl.nio.DefaultClientIOEventDispatch;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpClientIOTarget;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.passthru.logging.LoggingUtils;
+
+/**
+ * This is a factory for creating the logging sessions or non-logging sessions.
+ */
+public class TargetIOEventDispatch extends DefaultClientIOEventDispatch {
+
+    public TargetIOEventDispatch(final NHttpClientHandler handler, final HttpParams params) {
+        super(LoggingUtils.decorate(handler), params);
+    }
+
+    @Override
+    protected NHttpClientIOTarget createConnection(IOSession session) {
+        session = LoggingUtils.decorate(session, "client");
+        return LoggingUtils.createClientConnection(
+                session,
+                createHttpResponseFactory(),
+                this.allocator,
+                this.params);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpSourceConnection.java	(revision 1502663)
@@ -0,0 +1,160 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.http.impl.nio.DefaultNHttpServerConnection;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionOutputBuffer;
+import org.apache.http.nio.reactor.SessionInputBuffer;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.NHttpMessageWriter;
+import org.apache.http.nio.NHttpMessageParser;
+import org.apache.http.*;
+import org.apache.http.params.HttpParams;
+import org.apache.commons.logging.Log;
+
+import java.io.IOException;
+import java.nio.channels.ReadableByteChannel;
+
+public class LoggingNHttpSourceConnection extends DefaultNHttpServerConnection {
+    private final Log log;
+    private final Log headerLog;
+
+    public LoggingNHttpSourceConnection(
+            final Log log,
+            final Log headerlog,
+            final IOSession session,
+            final HttpRequestFactory requestFactory,
+            final ByteBufferAllocator allocator,
+            final HttpParams params) {
+        super(session, requestFactory, allocator, params);
+        this.log = log;
+        this.headerLog = headerlog;
+    }
+
+    @Override
+    public void close() throws IOException {
+        this.log.debug("Close connection");
+        super.close();
+    }
+
+    @Override
+    public void shutdown() throws IOException {
+        this.log.debug("Shutdown connection");
+        super.shutdown();
+    }
+
+    @Override
+    public void submitResponse(final HttpResponse response) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + this + ": "  + response.getStatusLine().toString());
+        }
+        super.submitResponse(response);
+    }
+
+    @Override
+    public void consumeInput(final NHttpServiceHandler handler) {
+        this.log.debug("Consume input");
+        super.consumeInput(handler);
+    }
+
+    @Override
+    public void produceOutput(final NHttpServiceHandler handler) {
+        this.log.debug("Produce output");
+        super.produceOutput(handler);
+    }
+
+    @Override
+    protected NHttpMessageWriter createResponseWriter(
+            final SessionOutputBuffer buffer,
+            final HttpParams params) {
+        return new LoggingNHttpMessageWriter(
+                super.createResponseWriter(buffer, params));
+    }
+
+    @Override
+    protected NHttpMessageParser createRequestParser(
+            final SessionInputBuffer buffer,
+            final HttpRequestFactory requestFactory,
+            final HttpParams params) {
+        return new LoggingNHttpMessageParser(
+                super.createRequestParser(buffer, requestFactory, params));
+    }
+
+    class LoggingNHttpMessageWriter implements NHttpMessageWriter {
+
+        private final NHttpMessageWriter writer;
+
+        public LoggingNHttpMessageWriter(final NHttpMessageWriter writer) {
+            super();
+            this.writer = writer;
+        }
+
+        public void reset() {
+            this.writer.reset();
+        }
+
+        public void write(final HttpMessage message) throws IOException, HttpException {
+            if (message != null && headerLog.isDebugEnabled()) {
+                HttpResponse response = (HttpResponse) message;
+                headerLog.debug("<< " + response.getStatusLine().toString());
+                Header[] headers = response.getAllHeaders();
+                for (Header header : headers) {
+                    headerLog.debug("<< " + header.toString());
+                }
+            }
+            this.writer.write(message);
+        }
+
+    }
+
+    class LoggingNHttpMessageParser implements NHttpMessageParser {
+
+        private final NHttpMessageParser parser;
+
+        public LoggingNHttpMessageParser(final NHttpMessageParser parser) {
+            super();
+            this.parser = parser;
+        }
+
+        public void reset() {
+            this.parser.reset();
+        }
+
+        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
+            return this.parser.fillBuffer(channel);
+        }
+
+        public HttpMessage parse() throws IOException, HttpException {
+            HttpMessage message = this.parser.parse();
+            if (message != null && headerLog.isDebugEnabled()) {
+                HttpRequest request = (HttpRequest) message;
+                headerLog.debug(">> " + request.getRequestLine().toString());
+                Header[] headers = request.getAllHeaders();
+                for (Header header : headers) {
+                    headerLog.debug(">> " + header.toString());
+                }
+            }
+            return message;
+        }
+    }
+}
+
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java	(revision 1502663)
@@ -0,0 +1,182 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.*;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.impl.DefaultConnectionReuseStrategy;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This class represents a response coming from the target server.
+ */
+public class TargetResponse {
+    // private Log log = LogFactory.getLog(TargetResponse.class);
+    /** To pipe the incoming data through */
+    private Pipe pipe = null;
+    /** Headers of the response */
+    private Map<String, String> headers = new HashMap<String, String>();
+    /** The status of the response */
+    private int status = HttpStatus.SC_OK;
+    /** Http status line */
+    private String statusLine = "OK";
+    /** The Http response */
+    private HttpResponse response = null;
+    /** Configuration of the sender */
+    private TargetConfiguration targetConfiguration;
+    /** Protocol version */
+    private ProtocolVersion version = HttpVersion.HTTP_1_1;
+    /** This utility class is used for determining weather we need to close the connection
+     * after submitting the response */
+    private ConnectionReuseStrategy connStrategy = new DefaultConnectionReuseStrategy();
+    /** The connection */
+    private NHttpClientConnection connection;
+    /** Weather this response has a body */
+    private boolean expectResponseBody = true;
+
+    public TargetResponse(TargetConfiguration targetConfiguration,
+                          HttpResponse response,
+                          NHttpClientConnection conn,
+                          boolean expectResponseBody) {
+        this.targetConfiguration = targetConfiguration;
+        this.response = response;
+        this.connection = conn;
+
+        this.version = response.getProtocolVersion();
+
+        this.status = response.getStatusLine().getStatusCode();
+        this.statusLine = response.getStatusLine().getReasonPhrase();
+
+        Header[] headers = response.getAllHeaders();
+        if (headers != null) {
+            for (Header header : headers) {
+                this.headers.put(header.getName(), header.getValue());
+            }
+        }
+
+        this.expectResponseBody = expectResponseBody;
+    }    
+
+    /**
+     * Starts the response
+     * @param conn the client connection
+     */
+    public void start(NHttpClientConnection conn) {
+        TargetContext.updateState(conn, ProtocolState.RESPONSE_HEAD);
+        
+        if (expectResponseBody) {
+            pipe
+                = new Pipe(conn, targetConfiguration.getBufferFactory().getBuffer(), "target", targetConfiguration);
+
+            TargetContext.get(conn).setReader(pipe);
+
+            BasicHttpEntity entity = new BasicHttpEntity();
+            if (response.getStatusLine().getProtocolVersion().greaterEquals(HttpVersion.HTTP_1_1)) {
+                entity.setChunked(true);
+            }
+            response.setEntity(entity);
+        } else {            
+            if (!connStrategy.keepAlive(response, conn.getContext())) {
+                try {
+                    // this is a connection we should not re-use
+                    TargetContext.updateState(conn, ProtocolState.CLOSING);
+                    targetConfiguration.getConnections().shutdownConnection(conn);
+                                       
+                } catch (Exception ignore) {
+
+                }
+            } else {
+                targetConfiguration.getConnections().releaseConnection(conn);
+            }
+        }
+    }
+
+    /**
+     * Read the data from the wire and read in to the pipe so that other end of
+     * the pipe can write.
+     * @param conn the target connection
+     * @param decoder content decoder
+     * @throws java.io.IOException if an error occurs
+     * @return number of bites read
+     */
+    public int read(NHttpClientConnection conn, ContentDecoder decoder) throws IOException {
+    	
+    	int bytes=0;
+    	
+    	if(pipe != null){
+    		bytes = pipe.produce(decoder);
+    	}
+
+        // Update connection state
+        if (decoder.isCompleted()) {
+            TargetContext.updateState(conn, ProtocolState.RESPONSE_DONE);
+
+            targetConfiguration.getMetrics().notifyReceivedMessageSize(
+                    conn.getMetrics().getReceivedBytesCount());
+
+            if (!this.connStrategy.keepAlive(response, conn.getContext())) {
+                TargetContext.updateState(conn, ProtocolState.CLOSED);
+
+                targetConfiguration.getConnections().shutdownConnection(conn);
+            } else {
+                targetConfiguration.getConnections().releaseConnection(conn);
+            }
+        }
+        return bytes;
+    }
+
+    public String getHeader(String name) {
+        return headers.get(name);
+    }
+
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    public Pipe getPipe() {
+        return pipe;
+    }
+
+    public int getStatus() {
+        return status;
+    }
+
+    public String getStatusLine() {
+        return statusLine;
+    }
+
+    public boolean isExpectResponseBody() {
+        return expectResponseBody;
+    }
+
+    public NHttpClientConnection getConnection() {
+        return connection;
+    }
+
+    public ProtocolVersion getVersion() {
+        return version;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ConnectCallback.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ConnectCallback.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ConnectCallback.java	(revision 1502663)
@@ -0,0 +1,93 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.nio.reactor.SessionRequestCallback;
+import org.apache.http.nio.reactor.SessionRequest;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.connections.HostConnections;
+
+public class ConnectCallback implements SessionRequestCallback {
+
+    private static Log log = LogFactory.getLog(ConnectCallback.class);     
+
+    /** The agent used for delivering requests */
+    private DeliveryAgent deliveryAgent;
+
+    /**
+     * Create the callback for the handling events on a given connection     
+     */
+    public ConnectCallback() {
+
+    }
+
+    public void completed(SessionRequest request) {
+        HostConnections pool = (HostConnections) request.getAttachment();
+        pool.pendingConnectionSucceeded();
+        if (log.isDebugEnabled()) {
+            if (request.getSession() != null &&
+                    request.getSession().getLocalAddress() != null) {
+                log.debug("Connected to remote address: " +
+                        request.getSession().getRemoteAddress() +
+                        " from local address: " + request.getSession().getLocalAddress());
+            }
+        }
+    }
+
+    public void failed(SessionRequest request) {
+        HostConnections pool = (HostConnections) request.getAttachment();
+        pool.pendingConnectionFailed();
+
+        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),
+                ErrorCodes.CONNECTION_FAILED, "Connection Failed");
+
+        handleError("Connection refused or failed for : " + request.getRemoteAddress());
+    }
+
+    public void timeout(SessionRequest request) {
+        HostConnections pool = (HostConnections) request.getAttachment();
+        pool.pendingConnectionFailed();
+
+        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),
+                ErrorCodes.CONNECT_TIMEOUT, "Connection Timeout");
+
+        handleError("Timeout connecting to : " + request.getRemoteAddress());
+        request.cancel();
+    }
+
+    public void cancelled(SessionRequest request) {
+        HostConnections pool = (HostConnections) request.getAttachment();
+        pool.pendingConnectionFailed();
+
+        deliveryAgent.errorConnecting(pool.getHost(), pool.getPort(),
+                ErrorCodes.CONNECT_CANCEL, "Connection Cancel");
+
+        handleError("Connection cancelled for : " + request.getRemoteAddress());
+    }
+
+    private void handleError(String errorMessage) {
+        log.warn(errorMessage);
+    }
+
+    public void setDeliveryAgent(DeliveryAgent deliveryAgent) {
+        this.deliveryAgent = deliveryAgent;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java	(revision 1502663)
@@ -0,0 +1,176 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.*;
+import org.apache.http.message.BasicHttpResponse;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+
+import java.io.IOException;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.TreeMap;
+
+/**
+ * Represents a Http Request.
+ */
+public class SourceRequest {
+    // private Log log = LogFactory.getLog(SourceRequest.class);
+
+    private Pipe pipe = null;
+    /** HTTP Headers */
+    private Map<String, String> headers =  new TreeMap<String, String>(new Comparator<String>() {
+        public int compare(String o1, String o2) {
+            return o1.compareToIgnoreCase(o2);
+        }
+    });
+    /** HTTP URL */
+    private String url;
+    /** HTTP Method */
+    private String method;
+    /** Weather reqyest has a body */
+    private boolean entityEnclosing;
+    /** The http request */
+    private HttpRequest request = null;
+    /** Configuration of the receiver */
+    private SourceConfiguration sourceConfiguration;
+    /** HTTP Version */
+    private ProtocolVersion version = null;
+    /** The connection from the client */
+    private NHttpServerConnection connection = null;
+
+    public SourceRequest(SourceConfiguration sourceConfiguration,
+                         HttpRequest request,
+                         NHttpServerConnection conn) {
+        this.sourceConfiguration = sourceConfiguration;
+        this.request = request;
+        this.connection = conn;
+
+        this.url = request.getRequestLine().getUri();
+        this.method = request.getRequestLine().getMethod();
+        this.entityEnclosing = request instanceof HttpEntityEnclosingRequest;
+        this.version = request.getProtocolVersion();
+
+        this.version = request.getRequestLine().getProtocolVersion();
+        if (!version.lessEquals(HttpVersion.HTTP_1_1)) {
+            // Downgrade protocol version if greater than HTTP/1.1
+            this.version = HttpVersion.HTTP_1_1;
+        }
+
+        Header[] headers = request.getAllHeaders();
+        if (headers != null) {
+            for (Header header : headers) {
+                this.headers.put(header.getName(), header.getValue());
+            }
+        }
+    }
+
+    /**
+     * Start processing the request by connecting the pipe if this request has an entity body.
+     * @param conn connection
+     * @throws IOException if an error occurs
+     * @throws HttpException if an error occurs
+     */
+    public void start(NHttpServerConnection conn) throws IOException, HttpException {
+        if (entityEnclosing) {
+            pipe = new Pipe(conn, sourceConfiguration.getBufferFactory().getBuffer(), "source", sourceConfiguration);
+
+            SourceContext.get(conn).setReader(pipe);
+
+            // See if the client expects a 100-Continue
+            if (((HttpEntityEnclosingRequest) request).expectContinue()) {
+                HttpResponse ack = new BasicHttpResponse(version, HttpStatus.SC_CONTINUE, "Continue");
+                conn.submitResponse(ack);
+            }
+        } else {
+            // this request is completed, there is nothing more to read
+            SourceContext.updateState(conn, ProtocolState.REQUEST_DONE);
+            // No httpRequest content expected. Suspend client input
+            conn.suspendInput();
+        }
+    }
+
+    /**
+     * Produce the content in to the pipe.
+     * @param conn the connection
+     * @param decoder content decoder
+     *
+     * @throws java.io.IOException if an error occurs
+     * @return number of bytes read
+     */
+    public int read(NHttpServerConnection conn, ContentDecoder decoder) throws IOException {
+        if (pipe == null) {
+            throw new IllegalStateException("A Pipe must be connected before calling read");
+        }
+
+        if (entityEnclosing) {
+            int bytes = pipe.produce(decoder);
+
+            if (decoder.isCompleted()) {
+                sourceConfiguration.getMetrics().
+                        notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());
+
+                // Update connection state
+                SourceContext.updateState(conn, ProtocolState.REQUEST_DONE);
+                // Suspend client input
+                conn.suspendInput();
+            }
+            return bytes;
+        } else {
+            throw new IllegalStateException("Only Entity Enclosing Requests " +
+                    "can read content in to the pipe");
+        }
+    }
+
+    public Map<String, String> getHeaders() {
+        return headers;
+    }
+
+    public String getUri() {
+        return url;
+    }
+
+    public String getMethod() {
+        return method;
+    }
+
+    public Pipe getPipe() {
+        return pipe;
+    }
+
+    public NHttpServerConnection getConnection() {
+        return connection;
+    }
+
+    public ProtocolVersion getVersion() {
+        return version;
+    }
+
+    public HttpRequest getRequest() {
+        return request;
+    }
+
+    public boolean isEntityEnclosing() {
+        return entityEnclosing;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/TargetConfiguration.java	(revision 1502663)
@@ -0,0 +1,98 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.config;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.ParameterInclude;
+import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.http.HttpRequestInterceptor;
+import org.apache.http.params.HttpParams;
+import org.apache.http.protocol.*;
+import org.apache.synapse.transport.passthru.connections.TargetConnections;
+
+/**
+ * This class stores configuration specific to HTTP Connectors (Senders)
+ */
+public class TargetConfiguration extends BaseConfiguration {
+
+    private HttpProcessor httpProcessor = null;
+
+    private int maxConnections = Integer.MAX_VALUE;
+
+    /** Weather User-Agent header coming from client should be preserved */
+    private boolean preserveUserAgentHeader = false;
+    /** Weather Server header coming from server should be preserved */
+    private boolean preserveServerHeader = true;
+
+    private TargetConnections connections = null;
+
+    public TargetConfiguration(ConfigurationContext configurationContext,
+                               ParameterInclude parameters,
+                               WorkerPool pool) {
+        super(configurationContext, parameters, pool);
+
+        httpProcessor = new ImmutableHttpProcessor(
+                new HttpRequestInterceptor[] {
+                        new RequestContent(),
+                        new RequestTargetHost(),
+                        new RequestConnControl(),
+                        new RequestUserAgent(),
+                        new RequestExpectContinue()
+         });
+    }
+
+    public void build() throws AxisFault {
+        super.build();
+
+        maxConnections = conf.getIntProperty(PassThroughConfigPNames.MAX_CONNECTION_PER_HOST_PORT,
+                Integer.MAX_VALUE);
+        preserveUserAgentHeader = conf.isPreserveUserAgentHeader();
+        preserveServerHeader = conf.isPreserveServerHeader();
+    }
+
+    public HttpParams getHttpParameters() {
+        return httpParameters;
+    }
+
+    public HttpProcessor getHttpProcessor() {
+        return httpProcessor;
+    }
+
+    public int getMaxConnections() {
+        return maxConnections;
+    }
+
+    public boolean isPreserveUserAgentHeader() {
+        return preserveUserAgentHeader;
+    }
+
+    public boolean isPreserveServerHeader() {
+        return preserveServerHeader;
+    }
+
+    public TargetConnections getConnections() {
+        return connections;
+    }
+
+    public void setConnections(TargetConnections connections) {
+        this.connections = connections;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfiguration.java	(revision 1502663)
@@ -0,0 +1,239 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.config;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Properties;
+
+/**
+ * This class encapsulates pass-through http transport tuning configurations specified via a
+ * configurations file or system properties.
+ */
+public class PassThroughConfiguration {
+
+    /**
+     * Default tuning parameter values
+     */
+    private static final int DEFAULT_WORKER_POOL_SIZE_CORE       = 40;
+    private static final int DEFAULT_WORKER_POOL_SIZE_MAX        = 200;
+    private static final int DEFAULT_WORKER_THREAD_KEEPALIVE_SEC = 60;
+    private static final int DEFAULT_WORKER_POOL_QUEUE_LENGTH    = -1;
+    private static final int DEFAULT_IO_BUFFER_SIZE              = 8 * 1024;
+    private static final int DEFAULT_IO_THREADS_PER_REACTOR      =
+                                                         Runtime.getRuntime().availableProcessors();
+
+    private static final Log log = LogFactory.getLog(PassThroughConfiguration.class);
+
+    private static PassThroughConfiguration _instance = new PassThroughConfiguration();
+
+    private Properties props;
+
+    private PassThroughConfiguration() {
+        try {
+            props = loadProperties("passthru-http.properties");
+        } catch (Exception ignored) {}
+    }
+
+    public static PassThroughConfiguration getInstance() {
+        return _instance;
+    }
+
+    public int getWorkerPoolCoreSize() {
+        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_CORE,
+                DEFAULT_WORKER_POOL_SIZE_CORE);
+    }
+
+    public int getWorkerPoolMaxSize() {
+        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_MAX,
+                DEFAULT_WORKER_POOL_SIZE_MAX);
+    }
+
+    public int getWorkerThreadKeepaliveSec() {
+        return getIntProperty(PassThroughConfigPNames.WORKER_THREAD_KEEP_ALIVE_SEC,
+                DEFAULT_WORKER_THREAD_KEEPALIVE_SEC);
+    }
+
+    public int getWorkerPoolQueueLen() {
+        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_QUEUE_LENGTH,
+                DEFAULT_WORKER_POOL_QUEUE_LENGTH);
+    }
+
+    public int getIOThreadsPerReactor() {
+        return getIntProperty(PassThroughConfigPNames.IO_THREADS_PER_REACTOR,
+                DEFAULT_IO_THREADS_PER_REACTOR);
+    }
+
+    public int getIOBufferSize() {
+        return getIntProperty(PassThroughConfigPNames.IO_BUFFER_SIZE,
+                DEFAULT_IO_BUFFER_SIZE);
+    }
+
+    public boolean isKeepAliveDisabled() {
+        return getBooleanProperty(PassThroughConfigPNames.DISABLE_KEEPALIVE, false);
+    }
+
+    public boolean isPreserveUserAgentHeader() {
+        return getBooleanProperty(PassThroughConfigPNames.USER_AGENT_HEADER_PRESERVE, false);
+    }
+
+    public boolean isPreserveServerHeader() {
+        return getBooleanProperty(PassThroughConfigPNames.SERVER_HEADER_PRESERVE, true);
+    }
+
+    /**
+     * Loads the properties from a given property file path
+     *
+     * @param filePath Path of the property file
+     * @return Properties loaded from given file
+     */
+    private static Properties loadProperties(String filePath) {
+
+        Properties properties = new Properties();
+        ClassLoader cl = Thread.currentThread().getContextClassLoader();
+
+        if (log.isDebugEnabled()) {
+            log.debug("Loading the file '" + filePath + "' from classpath");
+        }
+
+        InputStream in = cl.getResourceAsStream(filePath);
+        if (in == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Unable to load file  '" + filePath + "'");
+            }
+
+            filePath = "conf" + File.separatorChar + filePath;
+            if (log.isDebugEnabled()) {
+                log.debug("Loading the file '" + filePath + "'");
+            }
+
+            in = cl.getResourceAsStream(filePath);
+            if (in == null) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Unable to load file  '" + filePath + "'");
+                }
+            }
+        }
+        if (in != null) {
+            try {
+                properties.load(in);
+            } catch (IOException e) {
+                String msg = "Error loading properties from a file at : " + filePath;
+                log.error(msg, e);
+            }
+        }
+        return properties;
+    }
+
+    /**
+     * Get an int property that tunes pass-through http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public Integer getIntProperty(String name, Integer def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        if (val != null) {
+            int intVal;
+            try {
+                intVal = Integer.valueOf(val);
+            } catch (NumberFormatException e) {
+                log.warn("Invalid pass-through http tuning property value. " + name +
+                        " must be an integer");
+                return def;
+            }
+            if (log.isDebugEnabled()) {
+                log.debug("Using pass-through http tuning parameter : " + name + " = " + val);
+            }
+            return intVal;
+        }
+
+        return def;
+    }
+
+    /**
+     * Get an int property that tunes pass-through http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @return the value of the property, null if the property is not found
+     */
+    public Integer getIntProperty(String name) {
+        return getIntProperty(name, null);
+    }
+
+    /**
+     * Get a boolean property that tunes pass-through http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public Boolean getBooleanProperty(String name, Boolean def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        if (val != null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Using pass-through http tuning parameter : " + name + " = " + val);
+            }
+            return Boolean.valueOf(val);
+        }
+
+        return def;
+    }
+
+    /**
+     * Get a Boolean property that tunes pass-through http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @return the value of the property, null if the property is not found
+     */
+    public Boolean getBooleanProperty(String name) {
+        return getBooleanProperty(name, null);
+    }
+
+    /**
+     * Get a String property that tunes pass-through http transport. Prefer system properties
+     *
+     * @param name name of the system/config property
+     * @param def  default value to return if the property is not set
+     * @return the value of the property to be used
+     */
+    public String getStringProperty(String name, String def) {
+        String val = System.getProperty(name);
+        if (val == null) {
+            val = props.getProperty(name);
+        }
+
+        return val == null ? def : val;
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfigPNames.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfigPNames.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/PassThroughConfigPNames.java	(revision 1502663)
@@ -0,0 +1,77 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.config;
+
+/**
+ * Defines configuration parameter names for Pass-through HTTP Transport.
+ */
+public interface PassThroughConfigPNames {
+
+    /**
+     * Defines the core size (number of threads) of the worker thread pool.
+     */
+    public String WORKER_POOL_SIZE_CORE = "worker_pool_size_core";
+
+    /**
+     * Defines the maximum size (number of threads) of the worker thread pool.
+     */
+    public String WORKER_POOL_SIZE_MAX = "worker_pool_size_max";
+
+    /**
+     * Defines the keep-alive time for extra threads in the worker pool.
+     */
+    public String WORKER_THREAD_KEEP_ALIVE_SEC = "worker_thread_keepalive_sec";
+
+    /**
+     * Defines the length of the queue that is used to hold Runnable tasks to be executed by the
+     * worker pool.
+     */
+    public String WORKER_POOL_QUEUE_LENGTH = "worker_pool_queue_length";
+
+    /**
+     * Defines the number of IO dispatcher threads used per reactor
+     */
+    public String IO_THREADS_PER_REACTOR = "io_threads_per_reactor";
+
+    /**
+     * Defines the IO buffer size
+     */
+    public String IO_BUFFER_SIZE = "io_buffer_size";
+
+    /**
+     * Defines whether ESB needs to preserve the original User-Agent header.
+     */
+    public String USER_AGENT_HEADER_PRESERVE = "http.user.agent.preserve";
+
+    /**
+     * Defines whether ESB needs to preserve the original Server header.
+     */
+    public String SERVER_HEADER_PRESERVE = "http.server.preserve";
+
+    /**
+     * Defines whether HTTP keep-alive is disabled
+     */
+    public String DISABLE_KEEPALIVE = "http.connection.disable.keepalive";
+
+    /**
+     * Defines the maximum number of connections per host port
+     */
+    public String MAX_CONNECTION_PER_HOST_PORT = "http.max.connection.per.host.port";
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/BaseConfiguration.java	(revision 1502663)
@@ -0,0 +1,164 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+package org.apache.synapse.transport.passthru.config;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.ParameterInclude;
+import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.axis2.transport.base.threads.WorkerPoolFactory;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.params.NIOReactorPNames;
+import org.apache.http.nio.params.NIOReactorParams;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+import org.apache.http.params.BasicHttpParams;
+import org.apache.http.params.HttpConnectionParams;
+import org.apache.http.params.HttpParams;
+import org.apache.http.params.HttpProtocolParams;
+import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
+import org.apache.synapse.transport.passthru.util.BufferFactory;
+
+/**
+ * This class has common configurations for both sender and receiver.
+ */
+public abstract class BaseConfiguration {
+
+    private Log log = LogFactory.getLog(BaseConfiguration.class);
+
+    /**
+     * Configurations given by axis2.xml
+     */
+    protected ParameterInclude parameters = null;
+
+    /** The thread pool for executing the messages passing through */
+    private WorkerPool workerPool = null;
+
+    /** The Axis2 ConfigurationContext */
+    protected ConfigurationContext configurationContext = null;
+
+    /** Default http parameters */
+    protected HttpParams httpParameters = null;
+
+    protected BufferFactory bufferFactory = null;
+
+    private PassThroughTransportMetricsCollector metrics = null;
+
+    private int iOThreadsPerReactor;
+
+    private int iOBufferSize;
+
+    protected PassThroughConfiguration conf = PassThroughConfiguration.getInstance();
+
+    public BaseConfiguration(ConfigurationContext configurationContext,
+                             ParameterInclude parameters,
+                             WorkerPool workerPool) {
+        this.parameters = parameters;
+        this.workerPool = workerPool;
+        this.configurationContext = configurationContext;
+    }
+
+    public void build() throws AxisFault {
+        iOThreadsPerReactor = conf.getIOThreadsPerReactor();
+
+        iOBufferSize = conf.getIOBufferSize();
+
+        if (workerPool == null) {
+            workerPool = WorkerPoolFactory.getWorkerPool(
+                            conf.getWorkerPoolCoreSize(),
+                            conf.getWorkerPoolMaxSize(),
+                            conf.getWorkerThreadKeepaliveSec(),
+                            conf.getWorkerPoolQueueLen(),
+                            "Pass-through Message Processing Thread Group",
+                            "PassThroughMessageProcessor");
+        }
+
+        httpParameters = retrieveHttpParameters();
+
+        bufferFactory = new BufferFactory(iOBufferSize, new HeapByteBufferAllocator(), 512);
+    }
+
+    public int getIOThreadsPerReactor() {
+        return iOThreadsPerReactor;
+    }
+
+    public int getIOBufferSize() {
+        return iOBufferSize;
+    }
+
+    public WorkerPool getWorkerPool() {
+        return workerPool;
+    }
+
+    public ConfigurationContext getConfigurationContext() {
+        return configurationContext;
+    }
+
+    protected HttpParams retrieveHttpParameters() throws AxisFault {
+        HttpParams params = new BasicHttpParams();
+        params.
+            setIntParameter(HttpConnectionParams.SO_TIMEOUT,
+                    conf.getIntProperty(HttpConnectionParams.SO_TIMEOUT, 60000)).
+            setIntParameter(HttpConnectionParams.CONNECTION_TIMEOUT,
+                    conf.getIntProperty(HttpConnectionParams.CONNECTION_TIMEOUT, 0)).
+            setIntParameter(HttpConnectionParams.SOCKET_BUFFER_SIZE,
+                    conf.getIntProperty(HttpConnectionParams.SOCKET_BUFFER_SIZE, 8 * 1024)).
+            setBooleanParameter(HttpConnectionParams.STALE_CONNECTION_CHECK,
+                    conf.getBooleanProperty(HttpConnectionParams.STALE_CONNECTION_CHECK, false)).
+            setBooleanParameter(HttpConnectionParams.TCP_NODELAY,
+                    conf.getBooleanProperty(HttpConnectionParams.TCP_NODELAY, true)).
+            setBooleanParameter(NIOReactorPNames.INTEREST_OPS_QUEUEING,
+                    conf.getBooleanProperty(NIOReactorParams.INTEREST_OPS_QUEUEING, false)).
+            setParameter(HttpProtocolParams.ORIGIN_SERVER,
+                    conf.getStringProperty(HttpProtocolParams.ORIGIN_SERVER, "Synapse-PassThrough-HTTP"));
+
+        /* Set advanced tuning params only if they are explicitly set so that we are not loosing
+           internal defaults of HttpCore-NIO */
+        if (conf.getIntProperty(HttpConnectionParams.SO_LINGER) != null) {
+            HttpConnectionParams.setLinger(params,
+                    conf.getIntProperty(HttpConnectionParams.SO_LINGER));
+        }
+
+        if (conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR) != null) {
+            HttpConnectionParams.setSoReuseaddr(params,
+                    conf.getBooleanProperty(HttpConnectionParams.SO_REUSEADDR));
+        }
+
+        if (conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL) != null) {
+            NIOReactorParams.setSelectInterval(params,
+                    conf.getIntProperty(NIOReactorPNames.SELECT_INTERVAL));
+        }
+
+        return params;
+    }
+
+    public BufferFactory getBufferFactory() {
+        return bufferFactory;
+    }
+
+    public PassThroughTransportMetricsCollector getMetrics() {
+        return metrics;
+    }
+
+    public void setMetrics(PassThroughTransportMetricsCollector metrics) {
+        this.metrics = metrics;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/config/SourceConfiguration.java	(revision 1502663)
@@ -0,0 +1,258 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.config;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.axis2.transport.TransportListener;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.params.*;
+import org.apache.http.protocol.*;
+import org.apache.http.HttpResponseFactory;
+import org.apache.http.HttpResponseInterceptor;
+import org.apache.http.impl.DefaultHttpResponseFactory;
+import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.axis2.transport.base.ParamUtils;
+import org.apache.axis2.AxisFault;
+import org.apache.synapse.transport.nhttp.DefaultHttpGetProcessor;
+
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.passthru.HttpGetRequestProcessor;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+import org.apache.synapse.transport.passthru.connections.SourceConnections;
+
+import java.net.UnknownHostException;
+
+/**
+ * This class stores configurations specific to the Listeners
+ */
+public class SourceConfiguration extends BaseConfiguration {
+
+    private Log log = LogFactory.getLog(SourceConfiguration.class);
+
+    /** This is used to process HTTP responses */
+    private HttpProcessor httpProcessor = null;
+
+    /** Response factory used for creating HTTP Responses */
+    private HttpResponseFactory responseFactory = null;
+
+    /** port of the listener */
+    private int port = 8280;
+
+    /** Object to manage the source connections */
+    private SourceConnections sourceConnections = null;
+
+    private TransportInDescription inDescription;
+
+    private String host;
+
+    /** The EPR prefix for services available over this transport */
+    private String serviceEPRPrefix;
+    /** The EPR prefix for services with custom URI available over this transport */
+    private String customEPRPrefix;
+    
+    /** SSLContext if this listener is a SSL listener */
+    private boolean ssl = false;
+    
+    
+    /** WSDL processor for Get requests*/
+    private HttpGetRequestProcessor httpGetRequestProcessor = null;
+
+
+    public SourceConfiguration(ConfigurationContext configurationContext,
+                               TransportInDescription description,
+                               WorkerPool pool) {
+        super(configurationContext, description, pool);
+        this.inDescription = description;
+        httpProcessor = new ImmutableHttpProcessor(
+                new HttpResponseInterceptor[]{
+                        new ResponseDate(),
+                        new ResponseServer(),
+                        new ResponseContent(),
+                        new ResponseConnControl()});
+
+        responseFactory = new DefaultHttpResponseFactory();
+
+        sourceConnections = new SourceConnections();
+    }
+
+    public void build() throws AxisFault {
+        super.build();
+
+        port = ParamUtils.getRequiredParamInt(parameters, "port");
+
+        Parameter hostParameter = inDescription.getParameter(TransportListener.HOST_ADDRESS);
+        if (hostParameter != null) {
+            host = ((String) hostParameter.getValue()).trim();
+        } else {
+            try {
+                host = java.net.InetAddress.getLocalHost().getHostName();
+            } catch (UnknownHostException e) {
+                log.warn("Unable to lookup local host name, using 'localhost'");
+            }
+        }
+
+        Parameter param = inDescription.getParameter(PassThroughConstants.WSDL_EPR_PREFIX);
+        if (param != null) {
+            serviceEPRPrefix = getServiceEPRPrefix(configurationContext, (String) param.getValue());
+            customEPRPrefix = (String) param.getValue();
+        } else {
+            serviceEPRPrefix = getServiceEPRPrefix(configurationContext, host, port);
+            customEPRPrefix = inDescription.getName() + "://" + host + ":" +
+                    (port == 80 ? "" : port) + "/";
+        }
+        
+        // create http Get processor
+        param = inDescription.getParameter(NhttpConstants.HTTP_GET_PROCESSOR);
+        if (param != null && param.getValue() != null) {
+            httpGetRequestProcessor = createHttpGetProcessor(param.getValue().toString());
+            if (httpGetRequestProcessor == null) {
+                handleException("Cannot create HttpGetRequestProcessor");
+            }
+        } 
+    }
+
+    public HttpParams getHttpParameters() {
+        return httpParameters;
+    }
+
+    public HttpProcessor getHttpProcessor() {
+        return httpProcessor;
+    }
+
+    public HttpResponseFactory getResponseFactory() {
+        return responseFactory;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public SourceConnections getSourceConnections() {
+        return sourceConnections;
+    }
+
+    public TransportInDescription getInDescription() {
+        return inDescription;
+    }
+
+    public String getServiceEPRPrefix() {
+        return serviceEPRPrefix;
+    }
+
+    public String getCustomEPRPrefix() {
+        return customEPRPrefix;
+    }
+    
+    
+    
+    public boolean isSsl() {
+		return ssl;
+	}
+
+	public void setSsl(boolean ssl) {
+		this.ssl = ssl;
+	}
+	
+	
+	
+	public HttpGetRequestProcessor getHttpGetRequestProcessor() {
+		return httpGetRequestProcessor;
+	}
+
+	/**
+     * Return the EPR prefix for services made available over this transport
+     * @param cfgCtx configuration context to retrieve the service context path
+     * @param wsdlEPRPrefix specified wsdlPrefix
+     *
+     * @return wsdlEPRPrefix for the listener
+     */
+    protected String getServiceEPRPrefix(ConfigurationContext cfgCtx, String wsdlEPRPrefix) {
+        return wsdlEPRPrefix +
+            (!cfgCtx.getServiceContextPath().startsWith("/") ? "/" : "") +
+            cfgCtx.getServiceContextPath() +
+            (!cfgCtx.getServiceContextPath().endsWith("/") ? "/" : "");
+    }
+
+    /**
+     * Return the EPR prefix for services made available over this transport
+     * @param cfgCtx configuration context to retrieve the service context path
+     * @param host name of the host
+     * @param port listening port
+     * @return wsdlEPRPrefix for the listener
+     */
+	protected String getServiceEPRPrefix(ConfigurationContext cfgCtx,
+			String host, int port) {
+		if (!ssl) {
+			return "http://"
+					+ host
+					+ (port == 80 ? "" : ":" + port)
+					+ (!cfgCtx.getServiceContextPath().startsWith("/") ? "/"
+							: "")
+					+ cfgCtx.getServiceContextPath()
+					+ (!cfgCtx.getServiceContextPath().endsWith("/") ? "/" : "");
+		} else {
+
+			return "https://"
+					+ host
+					+ (port == 443 ? "" : ":" + port)
+					+ (!cfgCtx.getServiceContextPath().startsWith("/") ? "/"
+							: "")
+					+ cfgCtx.getServiceContextPath()
+					+ (!cfgCtx.getServiceContextPath().endsWith("/") ? "/" : "");
+		}
+	}
+    
+    
+    
+    private HttpGetRequestProcessor createHttpGetProcessor(String str) throws AxisFault {
+        Object obj = null;
+        try {
+            obj = Class.forName(str).newInstance();
+        } catch (ClassNotFoundException e) {
+            handleException("Error creating WSDL processor", e);
+        } catch (InstantiationException e) {
+            handleException("Error creating WSDL processor", e);
+        } catch (IllegalAccessException e) {
+            handleException("Error creating WSDL processor", e);
+        }
+
+        if (obj instanceof HttpGetRequestProcessor) {
+            return (HttpGetRequestProcessor) obj;
+        } else {
+            handleException("Error creating WSDL processor. The HttpProcessor should be of type " +
+                    "org.apache.synapse.transport.nhttp.HttpGetRequestProcessor");
+        }
+
+        return null;
+    }
+    
+    private void handleException(String msg, Exception e) throws AxisFault {
+        log.error(msg, e);
+        throw new AxisFault(msg, e);
+    }
+    
+    private void handleException(String msg) throws AxisFault {
+        log.error(msg);
+        throw new AxisFault(msg);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLSender.java	(revision 1502663)
@@ -0,0 +1,341 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.transport.base.ParamUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.impl.nio.reactor.SSLSetupHandler;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.reactor.IOEventDispatch;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.params.HttpParams;
+
+import javax.net.ssl.*;
+import javax.xml.namespace.QName;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+
+public class PassThroughHttpSSLSender extends PassThroughHttpSender {
+    private Log log = LogFactory.getLog(PassThroughHttpSSLSender.class);
+
+    protected IOEventDispatch getEventDispatch(NHttpClientHandler handler,
+                                               SSLContext sslContext,
+                                               SSLSetupHandler sslIOSessionHandler,
+                                               HttpParams params,
+                                               TransportOutDescription transportOut)
+            throws AxisFault {
+
+        SSLTargetIOEventDispatch dispatch = new SSLTargetIOEventDispatch(handler, sslContext,
+                sslIOSessionHandler, params);
+        dispatch.setContextMap(getCustomSSLContexts(transportOut));
+        return dispatch;
+    }
+
+    /**
+     * Create the SSLContext to be used by this sender
+     *
+     * @param transportOut the Axis2 transport configuration
+     * @return the SSLContext to be used
+     * @throws org.apache.axis2.AxisFault if an error occurs
+     */
+    protected SSLContext getSSLContext(TransportOutDescription transportOut) throws AxisFault {
+
+        Parameter keyParam    = transportOut.getParameter("keystore");
+        Parameter trustParam  = transportOut.getParameter("truststore");
+
+        OMElement ksEle = null;
+        OMElement tsEle = null;
+
+        if (keyParam != null) {
+            ksEle = keyParam.getParameterElement().getFirstElement();
+        }
+
+        boolean noValidateCert = ParamUtils.getOptionalParamBoolean(transportOut,
+                "novalidatecert", false);
+
+        if (trustParam != null) {
+            if (noValidateCert) {
+                log.warn("Ignoring novalidatecert parameter since a truststore has been specified");
+            }
+            tsEle = trustParam.getParameterElement().getFirstElement();
+        }
+
+        return createSSLContext(ksEle, tsEle, noValidateCert);
+    }
+
+    /**
+     * Create the SSLIOSessionHandler to initialize the host name verification at the following
+     * levels, through an Axis2 transport configuration parameter as follows:
+     * HostnameVerifier - Default, DefaultAndLocalhost, Strict, AllowAll
+     *
+     * @param transportOut the Axis2 transport configuration
+     * @return the SSLIOSessionHandler to be used
+     * @throws AxisFault if a configuration error occurs
+     */
+    protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)
+            throws AxisFault {
+
+        final Parameter hostnameVerifier = transportOut.getParameter("HostnameVerifier");
+        if (hostnameVerifier != null) {
+            return createSSLIOSessionHandler(hostnameVerifier.getValue().toString());
+        } else {
+            return createSSLIOSessionHandler(null);
+        }
+    }
+
+    /**
+     * Looks for a transport parameter named customSSLProfiles and initializes zero or more
+     * custom SSLContext instances. The syntax for defining custom SSL profiles is as follows.
+     *
+     * <parameter name="customSSLProfiles>
+     *      <profile>
+     *          <servers>www.test.org:80, www.test2.com:9763</servers>
+     *          <KeyStore>
+     *              <Location>/path/to/identity/store</Location>
+     *              <Type>JKS</Type>
+     *              <Password>password</Password>
+     *              <KeyPassword>password</KeyPassword>
+     *          </KeyStore>
+     *          <TrustStore>
+     *              <Location>path/tp/trust/store</Location>
+     *              <Type>JKS</Type>
+     *              <Password>password</Password>
+     *          </TrustStore>
+     *      </profile>
+     * </parameter>
+     *
+     * Any number of profiles can be defined under the customSSLProfiles parameter.
+     *
+     * @param transportOut transport out description
+     * @return a map of server addresses and SSL contexts
+     * @throws AxisFault if at least on SSL profile is not properly configured
+     */
+    private Map<String, SSLContext> getCustomSSLContexts(TransportOutDescription transportOut)
+            throws AxisFault {
+
+        if (log.isDebugEnabled()) {
+            log.info("Loading custom SSL profiles for the HTTPS sender");
+        }
+
+        Parameter customProfilesParam = transportOut.getParameter("customSSLProfiles");
+        if (customProfilesParam == null) {
+            return null;
+        }
+
+        OMElement customProfilesElt = customProfilesParam.getParameterElement();
+        Iterator profiles = customProfilesElt.getChildrenWithName(new QName("profile"));
+        Map<String, SSLContext> contextMap = new HashMap<String, SSLContext>();
+        while (profiles.hasNext()) {
+            OMElement profile = (OMElement) profiles.next();
+            OMElement serversElt = profile.getFirstChildWithName(new QName("servers"));
+            if (serversElt == null || serversElt.getText() == null) {
+                String msg = "Each custom SSL profile must define at least one host:port " +
+                        "pair under the servers element";
+                log.error(msg);
+                throw new AxisFault(msg);
+            }
+
+            String[] servers = serversElt.getText().split(",");
+            OMElement ksElt = profile.getFirstChildWithName(new QName("KeyStore"));
+            OMElement trElt = profile.getFirstChildWithName(new QName("TrustStore"));
+            String noValCert = profile.getAttributeValue(new QName("novalidatecert"));
+            boolean novalidatecert = "true".equals(noValCert);
+            SSLContext sslContext = createSSLContext(ksElt, trElt, novalidatecert);
+
+            for (String server : servers) {
+                server = server.trim();
+                if (!contextMap.containsKey(server)) {
+                    contextMap.put(server, sslContext);
+                } else {
+                    log.warn("Multiple SSL profiles were found for the server : " + server + ". " +
+                            "Ignoring the excessive profiles.");
+                }
+            }
+        }
+
+        if (contextMap.size() > 0) {
+            log.info("Custom SSL profiles initialized for " + contextMap.size() + " servers");
+            return contextMap;
+        }
+        return null;
+    }
+
+    private SSLContext createSSLContext(OMElement keyStoreElt, OMElement trustStoreElt,
+                                        boolean novalidatecert) throws AxisFault {
+
+        KeyManager[] keymanagers  = null;
+        TrustManager[] trustManagers = null;
+
+
+        if (keyStoreElt != null) {
+            String location      = keyStoreElt.getFirstChildWithName(new QName("Location")).getText();
+            String type          = keyStoreElt.getFirstChildWithName(new QName("Type")).getText();
+            String storePassword = keyStoreElt.getFirstChildWithName(new QName("Password")).getText();
+            String keyPassword   = keyStoreElt.getFirstChildWithName(new QName("KeyPassword")).getText();
+
+            FileInputStream fis = null;
+            try {
+                KeyStore keyStore = KeyStore.getInstance(type);
+                fis = new FileInputStream(location);
+                log.info("Loading Identity Keystore from : " + location);
+
+                keyStore.load(fis, storePassword.toCharArray());
+                KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
+                    KeyManagerFactory.getDefaultAlgorithm());
+                kmfactory.init(keyStore, keyPassword.toCharArray());
+                keymanagers = kmfactory.getKeyManagers();
+
+            } catch (GeneralSecurityException gse) {
+                log.error("Error loading Keystore : " + location, gse);
+                throw new AxisFault("Error loading Keystore : " + location, gse);
+            } catch (IOException ioe) {
+                log.error("Error opening Keystore : " + location, ioe);
+                throw new AxisFault("Error opening Keystore : " + location, ioe);
+            } finally {
+                if (fis != null) {
+                    try {
+                        fis.close();
+                    } catch (IOException ignore) {}
+                }
+            }
+        }
+
+        if (trustStoreElt != null) {
+            if (novalidatecert) {
+                log.warn("Ignoring novalidatecert parameter since a truststore has been specified");
+            }
+
+            String location      = trustStoreElt.getFirstChildWithName(new QName("Location")).getText();
+            String type          = trustStoreElt.getFirstChildWithName(new QName("Type")).getText();
+            String storePassword = trustStoreElt.getFirstChildWithName(new QName("Password")).getText();
+
+            FileInputStream fis = null;
+            try {
+                KeyStore trustStore = KeyStore.getInstance(type);
+                fis = new FileInputStream(location);
+                log.info("Loading Trust Keystore from : " + location);
+
+                trustStore.load(fis, storePassword.toCharArray());
+                TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance(
+                    TrustManagerFactory.getDefaultAlgorithm());
+                trustManagerfactory.init(trustStore);
+                trustManagers = trustManagerfactory.getTrustManagers();
+
+            } catch (GeneralSecurityException gse) {
+                log.error("Error loading Key store : " + location, gse);
+                throw new AxisFault("Error loading Key store : " + location, gse);
+            } catch (IOException ioe) {
+                log.error("Error opening Key store : " + location, ioe);
+                throw new AxisFault("Error opening Key store : " + location, ioe);
+            } finally {
+                if (fis != null) {
+                    try {
+                        fis.close();
+                    } catch (IOException ignore) {}
+                }
+            }
+        } else if (novalidatecert) {
+            log.warn("Server certificate validation (trust) has been disabled. " +
+                    "DO NOT USE IN PRODUCTION!");
+            trustManagers = new TrustManager[] { new NoValidateCertTrustManager() };
+        }
+
+        try {
+            SSLContext sslcontext = SSLContext.getInstance("TLS");
+            sslcontext.init(keymanagers, trustManagers, null);
+            return sslcontext;
+
+        } catch (GeneralSecurityException gse) {
+            log.error("Unable to create SSL context with the given configuration", gse);
+            throw new AxisFault("Unable to create SSL context with the given configuration", gse);
+        }
+    }
+
+    private SSLSetupHandler createSSLIOSessionHandler(final String hostnameVerifier)
+            throws AxisFault {
+
+        return new SSLSetupHandler() {
+
+            public void initalize(SSLEngine sslengine, HttpParams params) {
+            }
+
+            public void verify(IOSession ioSession, SSLSession session) throws SSLException {
+                SocketAddress remoteAddress = ioSession.getRemoteAddress();
+                String address;
+                if (remoteAddress instanceof InetSocketAddress) {
+                    address = ((InetSocketAddress) remoteAddress).getHostName();
+                } else {
+                    address = remoteAddress.toString();
+                }
+
+                boolean valid = false;
+                if (hostnameVerifier != null) {
+                    if ("Strict".equals(hostnameVerifier)) {
+                        valid = HostnameVerifier.STRICT.verify(address, session);
+                    } else if ("AllowAll".equals(hostnameVerifier)) {
+                        valid = HostnameVerifier.ALLOW_ALL.verify(address, session);
+                    } else if ("DefaultAndLocalhost".equals(hostnameVerifier)) {
+                        valid = HostnameVerifier.DEFAULT_AND_LOCALHOST.verify(address, session);
+                    }
+                } else {
+                    valid = HostnameVerifier.DEFAULT.verify(address, session);
+                }
+
+                if (!valid) {
+                    throw new SSLException("Host name verification failed for host : " + address);
+                }
+            }
+        };
+    }
+
+    /**
+     * Trust manager accepting any certificate.
+     */
+    public static class NoValidateCertTrustManager implements X509TrustManager {
+        public void checkClientTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            // Do nothing: we accept any certificate
+        }
+
+        public void checkServerTrusted(X509Certificate[] chain, String authType)
+                throws CertificateException {
+            // Do nothing: we accept any certificate
+        }
+
+        public X509Certificate[] getAcceptedIssuers() {
+            return new X509Certificate[0];
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetContext.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetContext.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetContext.java	(revision 1502663)
@@ -0,0 +1,191 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axis2.context.MessageContext;
+import org.apache.http.nio.NHttpConnection;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+
+import java.nio.ByteBuffer;
+
+/**
+ * When a connection is created, an object of this class is stored in the Connection Context.
+ * It is used as a holder for information required during the life-cycle of this connection.
+ */
+public class TargetContext {
+    private TargetConfiguration targetConfiguration = null;
+
+    public static final String CONNECTION_INFORMATION = "CONNECTION_INFORMATION";
+    /** The request for this connection */
+    private TargetRequest request;
+    /** The response for this connection */
+    private TargetResponse response;
+    /** State of the connection */
+    private ProtocolState state;
+    /** The request message context */
+    private MessageContext requestMsgCtx;
+    /** The current reader */
+    private Pipe reader;
+    /** The current writer */
+    private Pipe writer;
+
+    public TargetContext(TargetConfiguration targetConfiguration) {
+        this.targetConfiguration = targetConfiguration;
+    }
+
+    public ProtocolState getState() {
+        return state;
+    }
+
+    public void setState(ProtocolState state) {
+        this.state = state;
+    }
+
+    public TargetRequest getRequest() {
+        return request;
+    }
+
+    public void setRequest(TargetRequest request) {
+        this.request = request;
+    }
+
+    public TargetResponse getResponse() {
+        return response;
+    }
+
+    public void setResponse(TargetResponse response) {
+        this.response = response;
+    }
+
+    public MessageContext getRequestMsgCtx() {
+        return requestMsgCtx;
+    }
+
+    public void setRequestMsgCtx(MessageContext requestMsgCtx) {
+        this.requestMsgCtx = requestMsgCtx;
+    }
+
+    public Pipe getReader() {
+        return reader;
+    }
+
+    public Pipe getWriter() {
+        return writer;
+    }
+
+    public void setReader(Pipe reader) {
+        this.reader = reader;
+    }
+
+    public void setWriter(Pipe writer) {
+        this.writer = writer;
+    }
+
+    public void reset() {
+        request = null;
+        response = null;
+        state = ProtocolState.REQUEST_READY;
+
+        if (writer != null) {
+            ByteBuffer buffer = writer.getBuffer();
+            buffer.clear();
+            targetConfiguration.getBufferFactory().release(buffer);
+        }
+
+        reader = null;
+        writer = null;       
+    }
+
+    public static void create(NHttpConnection conn, ProtocolState state, 
+                              TargetConfiguration configuration) {
+        TargetContext info = new TargetContext(configuration);
+
+        conn.getContext().setAttribute(CONNECTION_INFORMATION, info);
+
+        info.setState(state);
+    }
+
+    public static void updateState(NHttpConnection conn, ProtocolState state) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setState(state);
+        }  else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static boolean assertState(NHttpConnection conn, ProtocolState state) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null && info.getState() == state;
+
+    }
+
+    public static ProtocolState getState(NHttpConnection conn) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getState() : null;
+    }
+
+    public static void setRequest(NHttpConnection conn, TargetRequest request) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setRequest(request);
+        } else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static void setResponse(NHttpConnection conn, TargetResponse response) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setResponse(response);
+        } else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static TargetRequest getRequest(NHttpConnection conn) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getRequest() : null;
+    }
+
+    public static TargetResponse getResponse(NHttpConnection conn) {
+        TargetContext info = (TargetContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getResponse() : null;
+    }
+
+    public static TargetContext get(NHttpConnection conn) {
+        return (TargetContext) conn.getContext().getAttribute(CONNECTION_INFORMATION);
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLSourceIOEventDispatch.java	(revision 1502663)
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.impl.nio.reactor.SSLSetupHandler;
+import org.apache.http.impl.nio.ssl.SSLServerIOEventDispatch;
+import org.apache.http.nio.NHttpServerIOTarget;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.passthru.logging.LoggingUtils;
+
+import javax.net.ssl.SSLContext;
+
+public class SSLSourceIOEventDispatch extends SSLServerIOEventDispatch {
+
+    private HttpParams params = null;
+
+    public SSLSourceIOEventDispatch(NHttpServiceHandler handler,
+                                    SSLContext sslcontext,
+                                    SSLSetupHandler sslHandler,
+                                    HttpParams params) {
+        super(handler, sslcontext, sslHandler, params);
+        this.params = params;
+    }
+
+    @Override
+    protected NHttpServerIOTarget createConnection(IOSession session) {
+        session = LoggingUtils.decorate(session, "sslserver");
+        return LoggingUtils.createServerConnection(
+                session,
+                createHttpRequestFactory(),
+                createByteBufferAllocator(),
+                this.params);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayUtils.java	(revision 1502663)
@@ -0,0 +1,264 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMNode;
+import org.apache.axiom.om.OMText;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.addressing.AddressingConstants;
+import org.apache.axis2.addressing.AddressingHelper;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.WSDL2Constants;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.engine.Handler;
+import org.apache.axis2.engine.Phase;
+import org.apache.axis2.transport.RequestResponseTransport;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+import org.apache.synapse.transport.passthru.Pipe;
+import org.apache.synapse.transport.passthru.config.PassThroughConfiguration;
+
+import javax.activation.DataHandler;
+import javax.activation.DataSource;
+import javax.xml.stream.XMLStreamException;
+
+import java.io.BufferedInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+
+public class RelayUtils {
+
+   	private static final Log log = LogFactory.getLog(RelayUtils.class);
+	  
+    private static final DeferredMessageBuilder messageBuilder = new DeferredMessageBuilder();
+
+    private static volatile Handler addressingInHandler = null;
+    private static boolean noAddressingHandler = false;
+    
+    private static Boolean forcePTBuild = null;
+    
+
+    static{
+    	if(forcePTBuild == null){
+           forcePTBuild =PassThroughConfiguration.getInstance().getBooleanProperty(PassThroughConstants.FORCE_PASS_THROUGH_BUILDER);
+           if(forcePTBuild ==null){
+             forcePTBuild =true;
+           }
+        //this to keep track ignore the builder operation eventhough content level is enable.
+        }
+    }
+
+	public static void buildMessage(org.apache.axis2.context.MessageContext msgCtx) throws IOException,
+            XMLStreamException {
+
+        buildMessage(msgCtx, false);
+    }
+
+    public static void buildMessage(MessageContext messageContext, boolean earlyBuild) throws IOException,
+            XMLStreamException {
+
+        final Pipe pipe = (Pipe) messageContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+		if (pipe != null &&
+		    !Boolean.TRUE.equals(messageContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED)) &&
+		    forcePTBuild) {
+			InputStream in = pipe.getInputStream();
+        	
+        	builldMessage(messageContext, earlyBuild, in);
+            return;
+        }
+
+        SOAPEnvelope envelope = messageContext.getEnvelope();
+        OMElement contentEle = envelope.getBody().getFirstChildWithName(
+                RelayConstants.BINARY_CONTENT_QNAME);
+
+        if (contentEle != null) {
+            OMNode node = contentEle.getFirstOMChild();
+
+            if (node != null && (node instanceof OMText)) {
+                OMText binaryDataNode = (OMText) node;
+                DataHandler dh = (DataHandler) binaryDataNode.getDataHandler();
+                if (dh == null) {
+                    throw new AxisFault("Error while building message");
+                }
+
+                DataSource dataSource = dh.getDataSource();
+                //Ask the data source to stream, if it has not already cached the request
+                if (dataSource instanceof StreamingOnRequestDataSource) {
+                    ((StreamingOnRequestDataSource) dataSource).setLastUse(true);
+                }
+
+                InputStream in = dh.getInputStream();
+                OMElement element = messageBuilder.getDocument(messageContext, in);
+                if (element != null) {
+                    messageContext.setEnvelope(TransportUtils.createSOAPEnvelope(element));
+                    messageContext.setProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP,
+                            messageBuilder.getFormatters());
+
+                    if (!earlyBuild) {
+                        processAddressing(messageContext);
+                    }
+                }
+            }
+        }
+    }
+
+	public static void builldMessage(MessageContext messageContext, boolean earlyBuild, InputStream in) throws IOException, AxisFault {
+	    //
+	    BufferedInputStream bufferedInputStream= (BufferedInputStream) messageContext.getProperty(PassThroughConstants.BUFFERED_INPUT_STREAM);
+	    if(bufferedInputStream != null){
+	    	try{
+	    	  bufferedInputStream.reset();
+	    	  bufferedInputStream.mark(0);
+	    	}catch (Exception e) {
+	    		//just ignore the error
+			}
+          
+	    }else{
+	    		bufferedInputStream =new BufferedInputStream(in);
+		    	 //TODO: need to handle properly for the moment lets use around 100k buffer.
+			    bufferedInputStream.mark(128 * 1024);
+		    	messageContext.setProperty(PassThroughConstants.BUFFERED_INPUT_STREAM, bufferedInputStream);
+		  }
+	   
+	    OMElement element = null;
+	    try{
+	     element = messageBuilder.getDocument(messageContext, bufferedInputStream != null?bufferedInputStream:in);
+	    }catch (Exception e) {
+	    	log.error("Error while building Passthrough stream",e);
+	    }
+	    if (element != null) {
+	        messageContext.setEnvelope(TransportUtils.createSOAPEnvelope(element));
+	        messageContext.setProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP,
+	                messageBuilder.getFormatters());
+	        messageContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED,
+	                Boolean.TRUE);
+
+	        if (!earlyBuild) {
+	            processAddressing(messageContext);
+	        }
+	    }
+	    return;
+    }
+
+    private static void processAddressing(MessageContext messageContext) throws AxisFault {
+        if (noAddressingHandler) {
+            return;
+        } else if (addressingInHandler == null) {
+            synchronized (messageBuilder) {
+                if (addressingInHandler == null) {
+                    AxisConfiguration axisConfig = messageContext.getConfigurationContext().
+                            getAxisConfiguration();
+                    List<Phase> phases = axisConfig.getInFlowPhases();
+                    boolean handlerFound = false;
+                    for (Phase phase : phases) {
+                        if ("Addressing".equals(phase.getName())) {
+                            List<Handler> handlers = phase.getHandlers();
+                            for (Handler handler : handlers) {
+                                if ("AddressingInHandler".equals(handler.getName())) {
+                                    addressingInHandler = handler;
+                                    handlerFound = true;
+                                    break;
+                                }
+                            }
+                            break;
+                        }
+                    }
+
+                    if (!handlerFound) {
+                        noAddressingHandler = true;
+                        return;
+                    }
+                }
+            }
+        }
+
+        messageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_IN_MESSAGES, "false");
+        
+        Object disableAddressingForOutGoing = null;
+        if(messageContext.getProperty(
+                    AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES) != null){
+        	disableAddressingForOutGoing = messageContext.getProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES);
+        }
+        addressingInHandler.invoke(messageContext);
+        
+        if(disableAddressingForOutGoing !=null){
+        	messageContext.setProperty(AddressingConstants.DISABLE_ADDRESSING_FOR_OUT_MESSAGES, disableAddressingForOutGoing);
+        }
+
+        if (messageContext.getAxisOperation() == null) {
+            return;
+        }
+
+        String mepString = messageContext.getAxisOperation().getMessageExchangePattern();
+
+        if (isOneWay(mepString)) {
+            Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);
+            if (requestResponseTransport != null) {
+
+                Boolean disableAck = getDisableAck(messageContext);
+                if (disableAck == null || disableAck.booleanValue() == false) {
+                    ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);
+                }
+            }
+        } else if (AddressingHelper.isReplyRedirected(messageContext) && AddressingHelper.isFaultRedirected(messageContext)) {
+            if (mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)
+                    || mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)
+                    || mepString.equals(WSDL2Constants.MEP_URI_IN_OUT)) {
+                // OR, if 2 way operation but the response is intended to not use the response channel of a 2-way transport
+                // then we don't need to keep the transport waiting.
+
+                Object requestResponseTransport = messageContext.getProperty(RequestResponseTransport.TRANSPORT_CONTROL);
+                if (requestResponseTransport != null) {
+
+                    // We should send an early ack to the transport whenever possible, but some modules need
+                    // to use the back channel, so we need to check if they have disabled this code.
+                    Boolean disableAck = getDisableAck(messageContext);
+
+                    if (disableAck == null || disableAck.booleanValue() == false) {
+                        ((RequestResponseTransport) requestResponseTransport).acknowledgeMessage(messageContext);
+                    }
+
+                }
+            }
+        }
+    }
+
+    private static Boolean getDisableAck(MessageContext msgContext) throws AxisFault {
+       // We should send an early ack to the transport whenever possible, but some modules need
+       // to use the back channel, so we need to check if they have disabled this code.
+       Boolean disableAck = (Boolean) msgContext.getProperty(Constants.Configuration.DISABLE_RESPONSE_ACK);
+       if(disableAck == null) {
+          disableAck = (Boolean) (msgContext.getAxisService() != null ? msgContext.getAxisService().getParameterValue(Constants.Configuration.DISABLE_RESPONSE_ACK) : null);
+       }
+
+       return disableAck;
+    }
+
+    private static boolean isOneWay(String mepString) {
+        return (mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY)
+                || mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY)
+                || mepString.equals(WSDL2Constants.MEP_URI_IN_ONLY));
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelaySecurityMessageBuilderDispatchHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelaySecurityMessageBuilderDispatchHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelaySecurityMessageBuilderDispatchHandler.java	(revision 1502663)
@@ -0,0 +1,171 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMNamespace;
+import org.apache.axiom.om.OMNode;
+import org.apache.axiom.om.util.AXIOMUtil;
+import org.apache.axiom.soap.SOAPHeader;
+import org.apache.axiom.soap.SOAPHeaderBlock;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.HandlerDescription;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.engine.AbstractDispatcher;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.util.Utils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+import org.apache.synapse.transport.passthru.Pipe;
+
+public class RelaySecurityMessageBuilderDispatchHandler extends AbstractDispatcher{
+
+	private static final Log log = LogFactory.getLog(RelaySecurityMessageBuilderDispatchHandler.class);
+	
+	private static final String APPLICATION_XML = "application/xml";
+	private static final String WSSE = "wsse";
+	private static final String WSS_WSSECURITY_SECEXT_1_0_XSD = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd";
+	private static final String PROXY = "proxy";
+	private static final String SERVICE_TYPE = "serviceType";
+	public static final String NAME = "RelaySecurityMessageBuilderDispatchHandler";
+	
+	
+	@Override
+	public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {
+		InvocationResponse invocationResponse = super.invoke(messageContext);
+
+		EndpointReference toEPR = messageContext.getTo();
+
+		Pipe pipe = (Pipe) messageContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+		
+		if (pipe != null) {
+			if (toEPR != null) {
+
+				ConfigurationContext configurationContext = messageContext.getConfigurationContext();
+				AxisConfiguration registry = configurationContext.getAxisConfiguration();
+				String filePart = toEPR.getAddress();
+
+				if (filePart != null) {
+					String serviceOpPart = Utils.getServiceAndOperationPart(filePart,
+					                       messageContext.getConfigurationContext().getServiceContextPath());
+
+					AxisService axisService = null;
+
+					// only service context path onwards values will be taken
+					if (messageContext.getConfigurationContext().getServiceContextPath() != null &&
+					    serviceOpPart != null) {
+						axisService = registry.getService(serviceOpPart);
+						if (axisService != null) {
+							Parameter parameter = axisService.getParameter(SERVICE_TYPE);
+							if (parameter != null) {
+								if (!parameter.getValue().equals(PROXY)) {
+									build(messageContext);
+								}
+							} else {
+								build(messageContext);
+							}
+						}
+					}
+				}
+
+			}
+			if (messageContext.isEngaged(PassThroughConstants.SECURITY_MODULE_NAME)) {
+				SOAPHeader header = null;
+				if (messageContext.getEnvelope().getHeader() != null) {
+					header = messageContext.getEnvelope().getHeader();
+				}
+				build(messageContext);
+
+				this.handlePOXRequests(messageContext, header);
+
+			}
+		}
+
+		return invocationResponse;
+	}
+
+	private void handlePOXRequests(MessageContext messageContext, SOAPHeader header) {
+	    String contentType = (String) messageContext.getProperty(Constants.Configuration.CONTENT_TYPE);
+	    String _contentType =contentType;
+	    if (contentType != null) {
+	    	int j = contentType.indexOf(";");
+	    	if (j > 0) {
+	    		_contentType = contentType.substring(0, j);
+	    	}
+	    }
+	     
+	    //if the request message is a POX and if authenticate enables, which means a custom security header added to the SOAP header
+	    //and in PT case, since the message is getting build forcefully we need to make sure the POX security headers added by POXSecurityHandler
+	    //is existing in the newly build soap envelope.
+	    if(_contentType != null && _contentType.equals(APPLICATION_XML) && header != null && header.getChildElements() != null || messageContext.isDoingREST()){
+	    	try {
+	            OMElement element =AXIOMUtil.stringToOM(header.toString());
+	            OMNamespace omNamespace =  
+	            OMAbstractFactory.getOMFactory().createOMNamespace(WSS_WSSECURITY_SECEXT_1_0_XSD, WSSE); 
+	            SOAPHeaderBlock soapBloackingHeader = OMAbstractFactory.getSOAP12Factory().createSOAPHeaderBlock("Security",omNamespace);
+	            OMElement securityHeader = (OMElement) element.getFirstOMChild();
+	    		if (securityHeader != null) {
+	    			while (securityHeader.getChildElements().hasNext()) {
+	    				soapBloackingHeader.addChild((OMNode) securityHeader.getChildElements().next());
+	    			}
+
+	    			messageContext.getEnvelope().getHeader().addChild(soapBloackingHeader);
+	    		}
+	        } catch (Exception e) {
+	               log.error("Error while executing the message at relaySecurity handler", e);
+	        }
+	       
+	    }
+    }
+
+	private void build(MessageContext messageContext) {
+	    try {
+	    	RelayUtils.buildMessage(messageContext, false);
+	    } catch (Exception e) {
+	    	 log.error("Error while executing the message at relaySecurity handler", e);
+	    }
+    }
+
+	@Override
+	public AxisOperation findOperation(AxisService arg0, MessageContext arg1)
+			throws AxisFault {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public AxisService findService(MessageContext arg0) throws AxisFault {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public void initDispatcher() {
+		init(new HandlerDescription(NAME));
+	}
+	
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BufferFactory.java	(revision 1502663)
@@ -0,0 +1,83 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class BufferFactory {
+
+    private volatile ByteBuffer [] buffers;
+
+    private volatile int marker = -1;
+
+    private ByteBufferAllocator allocator = null;
+
+    private Lock lock = new ReentrantLock();
+
+    private int bufferSize = 1024 * 8;
+
+    public BufferFactory(int bufferSize, ByteBufferAllocator allocator, int size) {
+        this.bufferSize = bufferSize;
+        if (allocator != null) {
+            this.allocator = allocator;
+        } else {
+            this.allocator = new HeapByteBufferAllocator();
+        }
+
+        buffers = new ByteBuffer[size];
+    }
+
+    public ByteBuffer getBuffer() {
+        if (marker == -1) {
+            //System.out.println("allocating marker -1");
+            return allocator.allocate(bufferSize);
+        } else {
+            lock.lock();
+            try {
+                if (marker >= 0) {
+                    // System.out.println("Returning buffer");
+                    ByteBuffer b = buffers[marker];
+                    buffers[marker] = null;
+                    marker--;
+                    return b;
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        return allocator.allocate(bufferSize);
+    }
+
+    public void release(ByteBuffer buffer) {
+        lock.lock();
+        try {
+            if (marker < buffers.length - 1) {
+                buffers[++marker] = buffer;
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java	(revision 1502663)
@@ -0,0 +1,322 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.Constants;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.util.JavaUtils;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.http.protocol.HTTP;
+import org.apache.http.HttpStatus;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+
+import java.net.InetAddress;
+import java.net.SocketException;
+import java.net.NetworkInterface;
+import java.util.Map;
+import java.util.Iterator;
+import java.util.Enumeration;
+import java.util.Hashtable;
+
+/**
+ * Utility methods used by the transport.
+ */
+public class PassThroughTransportUtils {
+    private static Log log = LogFactory.getLog(PassThroughTransportUtils.class);
+
+    /**
+     * This method tries to determine the hostname of the given InetAddress without
+     * triggering a reverse DNS lookup.  {@link java.net.InetAddress#getHostName()}
+     * triggers a reverse DNS lookup which can be very costly in cases where reverse
+     * DNS fails. Tries to parse a symbolic hostname from {@link java.net.InetAddress#toString()},
+     * which is documented to return a String of the form "hostname / literal IP address"
+     * with 'hostname' blank if not already computed & stored in <code>address</code>.
+     * <p/>
+     * If the hostname cannot be determined from InetAddress.toString(),
+     * the value of {@link java.net.InetAddress#getHostAddress()} is returned.
+     *
+     * @param address The InetAddress whose hostname has to be determined
+     * @return hostsname, if it can be determined. hostaddress, if not.          
+     */
+    public static String getHostName(InetAddress address) {
+        String result;
+        String hostAddress = address.getHostAddress();
+        String inetAddr = address.toString();
+        int index1 = inetAddr.lastIndexOf('/');
+        int index2 = inetAddr.indexOf(hostAddress);
+        if (index2 == index1 + 1) {
+            if (index1 == 0) {
+                result = hostAddress;
+            } else {
+                result = inetAddr.substring(0, index1);
+            }
+        } else {
+            result = hostAddress;
+        }
+        return result;
+    }
+
+    /**
+     * Get the EPR for the message passed in
+     * @param msgContext the message context
+     * @return the destination EPR
+     */
+    public static EndpointReference getDestinationEPR(MessageContext msgContext) {
+
+        // Trasnport URL can be different from the WSA-To
+        String transportURL = (String) msgContext.getProperty(
+            Constants.Configuration.TRANSPORT_URL);
+
+        if (transportURL != null) {
+            return new EndpointReference(transportURL);
+        } else if (
+            (msgContext.getTo() != null) && !msgContext.getTo().hasAnonymousAddress()) {
+            return msgContext.getTo();
+        }
+        return null;
+    }
+
+    /**
+     * Remove unwanted headers from the http response of outgoing request. These are headers which
+     * should be dictated by the transport and not the user. We remove these as these may get
+     * copied from the request messages
+     * 
+     * @param msgContext the Axis2 Message context from which these headers should be removed
+     * @param preserveServerHeader if true preserve the original server header
+     * @param preserveUserAgentHeader if true preserve the original user-agent header
+     */
+    public static void removeUnwantedHeaders(MessageContext msgContext,
+                                             boolean preserveServerHeader,
+                                             boolean preserveUserAgentHeader) {
+        Map headers = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);
+
+        if (headers == null || headers.isEmpty()) {
+            return;
+        }
+
+        Iterator iter = headers.keySet().iterator();
+        while (iter.hasNext()) {
+            String headerName = (String) iter.next();
+            if (HTTP.CONN_DIRECTIVE.equalsIgnoreCase(headerName) ||
+                HTTP.TRANSFER_ENCODING.equalsIgnoreCase(headerName) ||
+                HTTP.DATE_HEADER.equalsIgnoreCase(headerName) ||
+                HTTP.CONTENT_LEN.equalsIgnoreCase(headerName) ||
+                HTTP.CONN_KEEP_ALIVE.equalsIgnoreCase(headerName)) {
+                iter.remove();
+            }
+
+            if (!preserveServerHeader && HTTP.SERVER_HEADER.equalsIgnoreCase(headerName)) {
+                iter.remove();
+            }
+
+            if (!preserveUserAgentHeader && HTTP.USER_AGENT.equalsIgnoreCase(headerName)) {
+                iter.remove();
+            }
+        }
+    }
+
+    /**
+     * Determine the Http Status Code depending on the message type processed <br>
+     * (normal response versus fault response) as well as Axis2 message context properties set
+     * via Synapse configuration or MessageBuilders.
+     *
+     * @see PassThroughConstants#FAULTS_AS_HTTP_200
+     * @see PassThroughConstants#HTTP_SC
+     *
+     * @param msgContext the Axis2 message context
+     *
+     * @return the HTTP status code to set in the HTTP response object
+     */
+    public static int determineHttpStatusCode(MessageContext msgContext) {
+
+        int httpStatus = HttpStatus.SC_OK;
+
+        // if this is a dummy message to handle http 202 case with non-blocking IO
+        // set the status code to 202
+        if (msgContext.isPropertyTrue(PassThroughConstants.SC_ACCEPTED)) {
+            httpStatus = HttpStatus.SC_ACCEPTED;
+        } else {
+            // is this a fault message
+            boolean handleFault = msgContext.getEnvelope() != null ?
+                (msgContext.getEnvelope().getBody().hasFault() || msgContext.isProcessingFault()):false;
+
+            // shall faults be transmitted with HTTP 200
+            boolean faultsAsHttp200 =
+                PassThroughConstants.TRUE.equals(
+                    msgContext.getProperty(PassThroughConstants.FAULTS_AS_HTTP_200));
+
+            // Set HTTP status code to 500 if this is a fault case and we shall not use HTTP 200
+            if (handleFault && !faultsAsHttp200) {
+                httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR;
+            }
+
+            // Any status code previously set shall be overwritten with the value of the following
+            // message context property if it is set.
+            Object statusCode = msgContext.getProperty(PassThroughConstants.HTTP_SC);
+            if (statusCode != null) {
+                try {
+                    httpStatus = Integer.parseInt(
+                            msgContext.getProperty(PassThroughConstants.HTTP_SC).toString());
+                } catch (NumberFormatException e) {
+                    log.warn("Unable to set the HTTP status code from the property "
+                            + PassThroughConstants.HTTP_SC + " with value: " + statusCode);
+                }
+            }
+        }
+
+        return httpStatus;
+    }
+
+    /**
+     * Whatever this method returns as the IP is ignored by the actual http/s listener when
+     * its getServiceEPR is invoked. This was originally copied from axis2
+     *
+     * @return Returns String.
+     * @throws java.net.SocketException if the socket can not be accessed
+     */
+    public static String getIpAddress() throws SocketException {
+        Enumeration e = NetworkInterface.getNetworkInterfaces();
+        String address = "127.0.0.1";
+
+        while (e.hasMoreElements()) {
+            NetworkInterface netface = (NetworkInterface) e.nextElement();
+            Enumeration addresses = netface.getInetAddresses();
+
+            while (addresses.hasMoreElements()) {
+                InetAddress ip = (InetAddress) addresses.nextElement();
+                if (!ip.isLoopbackAddress() && isIP(ip.getHostAddress())) {
+                    return ip.getHostAddress();
+                }
+            }
+        }
+        return address;
+    }
+
+    private static boolean isIP(String hostAddress) {
+        return hostAddress.split("[.]").length == 4;
+    }
+
+
+    /**
+     * Returns the HTML text for the list of services deployed.
+     * This can be delegated to another Class as well
+     * where it will handle more options of GET messages.
+     *
+     * @param prefix to be used for the Service names
+     * @param cfgCtx axis2 configuration context
+     * @return the HTML to be displayed as a String
+     */
+    public String getServicesHTML(String prefix, ConfigurationContext cfgCtx) {
+
+        Map services = cfgCtx.getAxisConfiguration().getServices();
+        Hashtable erroneousServices = cfgCtx.getAxisConfiguration().getFaultyServices();
+        boolean servicesFound = false;
+
+        StringBuffer resultBuf = new StringBuffer();
+        resultBuf.append("<html><head><title>Axis2: Services</title></head>" + "<body>");
+
+        if ((services != null) && !services.isEmpty()) {
+
+            servicesFound = true;
+            resultBuf.append("<h2>" + "Deployed services" + "</h2>");
+
+            for (Object service : services.values()) {
+
+                AxisService axisService = (AxisService) service;
+                Parameter parameter = axisService.getParameter(
+                        PassThroughConstants.HIDDEN_SERVICE_PARAM_NAME);
+                if (axisService.getName().startsWith("__") ||
+                        (parameter != null && JavaUtils.isTrueExplicitly(parameter.getValue()))) {
+                    continue;    // skip private services
+                }
+
+                Iterator iterator = axisService.getOperations();
+                resultBuf.append("<h3><a href=\"").append(prefix).append(axisService.getName()).append(
+                        "?wsdl\">").append(axisService.getName()).append("</a></h3>");
+
+                if (iterator.hasNext()) {
+                    resultBuf.append("Available operations <ul>");
+
+                    for (; iterator.hasNext();) {
+                        AxisOperation axisOperation = (AxisOperation) iterator.next();
+                        resultBuf.append("<li>").append(
+                                axisOperation.getName().getLocalPart()).append("</li>");
+                    }
+                    resultBuf.append("</ul>");
+                } else {
+                    resultBuf.append("No operations specified for this service");
+                }
+            }
+        }
+
+        if ((erroneousServices != null) && !erroneousServices.isEmpty()) {
+            servicesFound = true;
+            resultBuf.append("<hr><h2><font color=\"blue\">Faulty Services</font></h2>");
+            Enumeration faultyservices = erroneousServices.keys();
+
+            while (faultyservices.hasMoreElements()) {
+                String faultyserviceName = (String) faultyservices.nextElement();
+                resultBuf.append("<h3><font color=\"blue\">").append(
+                        faultyserviceName).append("</font></h3>");
+            }
+        }
+
+        if (!servicesFound) {
+            resultBuf.append("<h2>There are no services deployed</h2>");
+        }
+
+        resultBuf.append("</body></html>");
+        return resultBuf.toString();
+    }
+
+    public static OMOutputFormat getOMOutputFormat(MessageContext msgContext) {
+
+    	OMOutputFormat format = null;
+    	if(msgContext.getProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT) != null){
+    		format = (OMOutputFormat) msgContext.getProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT);
+    	}else{
+    		format = new OMOutputFormat();
+    	}
+     
+        msgContext.setDoingMTOM(TransportUtils.doWriteMTOM(msgContext));
+        msgContext.setDoingSwA(TransportUtils.doWriteSwA(msgContext));
+        msgContext.setDoingREST(TransportUtils.isDoingREST(msgContext));
+        format.setSOAP11(msgContext.isSOAP11());
+        format.setDoOptimize(msgContext.isDoingMTOM());
+        format.setDoingSWA(msgContext.isDoingSwA());
+
+        format.setCharSetEncoding(TransportUtils.getCharSetEncoding(msgContext));
+        Object mimeBoundaryProperty = msgContext.getProperty(Constants.Configuration.MIME_BOUNDARY);
+        if (mimeBoundaryProperty != null) {
+            format.setMimeBoundary((String) mimeBoundaryProperty);
+        }
+
+        return format;
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/ExpandingMessageFormatter.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/ExpandingMessageFormatter.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/ExpandingMessageFormatter.java	(revision 1502663)
@@ -0,0 +1,235 @@
+/*
+ *  Copyright 2013 Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.*;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.transport.http.SOAPMessageFormatter;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.util.DeferredMessageBuilder;
+
+import javax.activation.DataHandler;
+import javax.activation.DataSource;
+import javax.xml.stream.XMLStreamException;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.Map;
+
+
+public class ExpandingMessageFormatter extends SOAPMessageFormatter {
+
+    private Log log = LogFactory.getLog(ExpandingMessageFormatter.class);
+
+    private static final String MESSAGE_AS_BYTES = "MESSAGE_AS_BYTES";
+
+    @Override
+    public byte[] getBytes(MessageContext messageContext, OMOutputFormat format)
+            throws AxisFault {
+        SOAPEnvelope envelope = messageContext.getEnvelope();
+        if (hasASoapMessageEmbedded(envelope)) {
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            findAndWrite2OutputStream(messageContext, out, false);
+            return out.toByteArray();
+        } else {
+            return super.getBytes(messageContext, format);
+        }
+    }
+
+    @Override
+    public String getContentType(MessageContext msgCtx, OMOutputFormat format,
+                                 String soapActionString) {
+        String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);
+        if (contentType == null) {
+            MessageFormatter formatter = getMessageFormatter(msgCtx);
+            if (formatter != null) {
+                contentType = formatter.getContentType(msgCtx, format, soapActionString);
+            } else {
+                String messageType = getMessageFormatterProperty(msgCtx);
+                if (messageType.equals(HTTPConstants.MEDIA_TYPE_X_WWW_FORM)) {
+                    contentType = messageType;
+                    String encoding = format.getCharSetEncoding();
+                    if (encoding != null) {
+                        contentType = "; charset=" + encoding;
+                    }
+                } else {
+                    contentType = super.getContentType(msgCtx, format, soapActionString);
+                }
+            }
+        }
+        return contentType;
+    }
+
+    @Override
+    public void writeTo(MessageContext messageContext, OMOutputFormat format,
+                        OutputStream outputStream, boolean preserve) throws AxisFault {
+
+        try {
+            byte[] messageAsBytes = (byte[]) messageContext.getOperationContext().
+                    getProperty(MESSAGE_AS_BYTES);
+            if (messageAsBytes != null) {
+                outputStream.write(messageAsBytes);
+            } else {
+                SOAPEnvelope envelope = messageContext.getEnvelope();
+                Object forcedFormatter;
+                if (hasASoapMessageEmbedded(envelope)) {
+                    findAndWrite2OutputStream(messageContext, outputStream, preserve);
+                } else if ((forcedFormatter = messageContext.
+                        getProperty(DeferredMessageBuilder.FORCED_RELAY_FORMATTER)) != null) {
+                    /** If a formatter is forced by the builder mediator or some other means,
+                     *  it gets preference */
+                    if (forcedFormatter instanceof MessageFormatter) {
+                        ((MessageFormatter) forcedFormatter).writeTo(messageContext, format, outputStream, preserve);
+                    } else {
+                        String msg = "Invalid formatter is forced by " +
+                                DeferredMessageBuilder.FORCED_RELAY_FORMATTER + " property.";
+                        log.error(msg);
+                        throw new AxisFault(msg);
+                    }
+                } else {
+                    if (messageContext.isDoingREST()) {
+                        writeAsREST(messageContext, format, outputStream, preserve);
+                    } else {
+                        // try to get the formatters from the map set by the builder mediator or
+                        // SkipAdminHandler
+                        MessageFormatter formatter = getMessageFormatter(messageContext);
+                        if (formatter != null) {
+                            formatter.writeTo(messageContext, format,
+                                    outputStream, preserve);
+                        } else {
+                            super.writeTo(messageContext, format, outputStream, preserve);
+                        }
+                    }
+                }
+            }
+        } catch (IOException e) {
+            throw AxisFault.makeFault(e);
+        }
+    }
+
+    @Override
+    public URL getTargetAddress(MessageContext msgCtx, OMOutputFormat format, URL targetURL) throws AxisFault {
+        if (!msgCtx.isDoingREST()) {
+            return super.getTargetAddress(msgCtx, format, targetURL);
+        }
+
+        return targetURL;
+    }
+
+    public void writeAsREST(MessageContext messageContext, OMOutputFormat format,
+                            OutputStream outputStream, boolean preserve) throws AxisFault {
+        OMElement element = messageContext.getEnvelope().getBody().getFirstElement();
+        try {
+            if (element != null) {
+                if (preserve) {
+                    element.serialize(outputStream, format);
+                } else {
+                    element.serializeAndConsume(outputStream, format);
+                }
+            }
+            outputStream.flush();
+        } catch (XMLStreamException e) {
+            String msg = "Error writing Rest message";
+            log.error(msg, e);
+            throw new AxisFault(msg, e);
+        } catch (IOException e) {
+            String msg = "Error writing text message to stream";
+            log.error(msg);
+            throw new AxisFault(msg, e);
+        }
+    }
+
+    private boolean hasASoapMessageEmbedded(SOAPEnvelope envelope) {
+        OMElement contentEle = envelope.getBody().getFirstElement();
+        return contentEle != null && contentEle.getQName().equals(RelayConstants.BINARY_CONTENT_QNAME);
+    }
+
+    private void findAndWrite2OutputStream(MessageContext messageContext,
+                                           OutputStream out,
+                                           boolean preserve) throws AxisFault {
+        try {
+            SOAPEnvelope envelope = messageContext.getEnvelope();
+            OMElement contentEle = envelope.getBody().getFirstElement();
+            if (contentEle != null) {
+                OMNode node = contentEle.getFirstOMChild();
+                if (!(node instanceof OMText)) {
+                    String msg = "Wrong Input for the Validator, " +
+                            "the content of the first child element of the Body " +
+                            "should have the zip file";
+                    log.error(msg);
+                    throw new AxisFault(msg);
+                }
+                OMText binaryDataNode = (OMText) node;
+                DataHandler dh = (DataHandler) binaryDataNode.getDataHandler();
+
+                DataSource dataSource = dh.getDataSource();
+                //Ask the data source to stream, if it has not already cached the request
+                if (!preserve && dataSource instanceof StreamingOnRequestDataSource) {
+                    ((StreamingOnRequestDataSource) dataSource).setLastUse(true);
+                }
+                dh.writeTo(out);
+            }
+        } catch (OMException e) {
+            log.error(e);
+            throw AxisFault.makeFault(e);
+        } catch (IOException e) {
+            log.error(e);
+            throw AxisFault.makeFault(e);
+        }
+    }
+
+    private static String getMessageFormatterProperty(MessageContext msgContext) {
+        String messageFormatterProperty = null;
+        Object property = msgContext
+                .getProperty(Constants.Configuration.MESSAGE_TYPE);
+        if (property != null) {
+            messageFormatterProperty = (String) property;
+        }
+        if (messageFormatterProperty == null) {
+            Parameter parameter = msgContext
+                    .getParameter(Constants.Configuration.MESSAGE_TYPE);
+            if (parameter != null) {
+                messageFormatterProperty = (String) parameter.getValue();
+            }
+        }
+        return messageFormatterProperty;
+    }
+
+    private static MessageFormatter getMessageFormatter(MessageContext messageContext) {
+
+        Object o = messageContext.getProperty(DeferredMessageBuilder.RELAY_FORMATTERS_MAP);
+        if (o != null && o instanceof Map) {
+            Map map = (Map) o;
+            String messageFormatString =
+                    getMessageFormatterProperty(messageContext);
+            if (messageFormatString != null) {
+                return (MessageFormatter)
+                        map.get(messageFormatString);
+            }
+        }
+
+        return null;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java	(revision 1502663)
@@ -0,0 +1,79 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
+import org.apache.synapse.transport.nhttp.util.NhttpUtil;
+import org.apache.synapse.transport.passthru.SourceRequest;
+import org.apache.synapse.transport.passthru.SourceResponse;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class SourceResponseFactory {
+
+    public static SourceResponse create(MessageContext msgContext,
+                                        SourceRequest sourceRequest,
+                                        SourceConfiguration sourceConfiguration) {
+        // determine the status code to be sent
+        int statusCode = PassThroughTransportUtils.determineHttpStatusCode(msgContext);
+
+        SourceResponse sourceResponse =
+                new SourceResponse(sourceConfiguration, statusCode, sourceRequest);
+
+        // set any transport headers
+        Map transportHeaders = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);
+
+        if (transportHeaders != null) {
+            addResponseHeader(sourceResponse, transportHeaders);
+        }else{
+        	  Boolean noEntityBody = (Boolean) msgContext.getProperty(NhttpConstants.NO_ENTITY_BODY);
+        	 if (noEntityBody == null || Boolean.FALSE == noEntityBody) {
+        		 OMOutputFormat format = NhttpUtil.getOMOutputFormat(msgContext);
+        		 transportHeaders = new HashMap();
+            	 MessageFormatter messageFormatter =
+                     MessageFormatterDecoratorFactory.createMessageFormatterDecorator(msgContext);
+            	 transportHeaders.put(HTTP.CONTENT_TYPE, messageFormatter.getContentType(msgContext, format, msgContext.getSoapAction()));
+            	 addResponseHeader(sourceResponse, transportHeaders);
+             }
+        	 
+        }
+
+        return sourceResponse;
+    }
+
+	private static void addResponseHeader(SourceResponse sourceResponse, Map transportHeaders) {
+	    for (Object entryObj : transportHeaders.entrySet()) {
+	        Map.Entry entry = (Map.Entry) entryObj;
+	        if (entry.getValue() != null && entry.getKey() instanceof String &&
+	                entry.getValue() instanceof String) {
+	            sourceResponse.addHeader((String) entry.getKey(), (String) entry.getValue());
+	        }
+	    }
+    }
+    
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java	(revision 1502663)
@@ -0,0 +1,170 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+//import org.apache.axis2.util.MessageProcessorSelector;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.transport.http.SOAPMessageFormatter;
+import org.apache.axis2.util.MessageProcessorSelector;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpVersion;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+import org.apache.synapse.transport.passthru.TargetRequest;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Map;
+
+public class TargetRequestFactory {
+    
+	private static Log log = LogFactory.getLog(TargetRequestFactory.class);
+
+    public static TargetRequest create(MessageContext msgContext,
+                                       TargetConfiguration configuration) throws AxisFault {
+        try {
+            String httpMethod = (String) msgContext.getProperty(
+                    Constants.Configuration.HTTP_METHOD);
+            if (httpMethod == null) {
+                httpMethod = "POST";
+            }
+
+            // basic request
+            Boolean noEntityBody = (Boolean) msgContext.getProperty(PassThroughConstants.NO_ENTITY_BODY);
+            
+            if(msgContext.getEnvelope().getBody().getFirstElement() != null){
+            	noEntityBody  =false;
+            }
+
+            EndpointReference epr = PassThroughTransportUtils.getDestinationEPR(msgContext);
+            URL url = new URL(epr.getAddress());
+            TargetRequest request = new TargetRequest(configuration, url, httpMethod,
+                    noEntityBody == null || !noEntityBody);
+
+            // headers
+            PassThroughTransportUtils.removeUnwantedHeaders(msgContext,
+                    configuration.isPreserveServerHeader(),
+                    configuration.isPreserveUserAgentHeader());
+
+
+            Object o = msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);
+            if (o != null && o instanceof Map) {
+                Map headers = (Map) o;
+
+                for (Object entryObj : headers.entrySet()) {
+                    Map.Entry entry = (Map.Entry) entryObj;
+                    if (entry.getValue() != null && entry.getKey() instanceof String &&
+                            entry.getValue() instanceof String) {
+                        if (!HTTPConstants.HEADER_HOST.equalsIgnoreCase((String) entry.getKey())) {
+                            request.addHeader((String) entry.getKey(), (String) entry.getValue());
+                        }else {
+                            if(msgContext.getProperty(NhttpConstants.REQUEST_HOST_HEADER) != null) {
+                            	request.addHeader((String) (String) entry.getKey(),
+                                        (String)msgContext.getProperty(NhttpConstants.REQUEST_HOST_HEADER));
+                            }
+                        }
+                    }
+                }
+            }
+
+            String cType = getContentType(msgContext);
+            if (cType != null) {
+                request.addHeader(HTTP.CONTENT_TYPE, cType);
+            }
+
+            // version
+            String forceHttp10 = (String) msgContext.getProperty(PassThroughConstants.FORCE_HTTP_1_0);
+            if ("true".equals(forceHttp10)) {
+                request.setVersion(HttpVersion.HTTP_1_0);
+            }
+
+            // keep alive
+            String noKeepAlie = (String) msgContext.getProperty(PassThroughConstants.NO_KEEPALIVE);
+            if ("true".equals(noKeepAlie)) {
+                request.setKeepAlive(false);
+            }
+
+            // port
+            int port = url.getPort();
+            request.setPort(port != -1 ? port : 80);
+
+            // chunk
+            String disableChunking = (String) msgContext.getProperty(
+                    PassThroughConstants.DISABLE_CHUNKING);
+            if ("true".equals(disableChunking)) {
+                request.setChunk(false);
+            }
+
+            // full url
+            String fullUrl = (String) msgContext.getProperty(PassThroughConstants.FULL_URI);
+            if ("true".equals(fullUrl)) {
+                request.setFullUrl(true);                
+            }
+
+            return request;
+        } catch (MalformedURLException e) {
+            handleException("Invalid to address" + msgContext.getTo().getAddress(), e);
+        }
+
+        return null;
+    }
+
+    private static String getContentType(MessageContext msgCtx) throws AxisFault {
+        MessageFormatter formatter = MessageProcessorSelector.getMessageFormatter(msgCtx);
+        OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgCtx);
+        
+        if (formatter != null) {
+            String contentType= formatter.getContentType(msgCtx, format, msgCtx.getSoapAction());
+          //keep the formatter information to prevent multipart boundary override (this will be the content writing to header)
+            msgCtx.setProperty(PassThroughConstants.MESSAGE_OUTPUT_FORMAT, format);
+            return contentType;
+            
+        } else {
+            String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);
+            if (contentType != null) {
+                return contentType;
+            } else {
+                return new SOAPMessageFormatter().getContentType(
+                        msgCtx, format,  msgCtx.getSoapAction());
+            }
+        }
+    }
+
+    /**
+     * Throws an AxisFault if an error occurs at this level
+     * @param s a message describing the error
+     * @param e original exception leads to the error condition
+     * @throws org.apache.axis2.AxisFault wrapping the original exception
+     */
+    private static void handleException(String s, Exception e) throws AxisFault {
+        log.error(s, e);
+        throw new AxisFault(s, e);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpListener.java	(revision 1502663)
@@ -0,0 +1,430 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.SessionContext;
+import org.apache.axis2.description.*;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.engine.AxisEvent;
+import org.apache.axis2.engine.AxisObserver;
+import org.apache.axis2.transport.TransportListener;
+import org.apache.axis2.transport.base.BaseConstants;
+import org.apache.axis2.transport.base.BaseUtils;
+import org.apache.axis2.transport.base.threads.NativeThreadFactory;
+import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.axis2.util.JavaUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.impl.nio.reactor.DefaultListeningIOReactor;
+import org.apache.http.impl.nio.reactor.SSLIOSessionHandler;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.reactor.IOEventDispatch;
+import org.apache.http.nio.reactor.IOReactorException;
+import org.apache.http.nio.reactor.IOReactorExceptionHandler;
+import org.apache.http.nio.reactor.ListenerEndpoint;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+import org.apache.synapse.transport.passthru.jmx.MBeanRegistrar;
+import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
+import org.apache.synapse.transport.passthru.jmx.TransportView;
+
+import javax.net.ssl.SSLContext;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This is the TransportListener listening for incoming connections. This class start the IOReactor
+ * and registers the InRequest Handlers on it.
+ */
+public class PassThroughHttpListener implements TransportListener {
+
+    protected Log log = LogFactory.getLog(this.getClass());
+
+    /** The reactor being used */
+    private DefaultListeningIOReactor ioReactor;
+
+    /** The configuration of the listener */
+    private SourceConfiguration sourceConfiguration = null;
+
+    /** SSLContext if this listener is a SSL listener */
+    private SSLContext sslContext = null;
+    
+    /** The SSL session handler that manages client authentication etc */
+    private SSLIOSessionHandler sslIOSessionHandler = null;
+
+    /** The custom URI map for the services if there are any */
+    private Map<String, String> serviceNameToEPRMap = new HashMap<String, String>();
+    /** The service name map for the custom URI if there are any */
+    private Map<String, String> eprToServiceNameMap = new HashMap<String, String>();
+    /** the axis observer that gets notified of service life cycle events*/
+    private final AxisObserver axisObserver = new GenericAxisObserver();
+
+    private volatile int state = BaseConstants.STOPPED;
+
+    private String namePrefix;
+
+    public void init(ConfigurationContext cfgCtx, TransportInDescription transportInDescription)
+            throws AxisFault {
+
+        log.info("Initializing Pass-through HTTP/S Listener...");
+        
+        int portOffset = Integer.parseInt(System.getProperty("portOffset", "0"));
+        Parameter portParam = transportInDescription.getParameter("port");
+        int port = Integer.parseInt(portParam.getValue().toString());
+        port = port + portOffset;
+        portParam.setValue(String.valueOf(port));
+        portParam.getParameterElement().setText(String.valueOf(port));
+
+        Object obj = cfgCtx.getProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL);
+        WorkerPool workerPool = null;
+        if (obj != null) {
+            workerPool = (WorkerPool) obj;
+        }
+
+        // is this a SSL listener?
+        sslContext = getSSLContext(transportInDescription);
+        sslIOSessionHandler = getSSLIOSessionHandler(transportInDescription);
+
+        namePrefix = (sslContext == null) ? "HTTP" : "HTTPS";
+
+        sourceConfiguration = new SourceConfiguration(cfgCtx, transportInDescription, workerPool);
+        sourceConfiguration.setSsl((sslContext == null) ? false :true);
+        sourceConfiguration.build();
+
+        // register to receive updates on services for lifetime management
+        cfgCtx.getAxisConfiguration().addObservers(axisObserver);
+        cfgCtx.setProperty(PassThroughConstants.EPR_TO_SERVICE_NAME_MAP, eprToServiceNameMap);
+
+        cfgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL,
+                sourceConfiguration.getWorkerPool());
+
+        PassThroughTransportMetricsCollector metrics = new PassThroughTransportMetricsCollector(
+                                                            true, sslContext != null);
+
+        MBeanRegistrar.getInstance().registerMBean(
+                new TransportView(this, null, metrics, null), "Transport",
+                "passthru-" + namePrefix.toLowerCase() + "-receiver");
+        sourceConfiguration.setMetrics(metrics);
+    }
+
+    public void start() throws AxisFault {
+
+        log.info("Starting Pass-through " + namePrefix + " Listener...");
+
+        try {
+            String prefix = namePrefix + "-Listener I/O dispatcher";
+
+            ioReactor = new DefaultListeningIOReactor(
+                            sourceConfiguration.getIOThreadsPerReactor(),
+                            new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix),
+                            sourceConfiguration.getHttpParameters());
+            
+            ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {
+
+                public boolean handle(IOException ioException) {
+                    log.warn("System may be unstable: " + namePrefix +
+                            " ListeningIOReactor encountered a checked exception : " +
+                            ioException.getMessage(), ioException);
+                    return true;
+                }
+
+                public boolean handle(RuntimeException runtimeException) {
+                    log.warn("System may be unstable: " + namePrefix +
+                            " ListeningIOReactor encountered a runtime exception : "
+                            + runtimeException.getMessage(), runtimeException);
+                    return true;
+                }
+            });
+
+        } catch (IOReactorException e) {
+            handleException("Error starting " + namePrefix + " ListeningIOReactor", e);
+        }
+
+        SourceHandler handler = new SourceHandler(sourceConfiguration);
+
+        final IOEventDispatch ioEventDispatch = getEventDispatch(handler, sslContext,
+                                      sslIOSessionHandler, sourceConfiguration.getHttpParameters());
+
+        ListenerEndpoint endpoint = ioReactor.listen(
+                                      new InetSocketAddress(sourceConfiguration.getPort()));
+        
+        if(sourceConfiguration.getHttpGetRequestProcessor() != null){
+           sourceConfiguration.getHttpGetRequestProcessor().init(sourceConfiguration.getConfigurationContext(), handler);
+        }
+
+        Thread t = new Thread(new Runnable() {
+            public void run() {
+                try {
+                    ioReactor.execute(ioEventDispatch);
+                } catch (Exception e) {
+                    log.fatal("Exception encountered in the " + namePrefix + " Listener. " +
+                            "No more connections will be accepted by this transport", e);
+                }
+                log.info(namePrefix + " Listener shutdown.");
+            }
+        }, "PassThrough" + namePrefix + "Listener");
+        t.start();
+
+        try {
+            endpoint.waitFor();
+        } catch (InterruptedException e) {
+            log.warn("PassThroughHttpListener start event was interrupted", e);
+        }
+
+        state = BaseConstants.STARTED;
+
+        log.info("Pass-through " + namePrefix + " Listener " + "started on port : " +
+                sourceConfiguration.getPort());
+    }
+
+    private void handleException(String s, Exception e) throws AxisFault {
+        log.error(s, e);
+        throw new AxisFault(s, e);
+    }
+
+    public EndpointReference getEPRForService(String serviceName, String ip) throws AxisFault {
+        String trailer = "";
+        //Strip out the operation name
+        if (serviceName.indexOf('/') != -1) {
+            trailer += serviceName.substring(serviceName.indexOf("/"));
+            serviceName = serviceName.substring(0, serviceName.indexOf('/'));
+        }
+        // strip out the endpoint name if present
+        if (serviceName.indexOf('.') != -1) {
+            trailer += serviceName.substring(serviceName.indexOf("."));
+            serviceName = serviceName.substring(0, serviceName.indexOf('.'));
+        }
+
+        if (serviceNameToEPRMap.containsKey(serviceName)) {
+            return new EndpointReference(
+                    sourceConfiguration.getCustomEPRPrefix() +
+                            serviceNameToEPRMap.get(serviceName) + trailer);
+        } else {
+            return new EndpointReference(sourceConfiguration.getServiceEPRPrefix() +
+                    serviceName + trailer);
+        }
+    }
+
+    /**
+     * Return the EPRs for the given service over this transport
+     * @param serviceName name of the service
+     * @param ip IP address
+     * @return the EndpointReferences for this service over the transport
+     * @throws AxisFault on error
+     */
+    public EndpointReference[] getEPRsForService(String serviceName, String ip) throws AxisFault {
+        String trailer = "";
+        //Strip out the operation name
+        if (serviceName.indexOf('/') != -1) {
+            trailer += serviceName.substring(serviceName.indexOf("/"));
+            serviceName = serviceName.substring(0, serviceName.indexOf('/'));
+        }
+        // strip out the endpoint name if present
+        if (serviceName.indexOf('.') != -1) {
+            trailer += serviceName.substring(serviceName.indexOf("."));
+            serviceName = serviceName.substring(0, serviceName.indexOf('.'));
+        }
+
+        EndpointReference[] endpointReferences = new EndpointReference[1];
+        if (serviceNameToEPRMap.containsKey(serviceName)) {
+            endpointReferences[0] = new EndpointReference(
+                    sourceConfiguration.getCustomEPRPrefix() +
+                            serviceNameToEPRMap.get(serviceName) + trailer);
+        } else {
+            endpointReferences[0]
+                    = new EndpointReference(sourceConfiguration.getServiceEPRPrefix() +
+                    serviceName + trailer);
+        }
+        return endpointReferences;
+    }
+
+    public SessionContext getSessionContext(MessageContext messageContext) {
+        return null;
+    }
+
+
+    public void stop() throws AxisFault {
+        log.info("Stopping Pass-through " + namePrefix + " Listener..");
+        try {
+            ioReactor.shutdown();
+        } catch (IOException e) {
+            handleException("Error shutting down " + namePrefix + " listening IO reactor", e);
+        }
+    }
+
+    public void destroy() {
+        log.info("Destroying PassThroughHttpListener");
+        sourceConfiguration.getConfigurationContext().
+                getAxisConfiguration().getObserversList().remove(axisObserver);
+
+        sourceConfiguration.getMetrics().destroy();
+    }
+
+    /**
+     * Pause the listener - Stops accepting new connections, but continues processing existing
+     * connections until they complete. This helps bring an instance into a maintenance mode
+     *
+     * @throws AxisFault if pausing fails
+     */
+    public void pause() throws AxisFault {
+        if (state != BaseConstants.STARTED) return;
+        try {
+            ioReactor.pause();
+
+            state = BaseConstants.PAUSED;
+            log.info(namePrefix + " Listener Paused");
+        } catch (IOException e) {
+            handleException("Error pausing IOReactor", e);
+        }
+    }
+
+    /**
+     * Resume the lister - Brings the lister into active mode back from a paused state
+     *
+     * @throws AxisFault if the resume fails
+     */
+    public void resume() throws AxisFault {
+        if (state != BaseConstants.PAUSED) return;
+        try {
+            ioReactor.resume();
+            state = BaseConstants.STARTED;
+            log.info((sslContext == null ? "HTTP" : "HTTPS") + "Listener Resumed");
+        } catch (IOException e) {
+            handleException("Error resuming IOReactor", e);
+        }
+    }
+
+    /**
+     * Stop accepting new connections, and wait the maximum specified time for in-flight
+     * requests to complete before a controlled shutdown for maintenance
+     *
+     * @param milliSecs number of milliseconds to wait until pending requests complete
+     * @throws AxisFault if the shutdown fails
+     */
+    public void maintenanceShutdown(long milliSecs) throws AxisFault {
+        if (state != BaseConstants.STARTED) return;
+        try {
+            long start = System.currentTimeMillis();
+            ioReactor.pause();
+            ioReactor.shutdown(milliSecs);
+            state = BaseConstants.STOPPED;
+            log.info("Listener shutdown in : " + (System.currentTimeMillis() - start) / 1000 + "s");
+        } catch (IOException e) {
+            handleException("Error shutting down the IOReactor for maintenance", e);
+        }
+    }
+
+    /**
+     * An AxisObserver which will start listening for newly deployed or started services,
+     * and stop listening when services are un-deployed or stopped.
+     */
+    private class GenericAxisObserver implements AxisObserver {
+        public void init(AxisConfiguration axisConfig) {}
+
+        public void serviceUpdate(AxisEvent event, AxisService service) {
+            if (!ignoreService(service)
+                    && BaseUtils.isUsingTransport(service,
+                    sourceConfiguration.getInDescription().getName())) {
+                switch (event.getEventType()) {
+                    case AxisEvent.SERVICE_DEPLOY :
+                        addToServiceURIMap(service);
+                        break;
+                    case AxisEvent.SERVICE_REMOVE :
+                        removeServiceFfromURIMap(service);
+                        break;
+                    case AxisEvent.SERVICE_START  :
+                        addToServiceURIMap(service);
+                        break;
+                    case AxisEvent.SERVICE_STOP   :
+                        removeServiceFfromURIMap(service);
+                        break;
+                }
+            }
+        }
+
+        public void moduleUpdate(AxisEvent event, AxisModule module) {}
+        public void addParameter(Parameter parameter) throws AxisFault {}
+        public void removeParameter(Parameter parameter) throws AxisFault {}
+        public void deserializeParameters(OMElement parameterElement) throws AxisFault {}
+        public Parameter getParameter(String name) { return null; }
+        public ArrayList<Parameter> getParameters() { return null; }
+        public boolean isParameterLocked(String parameterName) { return false; }
+        public void serviceGroupUpdate(AxisEvent event, AxisServiceGroup serviceGroup) {}
+    }
+
+    private boolean ignoreService(AxisService service) {
+        // these are "private" services
+        return service.getName().startsWith("__") || JavaUtils.isTrueExplicitly(
+                service.getParameter(PassThroughConstants.HIDDEN_SERVICE_PARAM_NAME));
+    }
+
+    private void addToServiceURIMap(AxisService service) {
+        Parameter param = service.getParameter(PassThroughConstants.SERVICE_URI_LOCATION);
+        if (param != null) {
+            String uriLocation = param.getValue().toString();
+            if (uriLocation.startsWith("/")) {
+                uriLocation = uriLocation.substring(1);
+            }
+            serviceNameToEPRMap.put(service.getName(), uriLocation);
+            eprToServiceNameMap.put(uriLocation, service.getName());
+        }
+    }
+
+    private void removeServiceFfromURIMap(AxisService service) {
+        eprToServiceNameMap.remove(serviceNameToEPRMap.get(service.getName()));
+        serviceNameToEPRMap.remove(service.getName());
+    }
+
+    protected IOEventDispatch getEventDispatch(
+            NHttpServiceHandler handler, SSLContext sslContext,
+            SSLIOSessionHandler sslioSessionHandler, HttpParams params) {
+        return new SourceIOEventDispatch(handler, params);
+    }
+
+    /**
+     * Create the SSLContext to be used by this listener
+     * @param transportIn transport in description
+     * @return always null
+     * @throws AxisFault never thrown
+     */
+    protected SSLContext getSSLContext(
+            TransportInDescription transportIn) throws AxisFault {
+        return null;
+    }
+
+    /**
+     * Create the SSL IO Session handler to be used by this listener
+     * @param transportIn transport in descritption
+     * @return always null
+     * @throws AxisFault never thrown
+     */
+    protected SSLIOSessionHandler getSSLIOSessionHandler(
+            TransportInDescription transportIn) throws AxisFault {
+        return null;
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetHandler.java	(revision 1502663)
@@ -0,0 +1,525 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+package org.apache.synapse.transport.passthru;
+
+import java.io.IOException;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.WSDL2Constants;
+import org.apache.axis2.engine.MessageReceiver;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.ConnectionClosedException;
+import org.apache.http.HttpException;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+import org.apache.synapse.transport.passthru.connections.HostConnections;
+import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
+
+
+/**
+ * This class is handling events from the transport -- > client.
+ */
+public class TargetHandler implements NHttpClientHandler {
+    private static Log log = LogFactory.getLog(TargetHandler.class);
+
+    /** Delivery agent */
+    private final DeliveryAgent deliveryAgent;
+
+    /** Configuration used by the sender */
+    private final TargetConfiguration targetConfiguration;
+
+    /** Error handler for injecting faults */
+    private final TargetErrorHandler targetErrorHandler;
+
+    private PassThroughTransportMetricsCollector metrics = null;
+
+    public TargetHandler(DeliveryAgent deliveryAgent,
+                         TargetConfiguration configuration) {
+        this.targetConfiguration = configuration;
+        this.deliveryAgent = deliveryAgent;
+        this.targetErrorHandler = new TargetErrorHandler(targetConfiguration);
+        this.metrics = targetConfiguration.getMetrics();
+    }
+
+    public void connected(NHttpClientConnection conn, Object o) {
+        assert o instanceof HostConnections : "Attachment should be a HostConnections";
+
+        HostConnections pool = (HostConnections) o;
+        conn.getContext().setAttribute(PassThroughConstants.CONNECTION_POOL, pool);
+
+          
+        // create the connection information and set it to request ready
+        TargetContext.create(conn, ProtocolState.REQUEST_READY, targetConfiguration);
+
+        // notify the pool about the new connection
+        targetConfiguration.getConnections().addConnection(conn);
+
+        // notify about the new connection
+        deliveryAgent.connected(pool.getHost(), pool.getPort());
+        
+        conn.getContext().setAttribute(PassThroughConstants.REQ_DEPARTURE_TIME, System.currentTimeMillis());
+
+        metrics.connected();
+    }
+
+    public void requestReady(NHttpClientConnection conn) {
+        ProtocolState connState = null;
+        try {
+            connState = TargetContext.getState(conn);
+
+            if (connState == ProtocolState.REQUEST_DONE || connState == ProtocolState.RESPONSE_BODY) {
+                return;
+            }
+
+            if (connState != ProtocolState.REQUEST_READY) {
+                handleInvalidState(conn, "Request not started");
+                return;
+            }
+
+            TargetRequest request = TargetContext.getRequest(conn);
+            if (request != null) {
+                request.start(conn);
+                targetConfiguration.getMetrics().incrementMessagesSent();
+            }
+            conn.getContext().setAttribute(PassThroughConstants.REQ_DEPARTURE_TIME, System.currentTimeMillis());
+        } catch (IOException e) {
+            logIOException(conn, e);
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+
+            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+            if (requestMsgCtx != null) {
+                targetErrorHandler.handleError(requestMsgCtx,
+                        ErrorCodes.SND_IO_ERROR,
+                        "Error in Sender",
+                        null,
+                        connState);
+            }
+        } catch (HttpException e) {
+            log.error(e.getMessage(), e);
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+
+            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+            if (requestMsgCtx != null) {
+                targetErrorHandler.handleError(requestMsgCtx,
+                        ErrorCodes.SND_HTTP_ERROR,
+                        "Error in Sender",
+                        null,
+                        connState);
+            }
+        }
+    }
+
+    public void outputReady(NHttpClientConnection conn, ContentEncoder encoder) {
+        ProtocolState connState = null;
+        try {
+            connState = TargetContext.getState(conn);
+            if (connState != ProtocolState.REQUEST_HEAD &&
+                    connState != ProtocolState.REQUEST_DONE) {
+                handleInvalidState(conn, "Writing message body");
+                return;
+            }
+
+            TargetRequest request = TargetContext.getRequest(conn);
+            if (request.hasEntityBody()) {
+                int bytesWritten = request.write(conn, encoder);
+                metrics.incrementBytesSent(bytesWritten);
+            }
+        } catch (IOException ex) {
+            logIOException(conn, ex);
+            TargetContext.updateState(conn, ProtocolState.CLOSING);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+
+            informWriterError(conn);
+
+            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+            if (requestMsgCtx != null) {
+                targetErrorHandler.handleError(requestMsgCtx,
+                        ErrorCodes.SND_HTTP_ERROR,
+                        "Error in Sender",
+                        null,
+                        connState);
+            }
+        } catch (Exception e) {
+            log.error("Error occurred while writing data to the target", e);
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+
+            informWriterError(conn);
+
+            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+            if (requestMsgCtx != null) {
+                targetErrorHandler.handleError(requestMsgCtx,
+                        ErrorCodes.SND_HTTP_ERROR,
+                        "Error in Sender",
+                        null,
+                        connState);
+            }
+        }
+    }
+
+    public void responseReceived(NHttpClientConnection conn) {
+        ProtocolState connState;
+        try {
+        	conn.getContext().setAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME, System.currentTimeMillis());
+            connState = TargetContext.getState(conn);
+            if (connState != ProtocolState.REQUEST_DONE) {
+                handleInvalidState(conn, "Receiving response");
+                return;
+            }
+
+            HttpResponse response = conn.getHttpResponse();
+            TargetRequest targetRequest = TargetContext.getRequest(conn);
+
+            int statusCode = response.getStatusLine().getStatusCode();
+            if (statusCode < HttpStatus.SC_OK) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Received a 100 Continue response");
+                }
+                // Ignore 1xx response
+                return;
+            }
+
+            String method = "POST";
+            if (targetRequest != null) {
+                method = targetRequest.getMethod();
+            }
+            boolean canResponseHaveBody =
+                    isResponseHaveBodyExpected(method, response);
+            TargetResponse targetResponse = new TargetResponse(
+                    targetConfiguration, response, conn, canResponseHaveBody);
+            TargetContext.setResponse(conn, targetResponse);
+            targetResponse.start(conn);
+
+            MessageContext requestMsgContext = TargetContext.get(conn).getRequestMsgCtx();
+            if (statusCode == HttpStatus.SC_ACCEPTED && handle202(requestMsgContext)) {
+                return;
+            }
+                       
+            targetConfiguration.getWorkerPool().execute(
+                    new ClientWorker(targetConfiguration.getConfigurationContext(),
+                            requestMsgContext, targetResponse));
+
+            targetConfiguration.getMetrics().incrementMessagesReceived();
+            
+			NHttpServerConnection sourceConn =
+			                                   (NHttpServerConnection) requestMsgContext.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION);
+			if (sourceConn != null) {
+				sourceConn.getContext().setAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME,
+				                                     conn.getContext()
+				                                         .getAttribute(PassThroughConstants.RES_HEADER_ARRIVAL_TIME));
+				sourceConn.getContext().setAttribute(PassThroughConstants.REQ_DEPARTURE_TIME,
+				                                     conn.getContext()
+				                                         .getAttribute(PassThroughConstants.REQ_DEPARTURE_TIME));
+
+			}
+                                                                                      
+        } catch (Exception ex) {
+            log.error(ex.getMessage(), ex);
+
+            informReaderError(conn);
+
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+        }
+    }
+
+    private boolean handle202(MessageContext requestMsgContext) throws AxisFault {
+        if (requestMsgContext.isPropertyTrue(NhttpConstants.IGNORE_SC_ACCEPTED)) {
+            // We should not further process this 202 response - Ignore it
+            return true;
+        }
+
+        MessageReceiver mr = requestMsgContext.getAxisOperation().getMessageReceiver();
+        MessageContext responseMsgCtx = requestMsgContext.getOperationContext().
+                        getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);
+        if (responseMsgCtx == null || requestMsgContext.getOptions().isUseSeparateListener()) {
+            // Most probably a response from a dual channel invocation
+            // Inject directly into the SynapseCallbackReceiver
+            requestMsgContext.setProperty(NhttpConstants.HTTP_202_RECEIVED, "true");
+            mr.receive(requestMsgContext);
+            return true;
+        }
+
+        return false;
+    }
+
+    public void inputReady(NHttpClientConnection conn, ContentDecoder decoder) {
+        ProtocolState connState;
+        try {
+            connState = TargetContext.getState(conn);
+            if (connState.compareTo(ProtocolState.RESPONSE_HEAD) < 0) {
+                return;
+            }
+            if (connState != ProtocolState.RESPONSE_HEAD &&
+                    connState != ProtocolState.RESPONSE_BODY) {
+                handleInvalidState(conn, "Response received");
+                return;
+            }
+
+            TargetContext.updateState(conn, ProtocolState.RESPONSE_BODY);
+
+            TargetResponse response = TargetContext.getResponse(conn);
+
+			if (response != null) {
+				int responseRead = response.read(conn, decoder);
+				metrics.incrementBytesReceived(responseRead);
+			}
+        } catch (IOException e) {
+            logIOException(conn, e);
+
+            informReaderError(conn);
+
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+        } catch (Exception ex) {
+            log.error(ex.getMessage(), ex);
+
+            informReaderError(conn);
+
+            TargetContext.updateState(conn, ProtocolState.CLOSED);
+            targetConfiguration.getConnections().shutdownConnection(conn);
+        }
+    }
+
+    public void closed(NHttpClientConnection conn) {
+        ProtocolState state = TargetContext.getState(conn);
+        
+        boolean sendFault = false;
+
+        if (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE) {
+            if (log.isDebugEnabled()) {
+                log.debug("Keep-Alive Connection closed");
+            }
+        } else if (state == ProtocolState.REQUEST_HEAD || state == ProtocolState.REQUEST_BODY) {
+            informWriterError(conn);
+            log.warn("Connection closed by target host while sending the request");
+            sendFault = true;
+        } else if (state == ProtocolState.RESPONSE_HEAD || state == ProtocolState.RESPONSE_BODY) {
+            informReaderError(conn);
+            log.warn("Connection closed by target host while receiving the response");
+            sendFault = false;
+        } else if (state == ProtocolState.REQUEST_DONE) {
+            informWriterError(conn);
+            log.warn("Connection closed by target host before receiving the request");
+            sendFault = true;
+        }
+
+        if (sendFault) {
+            MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+            if (requestMsgCtx != null) {
+                targetErrorHandler.handleError(requestMsgCtx,
+                        ErrorCodes.CONNECTION_CLOSED,
+                        "Error in Sender",
+                        null,
+                        state);
+            }
+        }
+
+        metrics.disconnected();
+
+        TargetContext.updateState(conn, ProtocolState.CLOSED);
+        targetConfiguration.getConnections().shutdownConnection(conn);
+    }
+
+    public void exception(NHttpClientConnection conn, IOException e) {
+        ProtocolState state = TargetContext.getState(conn);
+
+        logIOException(conn, e);
+
+        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+        if (requestMsgCtx != null) {
+            targetErrorHandler.handleError(requestMsgCtx,
+                    ErrorCodes.SND_IO_ERROR,
+                    "Error in Sender",
+                    e,
+                    state);
+        }
+
+        TargetContext.updateState(conn, ProtocolState.CLOSING);
+        targetConfiguration.getConnections().shutdownConnection(conn);
+    }
+
+    private void logIOException(NHttpClientConnection conn, IOException e) {
+        String message = getErrorMessage("I/O error : " + e.getMessage(), conn);
+
+        if (e instanceof ConnectionClosedException || (e.getMessage() != null &&
+                e.getMessage().toLowerCase().contains("connection reset by peer") ||
+                e.getMessage().toLowerCase().contains("forcibly closed"))) {
+            if (log.isDebugEnabled()) {
+                log.debug("I/O error (Probably the keep-alive connection " +
+                        "was closed):" + e.getMessage());
+            }
+        } else if (e.getMessage() != null) {
+            String msg = e.getMessage().toLowerCase();
+            if (msg.indexOf("broken") != -1) {
+                log.warn("I/O error (Probably the connection " +
+                        "was closed by the remote party):" + e.getMessage());
+            } else {
+                log.error("I/O error: " + e.getMessage(), e);
+            }
+        } else {
+            log.error(message, e);
+        }
+    }
+
+    public void exception(NHttpClientConnection conn, HttpException e) {
+        ProtocolState state = TargetContext.getState(conn);
+
+        String message = getErrorMessage("HTTP protocol violation : " + e.getMessage(), conn);
+        log.error(message, e);
+
+        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+        if (requestMsgCtx != null) {
+            targetErrorHandler.handleError(requestMsgCtx,
+                    ErrorCodes.PROTOCOL_VIOLATION,
+                    "Error in Sender",
+                    null,
+                    state);
+        }
+
+        TargetContext.updateState(conn, ProtocolState.CLOSED);
+        targetConfiguration.getConnections().shutdownConnection(conn);
+    }
+
+    public void timeout(NHttpClientConnection conn) {
+        ProtocolState state = TargetContext.getState(conn);
+
+        String message = getErrorMessage("Connection timeout", conn);
+        if (log.isDebugEnabled()) {
+            log.debug(message);
+        }
+
+        if (state != null &&
+                (state == ProtocolState.REQUEST_READY || state == ProtocolState.RESPONSE_DONE)) {
+            if (log.isDebugEnabled()) {
+                log.debug(getErrorMessage("Keep-alive connection timed out", conn));
+            }
+        } else if (state != null ) {
+            if (state == ProtocolState.REQUEST_BODY) {
+                metrics.incrementTimeoutsSending();
+                informWriterError(conn);
+            }
+
+            if (state == ProtocolState.RESPONSE_BODY || state == ProtocolState.REQUEST_HEAD) {
+                metrics.incrementTimeoutsReceiving();
+                informReaderError(conn);
+            }
+
+            if (state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {
+                MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+
+                log.warn("Connection time out while in state: " + state);
+                if (requestMsgCtx != null) {
+                    targetErrorHandler.handleError(requestMsgCtx,
+                            ErrorCodes.CONNECTION_TIMEOUT,
+                            "Error in Sender",
+                            null,
+                            state);
+                }
+            }
+        }
+
+        TargetContext.updateState(conn, ProtocolState.CLOSED);
+        targetConfiguration.getConnections().shutdownConnection(conn);
+    }
+
+    private boolean isResponseHaveBodyExpected(
+            final String method, final HttpResponse response) {
+
+        if ("HEAD".equalsIgnoreCase(method)) {
+            return false;
+        }
+
+        int status = response.getStatusLine().getStatusCode();
+        return status >= HttpStatus.SC_OK
+            && status != HttpStatus.SC_NO_CONTENT
+            && status != HttpStatus.SC_NOT_MODIFIED
+            && status != HttpStatus.SC_RESET_CONTENT;
+    }
+
+    /**
+     * Include remote host and port information to an error message
+     *
+     * @param message the initial message
+     * @param conn    the connection encountering the error
+     * @return the updated error message
+     */
+    private String getErrorMessage(String message, NHttpClientConnection conn) {
+        if (conn != null && conn instanceof DefaultNHttpClientConnection) {
+            DefaultNHttpClientConnection c = ((DefaultNHttpClientConnection) conn);
+
+            if (c.getRemoteAddress() != null) {
+                return message + " For : " + c.getRemoteAddress().getHostAddress() + ":" +
+                        c.getRemotePort();
+            }
+        }
+        return message;
+    }
+
+    private void handleInvalidState(NHttpClientConnection conn, String action) {
+        ProtocolState state = TargetContext.getState(conn);
+
+        log.warn(action + " while the handler is in an inconsistent state " +
+                TargetContext.getState(conn));
+        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+        TargetContext.updateState(conn, ProtocolState.CLOSED);
+        targetConfiguration.getConnections().shutdownConnection(conn);
+        if (requestMsgCtx != null) {
+            targetErrorHandler.handleError(requestMsgCtx,
+                    ErrorCodes.SND_INVALID_STATE,
+                    "Error in Sender",
+                    null,
+                    state);
+        }
+    }
+
+    private void informReaderError(NHttpClientConnection conn) {
+        Pipe reader = TargetContext.get(conn).getReader();
+
+        metrics.incrementFaultsReceiving();
+
+        if (reader != null) {
+            reader.producerError();
+        }
+    }
+
+    private void informWriterError(NHttpClientConnection conn) {
+        Pipe writer = TargetContext.get(conn).getWriter();
+
+        metrics.incrementFaultsReceiving();
+
+        if (writer != null) {
+            writer.consumerError();
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetErrorHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetErrorHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetErrorHandler.java	(revision 1502663)
@@ -0,0 +1,148 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.engine.MessageReceiver;
+import org.apache.axis2.util.MessageContextBuilder;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+
+public class TargetErrorHandler {
+    private Log log = LogFactory.getLog(TargetErrorHandler.class);
+
+    private TargetConfiguration targetConfiguration = null;
+
+    public TargetErrorHandler(TargetConfiguration targetConfiguration) {
+        this.targetConfiguration = targetConfiguration;
+    }
+
+    /**
+     * Mark request to send failed with error
+     *
+     * @param mc the failed message context
+     * @param errorCode the error code to raise
+     * @param errorMessage the text for an error message to be returned to the MR on failure
+     * @param exceptionToRaise an Exception to be returned to the MR on failure
+     * @param state state of the connection
+     */
+    protected void handleError(final MessageContext mc,
+                               final int errorCode,
+                               final String errorMessage,
+                               final Exception exceptionToRaise,
+                               final ProtocolState state) {
+
+        if (errorCode == -1 && errorMessage == null && exceptionToRaise == null) {
+            return;
+        }
+
+        if (mc.getAxisOperation() == null ||
+                mc.getAxisOperation().getMessageReceiver() == null) {
+            return;
+        }
+
+//        if (mc.getOperationContext().isComplete()) {
+//            return;
+//        } ? why we ignoring this..
+
+        targetConfiguration.getWorkerPool().execute(new Runnable() {
+            public void run() {
+                MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();
+                try {
+                    AxisFault axisFault = (exceptionToRaise != null ?
+                            new AxisFault(errorMessage, exceptionToRaise) :
+                            new AxisFault(errorMessage));
+
+                    MessageContext faultMessageContext =
+                            MessageContextBuilder.createFaultMessageContext(mc, axisFault);
+
+                    SOAPEnvelope envelope = faultMessageContext.getEnvelope();
+
+                    if (log.isDebugEnabled()) {
+                        log.debug("Sending Fault for Request with Message ID : "
+                                + mc.getMessageID());
+                    }
+
+                    faultMessageContext.setTo(null);
+                    faultMessageContext.removeProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+
+                    // copy the important properties from the original message context
+                    faultMessageContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,
+                            mc.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION));
+                    faultMessageContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION,
+                            mc.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION));
+
+                    faultMessageContext.setServerSide(true);
+                    faultMessageContext.setDoingREST(mc.isDoingREST());
+                    faultMessageContext.setProperty(MessageContext.TRANSPORT_IN, mc
+                            .getProperty(MessageContext.TRANSPORT_IN));
+                    faultMessageContext.setTransportIn(mc.getTransportIn());
+                    faultMessageContext.setTransportOut(mc.getTransportOut());
+
+
+                    faultMessageContext.setAxisMessage(
+                            mc.getOperationContext().getAxisOperation().getMessage(
+                                    WSDLConstants.MESSAGE_LABEL_IN_VALUE));
+                    
+                    faultMessageContext.setOperationContext(mc.getOperationContext());
+                    faultMessageContext.setConfigurationContext(mc.getConfigurationContext());
+                    faultMessageContext.setTo(null);
+
+                    faultMessageContext.setProperty(
+                            PassThroughConstants.SENDING_FAULT, Boolean.TRUE);
+                    faultMessageContext.setProperty(
+                            PassThroughConstants.ERROR_MESSAGE, errorMessage);
+                    if (errorCode != -1) {
+                        faultMessageContext.setProperty(
+                                PassThroughConstants.ERROR_CODE, getErrorCode(errorCode, state));
+                    }
+                    if (exceptionToRaise != null) {
+                        faultMessageContext.setProperty(
+                                PassThroughConstants.ERROR_DETAIL, exceptionToRaise.toString());
+                        faultMessageContext.setProperty(
+                                PassThroughConstants.ERROR_EXCEPTION, exceptionToRaise);
+                        envelope.getBody().getFault().getDetail().setText(
+                                exceptionToRaise.toString());
+                    } else {
+                        faultMessageContext.setProperty(
+                                PassThroughConstants.ERROR_DETAIL, errorMessage);
+                        envelope.getBody().getFault().getDetail().setText(errorMessage);
+                    }
+
+                    faultMessageContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, true);
+
+                    mr.receive(faultMessageContext);
+
+                } catch (AxisFault af) {
+                    log.error("Unable to report back failure to the message receiver", af);
+                }
+            }
+        });
+    }
+
+    private int getErrorCode(int errorCode, ProtocolState state) {
+        return errorCode + state.ordinal();
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java	(revision 1502663)
@@ -0,0 +1,568 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.util.Comparator;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+
+import javax.xml.parsers.FactoryConfigurationError;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.soap.SOAP11Constants;
+import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;
+import org.apache.axiom.util.UIDGenerator;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.builder.BuilderUtil;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.dispatchers.RequestURIBasedDispatcher;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axis2.transport.RequestResponseTransport;
+import org.apache.axis2.transport.TransportUtils;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.transport.http.HTTPTransportUtils;
+import org.apache.axis2.util.MessageContextBuilder;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpInetConnection;
+import org.apache.http.HttpResponse;
+import org.apache.http.HttpStatus;
+import org.apache.http.HttpVersion;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.impl.nio.reactor.SSLIOSession;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.nhttp.HttpCoreRequestResponseTransport;
+import org.apache.synapse.transport.nhttp.NHttpConfiguration;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.nhttp.util.NhttpUtil;
+import org.apache.synapse.transport.nhttp.util.RESTUtil;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+import org.apache.synapse.transport.passthru.util.RelayUtils;
+import org.apache.synapse.transport.passthru.util.SourceResponseFactory;
+
+/**
+ * This is a worker thread for executing an incoming request in to the transport.
+ */
+public class ServerWorker implements Runnable {
+
+  	private static final Log log = LogFactory.getLog(ServerWorker.class);
+    /** the incoming message to be processed */
+    private org.apache.axis2.context.MessageContext msgContext = null;
+    /** the http request */
+    private SourceRequest request = null;
+    /** The configuration of the receiver */
+    private SourceConfiguration sourceConfiguration = null;
+
+    private static final String SOAP_ACTION_HEADER = "SOAPAction";
+        
+    /** WSDL processor for Get requests */
+    private HttpGetRequestProcessor httpGetRequestProcessor = null;
+    
+    /** Weather we should do rest dispatching or not */
+    private boolean isRestDispatching = true;
+    
+    private boolean isHttps = false;
+    
+    
+    private OutputStream os; //only used for WSDL  requests..
+  
+    public ServerWorker(final SourceRequest request,
+                        final SourceConfiguration sourceConfiguration,final OutputStream os) {
+        this.request = request;
+        this.sourceConfiguration = sourceConfiguration;
+
+        this.isHttps = sourceConfiguration.isSsl();
+        
+        this.msgContext = createMessageContext(request);
+        
+        this.httpGetRequestProcessor = sourceConfiguration.getHttpGetRequestProcessor();
+        
+        this.os = os;
+        
+      
+        
+        // set these properties to be accessed by the engine
+        msgContext.setProperty(
+                PassThroughConstants.PASS_THROUGH_SOURCE_REQUEST, request);
+        msgContext.setProperty(
+                PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION, sourceConfiguration);
+        msgContext.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,
+                request.getConnection());
+        
+    }
+
+    public void run() {
+        if (log.isDebugEnabled()) {
+            log.debug("Starting a new Server Worker instance");
+        }
+        ConfigurationContext cfgCtx = sourceConfiguration.getConfigurationContext();        
+        msgContext.setProperty(Constants.Configuration.HTTP_METHOD, request.getMethod());
+
+        String method = request.getRequest() != null ? request.getRequest().getRequestLine().getMethod().toUpperCase():"";
+        
+        String uri = request.getUri();
+        String oriUri = uri;
+        
+        if (uri.contains(cfgCtx.getServicePath())) {
+            // discard up to servicePath
+            uri = uri.substring(uri.indexOf(cfgCtx.getServicePath()) +
+                    cfgCtx.getServicePath().length());
+            // discard [proxy] service name if any
+            int pos = uri.indexOf("/", 1);
+            if (pos > 0) {
+                uri = uri.substring(pos);
+            } else {
+                pos = uri.indexOf("?");
+                if (pos != -1) {
+                    uri = uri.substring(pos);
+                } else {
+                    uri = "";
+                }
+            }
+        } else {
+            // remove any absolute prefix if any
+            int pos = uri.indexOf("://");
+            if (pos != -1) {
+                uri = uri.substring(pos + 3);
+                pos = uri.indexOf("/");
+                if (pos != -1) {
+                    uri = uri.substring(pos + 1);
+                }
+            }
+        }
+        
+        
+        String servicePrefix = oriUri.substring(0, oriUri.indexOf(uri));
+        if (servicePrefix.indexOf("://") == -1) {
+            HttpInetConnection inetConn = (HttpInetConnection) request.getConnection();
+            InetAddress localAddr = inetConn.getLocalAddress();
+            if (localAddr != null) {
+                servicePrefix = (sourceConfiguration.isSsl() ? "https://" : "http://") +
+                        localAddr.getHostAddress() + ":" + inetConn.getLocalPort() + servicePrefix;
+            }
+        }
+       
+        msgContext.setProperty(PassThroughConstants.SERVICE_PREFIX, servicePrefix);
+
+        msgContext.setTo(new EndpointReference(uri));
+        msgContext.setProperty(PassThroughConstants.REST_URL_POSTFIX, uri);
+
+		if ("GET".equals(method) || "DELETE".equals(method)) {
+			
+			HttpResponse response = sourceConfiguration.getResponseFactory().newHttpResponse(
+		                request.getVersion(), HttpStatus.SC_OK,
+		                request.getConnection().getContext());
+			
+			// create a basic HttpEntity using the source channel of the response pipe
+            BasicHttpEntity entity = new BasicHttpEntity();
+            if (request.getVersion().greaterEquals(HttpVersion.HTTP_1_1)) {
+                entity.setChunked(true);
+            }
+            response.setEntity(entity);
+            
+			httpGetRequestProcessor.process(request.getRequest(), response,msgContext,
+					request.getConnection(), os, isRestDispatching);
+		} 
+		
+		//need special case to handle REST
+		boolean restHandle =false;
+		if(msgContext.getProperty(PassThroughConstants.REST_GET_DELETE_INVOKE) != null && (Boolean)msgContext.getProperty(PassThroughConstants.REST_GET_DELETE_INVOKE)){
+			msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
+	        msgContext.setServerSide(true);
+	        msgContext.setDoingREST(true);
+	        String contentTypeHeader = request.getHeaders().get(HTTP.CONTENT_TYPE);
+	        //String contentType = contentTypeHeader != null ?TransportUtils.getContentType(contentTypeHeader, msgContext):null;
+	        SOAPEnvelope soapEnvelope = this.handleRESTUrlPost(contentTypeHeader);
+	        processNonEntityEnclosingRESTHandler(soapEnvelope);
+			restHandle =true;
+		}
+		
+		//if WSDL done then moved out rather than hand over to entity handle methods.
+		SourceContext info = (SourceContext) request.getConnection().getContext().getAttribute(SourceContext.CONNECTION_INFORMATION);
+		if (info != null &&
+		    info.getState().equals(ProtocolState.WSDL_RESPONSE_DONE) ||
+		    (msgContext.getProperty(PassThroughConstants.WSDL_GEN_HANDLED) != null && Boolean.TRUE.equals((msgContext.getProperty(PassThroughConstants.WSDL_GEN_HANDLED))))) {
+			return;
+		}
+		
+		//should be process normally
+		if (!restHandle) {
+			if (request.isEntityEnclosing()) {
+				processEntityEnclosingRequest();
+			} else {
+				processNonEntityEnclosingRESTHandler(null);
+			}
+		}
+	
+		
+		
+
+        sendAck();
+    }
+
+	/**
+	 * Method will setup the necessary parameters for the rest url post action
+	 * 
+	 * @param contentType
+	 * @return
+	 * @throws FactoryConfigurationError
+	 */
+	private SOAPEnvelope handleRESTUrlPost(String contentTypeHdr) throws FactoryConfigurationError {
+	    SOAPEnvelope soapEnvelope = null;
+	    String contentType = contentTypeHdr!=null?TransportUtils.getContentType(contentTypeHdr, msgContext):null;
+	    if (contentType == null || "".equals(contentType) || HTTPConstants.MEDIA_TYPE_X_WWW_FORM.equals(contentType)) {
+	        contentType = contentTypeHdr != null ? contentTypeHdr:HTTPConstants.MEDIA_TYPE_X_WWW_FORM;
+	        msgContext.setTo(new EndpointReference(request.getRequest().getRequestLine().getUri()));
+	        msgContext.setProperty(Constants.Configuration.CONTENT_TYPE,contentType);
+	        String charSetEncoding = BuilderUtil.getCharSetEncoding(contentType);
+		    msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEncoding);
+	        try {
+	            RESTUtil.dispatchAndVerify(msgContext);
+	        } catch (AxisFault e1) {
+	        	log.error("Error while building message for REST_URL request",e1);
+	        }
+	        
+	        RequestURIBasedDispatcher requestDispatcher = new RequestURIBasedDispatcher();
+	       
+			try {
+				String requestURI = request.getRequest().getRequestLine().getUri();
+				AxisService axisService = requestDispatcher.findService(msgContext);
+
+				boolean isCustomRESTDispatcher = false;
+				if (requestURI.startsWith("/t/") || requestURI.startsWith("/services/t/")) {
+					isCustomRESTDispatcher = true;
+				}
+
+				// the logic determines which service dispatcher to get invoke,
+				// this will be determine
+				// based on parameter defines at disableRestServiceDispatching,
+				// and if super tenant invoke, with isTenantRequest
+				// identifies whether the request to be dispatch to custom REST
+				// Dispatcher Service.
+
+				if (axisService == null) {
+					String defaultSvcName = NHttpConfiguration.getInstance().getStringValue("nhttp.default.service",
+					                                                                        "__SynapseService");
+
+					axisService =  msgContext.getConfigurationContext().getAxisConfiguration()
+					                        .getService(defaultSvcName);
+					msgContext.setAxisService(axisService);
+
+				}
+			} catch (AxisFault e) {
+				handleException("Error processing " + request.getMethod() + " request for : " + request.getUri(), e);
+			}
+			
+			
+	        try {
+	        	 soapEnvelope = TransportUtils.createSOAPMessage(msgContext, null, contentType);
+	           } catch (Exception e) {
+	        	log.error("Error while building message for REST_URL request");
+	        }
+	       //msgContext.setProperty(Constants.Configuration.CONTENT_TYPE,"application/xml");  
+	       msgContext.setProperty(Constants.Configuration.MESSAGE_TYPE,HTTPConstants.MEDIA_TYPE_APPLICATION_XML);   
+	    }
+	    return soapEnvelope;
+    }
+
+    private void sendAck() {
+        String respWritten = "";
+        if (msgContext.getOperationContext() != null) {
+            respWritten = (String) msgContext.getOperationContext().getProperty(
+                    Constants.RESPONSE_WRITTEN);
+        }
+        
+        if(msgContext.getProperty(PassThroughConstants.FORCE_SOAP_FAULT) != null){
+        	respWritten ="SKIP";
+        }
+        
+        boolean respWillFollow = !Constants.VALUE_TRUE.equals(respWritten)
+                && !"SKIP".equals(respWritten);
+        boolean ack = (((RequestResponseTransport) msgContext.getProperty(
+                    RequestResponseTransport.TRANSPORT_CONTROL)).getStatus()
+                    == RequestResponseTransport.RequestResponseTransportStatus.ACKED);
+        boolean forced = msgContext.isPropertyTrue(NhttpConstants.FORCE_SC_ACCEPTED);
+        boolean nioAck = msgContext.isPropertyTrue("NIO-ACK-Requested", false);
+        if (respWillFollow || ack || forced || nioAck) {
+            NHttpServerConnection conn = request.getConnection();
+            SourceResponse sourceResponse;
+            if (!nioAck) {
+                msgContext.removeProperty(MessageContext.TRANSPORT_HEADERS);
+                sourceResponse = SourceResponseFactory.create(msgContext,
+                        request, sourceConfiguration);
+                sourceResponse.setStatus(HttpStatus.SC_ACCEPTED);
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug("Sending ACK response with status "
+                            + msgContext.getProperty(NhttpConstants.HTTP_SC)
+                            + ", for MessageID : " + msgContext.getMessageID());
+                }
+                sourceResponse = SourceResponseFactory.create(msgContext,
+                        request, sourceConfiguration);
+                sourceResponse.setStatus(Integer.parseInt(
+                        msgContext.getProperty(NhttpConstants.HTTP_SC).toString()));
+            }
+
+            SourceContext.setResponse(conn, sourceResponse);
+            ProtocolState state = SourceContext.getState(conn);
+            if (state != null && state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {
+                conn.requestOutput();
+            } else {
+                SourceContext.updateState(conn, ProtocolState.CLOSED);
+                sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+            }
+        }
+    }
+
+    private void processNonEntityEnclosingRESTHandler(SOAPEnvelope soapEnvelope) {
+        String soapAction = request.getHeaders().get(SOAP_ACTION_HEADER);
+        if ((soapAction != null) && soapAction.startsWith("\"") && soapAction.endsWith("\"")) {
+            soapAction = soapAction.substring(1, soapAction.length() - 1);
+        }
+
+        msgContext.setSoapAction(soapAction);
+        msgContext.setTo(new EndpointReference(request.getUri()));
+        msgContext.setServerSide(true);
+        msgContext.setDoingREST(true);
+        if(!request.isEntityEnclosing()){
+        	msgContext.setProperty(PassThroughConstants.NO_ENTITY_BODY, Boolean.TRUE);
+        }
+        
+        try {
+        	if(soapEnvelope == null){
+        		 msgContext.setEnvelope(new SOAP11Factory().getDefaultEnvelope());
+        	}else{
+        		 msgContext.setEnvelope(soapEnvelope);
+        	}
+         
+
+            AxisEngine.receive(msgContext);
+        } catch (AxisFault axisFault) {
+            handleException("Error processing " + request.getMethod() +
+                " request for : " + request.getUri(), axisFault);
+        }
+    }
+
+    private void processEntityEnclosingRequest() {
+        try {
+            String contentTypeHeader = request.getHeaders().get(HTTP.CONTENT_TYPE);
+            contentTypeHeader = contentTypeHeader != null ? contentTypeHeader : inferContentType();
+
+            String charSetEncoding = null;
+            String contentType = null;
+
+			if (contentTypeHeader != null) {
+				charSetEncoding = BuilderUtil.getCharSetEncoding(contentTypeHeader);
+				contentType = TransportUtils.getContentType(contentTypeHeader, msgContext);
+			}
+            // get the contentType of char encoding
+            if (charSetEncoding == null) {
+                charSetEncoding = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+            }
+            String method = request.getRequest() != null ? request.getRequest().getRequestLine().getMethod().toUpperCase():"";
+            
+
+  
+
+            msgContext.setTo(new EndpointReference(request.getUri()));
+            msgContext.setProperty(HTTPConstants.HTTP_METHOD, method);
+            msgContext.setProperty(Constants.Configuration.CHARACTER_SET_ENCODING, charSetEncoding);
+            msgContext.setServerSide(true);
+            
+            msgContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentTypeHeader);
+            msgContext.setProperty(Constants.Configuration.MESSAGE_TYPE, contentType);
+
+            if (contentTypeHeader ==null || HTTPTransportUtils.isRESTRequest(contentTypeHeader) || isRest(contentTypeHeader)) {
+                msgContext.setProperty(PassThroughConstants.REST_REQUEST_CONTENT_TYPE, contentType);
+                msgContext.setDoingREST(true);
+                SOAPEnvelope soapEnvelope = this.handleRESTUrlPost(contentTypeHeader);
+                msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, request.getPipe());
+                processNonEntityEnclosingRESTHandler(soapEnvelope);
+    			return;
+            } else {
+                String soapAction = request.getHeaders().get(SOAP_ACTION_HEADER);
+
+                int soapVersion = HTTPTransportUtils.
+                        initializeMessageContext(msgContext, soapAction,
+                                request.getUri(), contentTypeHeader);
+                SOAPEnvelope envelope;
+
+                if (soapVersion == 1) {
+                    SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();
+                    envelope = fac.getDefaultEnvelope();
+                } else if (soapVersion == 2) {
+                    SOAPFactory fac = OMAbstractFactory.getSOAP12Factory();
+                    envelope = fac.getDefaultEnvelope();
+                } else {
+                    SOAPFactory fac = OMAbstractFactory.getSOAP12Factory();
+                    envelope = fac.getDefaultEnvelope();
+                }
+
+                msgContext.setEnvelope(envelope);
+            }
+            
+           
+            msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, request.getPipe());
+            AxisEngine.receive(msgContext);
+        } catch (AxisFault axisFault) {
+            handleException("Error processing " + request.getMethod() +
+                " request for : " + request.getUri(), axisFault);
+        } 
+    }
+    
+    
+    private boolean isRest(String contentType) {
+        return contentType != null &&
+                contentType.indexOf(SOAP11Constants.SOAP_11_CONTENT_TYPE) == -1 &&
+                contentType.indexOf(SOAP12Constants.SOAP_12_CONTENT_TYPE) == -1;
+    }
+
+
+
+    /**
+     * Create an Axis2 message context for the given http request. The request may be in the
+     * process of being streamed
+     *
+     * @param request the http request to be used to create the corresponding Axis2 message context
+     * @return the Axis2 message context created
+     */
+    private MessageContext createMessageContext(SourceRequest request) {
+        ConfigurationContext cfgCtx = sourceConfiguration.getConfigurationContext();
+        MessageContext msgContext =
+                new MessageContext();
+        msgContext.setMessageID(UIDGenerator.generateURNString());
+
+        // Axis2 spawns a new threads to send a message if this is TRUE - and it has to
+        // be the other way
+        msgContext.setProperty(MessageContext.CLIENT_API_NON_BLOCKING,
+                Boolean.FALSE);
+        msgContext.setConfigurationContext(cfgCtx);
+
+//        msgContext.setTransportOut(cfgCtx.getAxisConfiguration()
+//                .getTransportOut(Constants.TRANSPORT_HTTP));
+//        msgContext.setTransportIn(cfgCtx.getAxisConfiguration()
+//                .getTransportIn(Constants.TRANSPORT_HTTP));
+//        msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
+//        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, this);
+        
+        NHttpServerConnection conn = request.getConnection();
+        
+        if (isHttps) {
+            msgContext.setTransportOut(cfgCtx.getAxisConfiguration()
+                .getTransportOut(Constants.TRANSPORT_HTTPS));
+            msgContext.setTransportIn(cfgCtx.getAxisConfiguration()
+                .getTransportIn(Constants.TRANSPORT_HTTPS));
+            msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTPS);
+            SSLIOSession session = (SSLIOSession) (conn.getContext()).getAttribute("SSL_SESSION");
+            msgContext.setProperty("ssl.client.auth.cert.X509",
+                                                session.getAttribute("ssl.client.auth.cert.X509"));            
+        } else {
+            msgContext.setTransportOut(cfgCtx.getAxisConfiguration()
+                .getTransportOut(Constants.TRANSPORT_HTTP));
+            msgContext.setTransportIn(cfgCtx.getAxisConfiguration()
+                .getTransportIn(Constants.TRANSPORT_HTTP));
+            msgContext.setIncomingTransportName(Constants.TRANSPORT_HTTP);
+        }
+
+        msgContext.setProperty(Constants.OUT_TRANSPORT_INFO, this);
+        msgContext.setServerSide(true);
+        msgContext.setProperty(
+                Constants.Configuration.TRANSPORT_IN_URL, request.getUri());
+
+        // http transport header names are case insensitive
+        Map<String, String> headers = new TreeMap<String, String>(new Comparator<String>() {
+            public int compare(String o1, String o2) {
+                return o1.compareToIgnoreCase(o2);
+            }
+        });
+
+        Set<Map.Entry<String, String>> entries = request.getHeaders().entrySet();
+        for (Map.Entry<String, String> entry : entries) {
+            headers.put(entry.getKey(), entry.getValue());
+        }
+        msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headers);
+
+        // Following section is required for throttling to work
+        
+        if (conn instanceof HttpInetConnection) {
+            HttpInetConnection netConn = (HttpInetConnection) conn;
+            InetAddress remoteAddress = netConn.getRemoteAddress();
+            if (remoteAddress != null) {
+                msgContext.setProperty(
+                        MessageContext.REMOTE_ADDR, remoteAddress.getHostAddress());
+                msgContext.setProperty(
+                        NhttpConstants.REMOTE_HOST, NhttpUtil.getHostName(remoteAddress));
+            }
+        }
+
+        msgContext.setProperty(RequestResponseTransport.TRANSPORT_CONTROL,
+                new HttpCoreRequestResponseTransport(msgContext));
+
+        return msgContext;
+    }
+
+    private void handleException(String msg, Exception e) {
+        if (e == null) {
+            log.error(msg);
+        } else {
+            log.error(msg, e);
+        }
+
+        if (e == null) {
+            e = new Exception(msg);
+        }
+
+        try {
+            MessageContext faultContext =
+                    MessageContextBuilder.createFaultMessageContext(
+                    msgContext, e);
+            msgContext.setProperty(PassThroughConstants.FORCE_SOAP_FAULT, Boolean.TRUE);
+            AxisEngine.sendFault(faultContext);
+            
+        } catch (Exception ignored) {}
+    }
+
+    private String inferContentType() {
+        Parameter param = sourceConfiguration.getConfigurationContext().getAxisConfiguration().
+                getParameter(PassThroughConstants.REQUEST_CONTENT_TYPE);
+        if (param != null) {
+            return param.getValue().toString();
+        }
+        return null;
+    }
+
+    MessageContext getRequestContext() {
+        return msgContext;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingIOSession.java	(revision 1502663)
@@ -0,0 +1,228 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionBufferStatus;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import java.util.concurrent.atomic.AtomicLong;
+import java.nio.channels.ByteChannel;
+import java.nio.channels.SelectionKey;
+import java.nio.ByteBuffer;
+import java.net.SocketAddress;
+import java.io.IOException;
+
+class LoggingIOSession implements IOSession {
+
+    private static AtomicLong COUNT = new AtomicLong(0);
+
+    private final Log log;
+    private final Wire wirelog;
+    private final IOSession session;
+    private final ByteChannel channel;
+    private final String id;
+
+    public LoggingIOSession(            
+            final Log wirelog,
+            final IOSession session,
+            final String id) {
+        super();
+        if (session == null) {
+            throw new IllegalArgumentException("I/O session may not be null");
+        }
+        this.session = session;
+        this.channel = new LoggingByteChannel();
+        this.id = id + "-" + COUNT.incrementAndGet();
+        this.log = LogFactory.getLog(session.getClass());
+        this.wirelog = new Wire(wirelog);
+    }
+
+    public int getStatus() {
+        return this.session.getStatus();
+    }
+
+    public ByteChannel channel() {
+        return this.channel;
+    }
+
+    public SocketAddress getLocalAddress() {
+        return this.session.getLocalAddress();
+    }
+
+    public SocketAddress getRemoteAddress() {
+        return this.session.getRemoteAddress();
+    }
+
+    public int getEventMask() {
+        return this.session.getEventMask();
+    }
+
+    private static String formatOps(int ops) {
+        StringBuffer buffer = new StringBuffer(6);
+        buffer.append('[');
+        if ((ops & SelectionKey.OP_READ) > 0) {
+            buffer.append('r');
+        }
+        if ((ops & SelectionKey.OP_WRITE) > 0) {
+            buffer.append('w');
+        }
+        if ((ops & SelectionKey.OP_ACCEPT) > 0) {
+            buffer.append('a');
+        }
+        if ((ops & SelectionKey.OP_CONNECT) > 0) {
+            buffer.append('c');
+        }
+        buffer.append(']');
+        return buffer.toString();
+    }
+
+    public void setEventMask(int ops) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Set event mask "
+                    + formatOps(ops));
+        }
+        this.session.setEventMask(ops);
+    }
+
+    public void setEvent(int op) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Set event "
+                    + formatOps(op));
+        }
+        this.session.setEvent(op);
+    }
+
+    public void clearEvent(int op) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Clear event "
+                    + formatOps(op));
+        }
+        this.session.clearEvent(op);
+    }
+
+    public void close() {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Close");
+        }
+        this.session.close();
+    }
+
+    public boolean isClosed() {
+        return this.session.isClosed();
+    }
+
+    public void shutdown() {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Shutdown");
+        }
+        this.session.shutdown();
+    }
+
+    public int getSocketTimeout() {
+        return this.session.getSocketTimeout();
+    }
+
+    public void setSocketTimeout(int timeout) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Set timeout "
+                    + timeout);
+        }
+        this.session.setSocketTimeout(timeout);
+    }
+
+    public void setBufferStatus(final SessionBufferStatus status) {
+        this.session.setBufferStatus(status);
+    }
+
+    public boolean hasBufferedInput() {
+        return this.session.hasBufferedInput();
+    }
+
+    public boolean hasBufferedOutput() {
+        return this.session.hasBufferedOutput();
+    }
+
+    public Object getAttribute(final String name) {
+        return this.session.getAttribute(name);
+    }
+
+    public void setAttribute(final String name, final Object obj) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Set attribute "
+                    + name);
+        }
+        this.session.setAttribute(name, obj);
+    }
+
+    public Object removeAttribute(final String name) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("I/O session " + this.id + " " + this.session + ": Remove attribute "
+                    + name);
+        }
+        return this.session.removeAttribute(name);
+    }
+
+    class LoggingByteChannel implements ByteChannel {
+
+        public int read(final ByteBuffer dst) throws IOException {
+            int bytesRead = session.channel().read(dst);
+            if (log.isDebugEnabled()) {
+                log.debug("I/O session " + id + " " + session + ": " + bytesRead + " bytes read");
+            }
+            if (bytesRead > 0 && wirelog.isEnabled()) {
+                ByteBuffer b = dst.duplicate();
+                int p = b.position();
+                b.limit(p);
+                b.position(p - bytesRead);
+                wirelog.input(b);
+            }
+            return bytesRead;
+        }
+
+        public int write(final ByteBuffer src) throws IOException {
+            int byteWritten = session.channel().write(src);
+            if (log.isDebugEnabled()) {
+                log.debug("I/O session " + id + " " + session + ": " + byteWritten + " bytes written");
+            }
+            if (byteWritten > 0 && wirelog.isEnabled()) {
+                ByteBuffer b = src.duplicate();
+                int p = b.position();
+                b.limit(p);
+                b.position(p - byteWritten);
+                wirelog.output(b);
+            }
+            return byteWritten;
+        }
+
+        public void close() throws IOException {
+            if (log.isDebugEnabled()) {
+                log.debug("I/O session " + id + " " + session + ": Channel close");
+            }
+            session.channel().close();
+        }
+
+        public boolean isOpen() {
+            return session.channel().isOpen();
+        }
+
+    }       
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BinaryRelayBuilder.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BinaryRelayBuilder.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/BinaryRelayBuilder.java	(revision 1502663)
@@ -0,0 +1,83 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.*;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axiom.soap.SOAPFactory;
+import org.apache.axiom.soap.SOAPProcessingException;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.builder.Builder;
+import org.apache.axis2.context.MessageContext;
+
+import javax.activation.DataHandler;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+
+public class BinaryRelayBuilder implements Builder{
+
+	public static byte[] readAllFromInputSteam(InputStream in) throws IOException{
+		ByteArrayOutputStream out = new ByteArrayOutputStream();
+		byte[] buf = new byte[1024];
+		int read = in.read(buf);
+
+		while(read != -1){
+			out.write(buf,0,read);
+			read = in.read(buf);
+		}
+		return out.toByteArray();
+	}
+
+
+	public OMElement processDocument(InputStream inputStream,
+			String contentType, MessageContext messageContext) throws AxisFault {
+		try {
+            //Fix for https://wso2.org/jira/browse/CARBON-7256
+            messageContext.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+
+			//We will create a SOAP message, which holds the input message as a blob
+			SOAPFactory factory = OMAbstractFactory.getSOAP12Factory();
+			SOAPEnvelope env = factory.getDefaultEnvelope();
+            if (inputStream != null) {
+                OMNamespace ns = factory.createOMNamespace(
+                        RelayConstants.BINARY_CONTENT_QNAME.getNamespaceURI(), "ns");
+                OMElement omEle = factory.createOMElement(
+                        RelayConstants.BINARY_CONTENT_QNAME.getLocalPart(), ns);
+
+                StreamingOnRequestDataSource ds = new StreamingOnRequestDataSource(inputStream);
+                DataHandler dataHandler = new DataHandler(ds);
+
+                //create an OMText node with the above DataHandler and set optimized to true
+                OMText textData = factory.createOMText(dataHandler, true);
+                omEle.addChild(textData);
+                env.getBody().addChild(omEle);
+            }
+
+			return env;
+		} catch (SOAPProcessingException e) {
+			throw AxisFault.makeFault(e);
+		} catch (OMException e) {
+			throw AxisFault.makeFault(e);
+		}
+	}
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayConstants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/RelayConstants.java	(revision 1502663)
@@ -0,0 +1,51 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import javax.xml.namespace.QName;
+
+public final class RelayConstants {
+
+    public static final String RELAY_POLICY_NS =
+            "http://www.wso2.org/ns/2010/01/carbon/message-relay";
+
+    public static final String INCLUDE_HIDDEN_SERVICES = "includeHiddenServices";
+
+    public static final QName RELAY_ASSERTION_QNAME = new QName(RELAY_POLICY_NS, "RelayAssertion");
+
+    public static final QName INCLUDE_HIDDEN_SERVICES_QNAME =
+            new QName(RELAY_POLICY_NS, INCLUDE_HIDDEN_SERVICES);
+
+    public static final QName SERVICES_QNAME = new QName(RELAY_POLICY_NS, "services");
+    public static final QName SERVICE_QNAME = new QName(RELAY_POLICY_NS, "service");
+
+    public static final QName BUILDERS_QNAME = new QName(RELAY_POLICY_NS, "builders");
+    public static final QName MESSAGE_BUILDER_QNAME = new QName(RELAY_POLICY_NS, "messageBuilder");
+    public static final QName CONTENT_TYPE_QNAME = new QName("contentType");
+    public static final QName CLASS_NAME_QNAME = new QName("class");
+
+    public static final QName FORMATTER_CLASS_NAME_QNAME = new QName("class");
+
+    public static final String RELAY_CONFIG_PARAM = "__relay_configuration__";
+
+    public static final QName BINARY_CONTENT_QNAME =
+            new QName("http://ws.apache.org/commons/ns/payload", "binary");
+
+    public static final String FORCE_RESPONSE_EARLY_BUILD = "FORCE_RESPONSE_EARLY_BUILD";
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/StreamingOnRequestDataSource.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/StreamingOnRequestDataSource.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/StreamingOnRequestDataSource.java	(revision 1502663)
@@ -0,0 +1,82 @@
+/*
+ *  Copyright 2013 Apache Software Foundation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.attachments.ByteArrayDataSource;
+
+import javax.activation.DataSource;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+/**
+ * This class has a special flag, which says this is it's last use and not to cache data
+ * if it did not have done so already.
+ */
+public class StreamingOnRequestDataSource implements DataSource {
+    private InputStream in;
+
+    public StreamingOnRequestDataSource(InputStream in) {
+        super();
+        this.in = in;
+    }
+
+    private boolean lastUse = false;
+
+    private ByteArrayDataSource cachedData = null;
+
+    public String getContentType() {
+        return "application/octet-stream";
+    }
+
+    public InputStream getInputStream() throws IOException {
+        if (cachedData != null) {
+            return cachedData.getInputStream();
+        } else {
+            if (lastUse && in != null) {
+                InputStream returnStream = in;
+                this.in = null;
+                return returnStream;
+            } else if (in != null) {
+                byte[] data = BinaryRelayBuilder.readAllFromInputSteam(in);
+                cachedData = new ByteArrayDataSource(data);
+                return cachedData.getInputStream();
+            } else {
+                throw new IOException("Input stream has being already consumed");
+            }
+        }
+    }
+
+    public String getName() {
+        return "StreamingOnRequestDataSource";
+    }
+
+    public OutputStream getOutputStream() throws IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * This flag says that this is the last use of the stream, hence do not
+     * need to cache it if it has not
+     * already cached.
+     *
+     * @param lastUse
+     */
+    public void setLastUse(boolean lastUse) {
+        this.lastUse = lastUse;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/DeferredMessageBuilder.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/DeferredMessageBuilder.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/DeferredMessageBuilder.java	(revision 1502663)
@@ -0,0 +1,241 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.util;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.soap.SOAPEnvelope;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.builder.*;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.http.ApplicationXMLFormatter;
+import org.apache.axis2.transport.http.HTTPTransportUtils;
+import org.apache.axis2.transport.http.MultipartFormDataFormatter;
+import org.apache.axis2.transport.http.SOAPMessageFormatter;
+import org.apache.axis2.transport.http.XFormURLEncodedFormatter;
+import org.apache.axis2.util.JavaUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.xml.stream.XMLStreamException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class DeferredMessageBuilder {
+
+    private static Log log = LogFactory.getLog(DeferredMessageBuilder.class);
+
+    private Map<String, Builder> builders = new HashMap<String, Builder>();
+    private Map<String, MessageFormatter> formatters = new HashMap<String, MessageFormatter>();
+
+    public final static String RELAY_FORMATTERS_MAP = "__RELAY_FORMATTERS_MAP";
+    public final static String FORCED_RELAY_FORMATTER = "__FORCED_RELAY_FORMATTER";
+
+    public DeferredMessageBuilder() {
+        // first initialize with the default builders
+        builders.put("multipart/related", new MIMEBuilder());
+        builders.put("application/soap+xml", new SOAPBuilder());
+        builders.put("text/xml", new SOAPBuilder());
+        builders.put("application/xop+xml", new MTOMBuilder());
+        builders.put("application/xml", new ApplicationXMLBuilder());
+        builders.put("application/x-www-form-urlencoded",
+                new XFormURLEncodedBuilder());
+
+        // initialize the default formatters
+        formatters.put("application/x-www-form-urlencoded", new XFormURLEncodedFormatter());
+        formatters.put("multipart/form-data", new MultipartFormDataFormatter());
+        formatters.put("application/xml", new ApplicationXMLFormatter());
+        formatters.put("text/xml", new SOAPMessageFormatter());
+        formatters.put("application/soap+xml", new SOAPMessageFormatter());
+    }
+
+    public Map<String, Builder> getBuilders() {
+        return builders;
+    }
+
+    public void addBuilder(String contentType, Builder builder) {
+        builders.put(contentType, builder);
+    }
+
+    public void addFormatter(String contentType, MessageFormatter messageFormatter) {
+        formatters.put(contentType, messageFormatter);
+    }
+
+    public Map<String, MessageFormatter> getFormatters() {
+        return formatters;
+    }
+
+    public OMElement getDocument(MessageContext msgCtx, InputStream in) throws
+            XMLStreamException, IOException {
+   	  
+    	
+    	String contentType = (String) msgCtx.getProperty(Constants.Configuration.CONTENT_TYPE);
+    	String _contentType =contentType;
+ 	    in = HTTPTransportUtils.handleGZip(msgCtx, in);
+ 		if (contentType != null) {
+ 			int j = contentType.indexOf(";");
+ 			if (j > 0) {
+ 				_contentType = contentType.substring(0, j);
+ 			}
+ 		}
+    	
+    	
+    	AxisConfiguration configuration =
+    		  msgCtx.getConfigurationContext().getAxisConfiguration();
+      Parameter useFallbackParameter = configuration.getParameter(Constants.Configuration.USE_DEFAULT_FALLBACK_BUILDER);
+     
+      boolean useFallbackBuilder = false;
+      
+      if (useFallbackParameter !=null){
+      	useFallbackBuilder = JavaUtils.isTrueExplicitly(useFallbackParameter.getValue(),useFallbackBuilder);
+      }
+    	
+    	OMElement element = null;
+        Builder builder;
+        if (contentType != null) {
+            // loading builder from externally..
+            builder = configuration.getMessageBuilder(_contentType,useFallbackBuilder);
+            if (builder != null) {
+                try {
+                    /*try {
+                        throw new Exception("Building message");
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                    }*/
+                    element = builder.processDocument(in,contentType, msgCtx);
+                } catch (AxisFault axisFault) {
+                    log.error("Error building message", axisFault);
+                    throw axisFault;
+                }
+            }
+        }
+
+        if (element == null) {
+            if (msgCtx.isDoingREST()) {
+                try {
+                    element = BuilderUtil.getPOXBuilder(in, null).getDocumentElement();
+                } catch (XMLStreamException e) {
+                    log.error("Error building message using POX Builder", e);
+                    throw e;
+                }
+            } else {
+                // switch to default
+                builder = new SOAPBuilder();
+                try {
+                    element = builder.processDocument(in, contentType, msgCtx);
+                } catch (AxisFault axisFault) {
+                    log.error("Error building message using SOAP builder");
+                    throw axisFault;
+                }
+            }
+        }
+
+        // build the soap headers and body
+        if (element instanceof SOAPEnvelope) {
+            SOAPEnvelope env = (SOAPEnvelope) element;
+            env.hasFault();
+        }
+
+        //setting up original contentType (resetting the content type)
+        if(contentType != null && !contentType.isEmpty()){
+         msgCtx.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+        }
+        return element;
+    }
+
+    private Builder getBuilderForContentType(String contentType) {
+        String type;
+        int index = contentType.indexOf(';');
+        if (index > 0) {
+            type = contentType.substring(0, index);
+        } else {
+            type = contentType;
+        }
+
+        Builder builder = builders.get(type);
+
+        if (builder == null) {
+            builder = builders.get(type.toLowerCase());
+        }
+
+        if (builder == null) {
+            Iterator<Map.Entry<String, Builder>> iterator = builders.entrySet().iterator();
+            while (iterator.hasNext() && builder == null) {
+                Map.Entry<String, Builder> entry = iterator.next();
+                String key = entry.getKey();
+                if (contentType.matches(key)) {
+                    builder = entry.getValue();
+                }
+            }
+        }
+        return builder;
+    }
+
+    public static Builder createBuilder(String className) throws AxisFault {
+        try {
+            Class c = Class.forName(className);
+            Object o = c.newInstance();
+            if (o instanceof Builder) {
+                return (Builder) o;
+            }
+        } catch (ClassNotFoundException e) {
+            handleException("Builder class not found :" +
+                    className, e);
+        } catch (IllegalAccessException e) {
+            handleException("Cannot initiate Builder class :" +
+                    className, e);
+        } catch (InstantiationException e) {
+            handleException("Cannot initiate Builder class :" +
+                    className, e);
+        }
+        return null;
+    }
+
+    public static MessageFormatter createFormatter(String className) throws AxisFault {
+        try {
+            Class c = Class.forName(className);
+            Object o = c.newInstance();
+            if (o instanceof MessageFormatter) {
+                return (MessageFormatter) o;
+            }
+        } catch (ClassNotFoundException e) {
+            handleException("MessageFormatter class not found :" +
+                    className, e);
+        } catch (IllegalAccessException e) {
+            handleException("Cannot initiate MessageFormatter class :" +
+                    className, e);
+        } catch (InstantiationException e) {
+            handleException("Cannot initiate MessageFormatter class :" +
+                    className, e);
+        }
+        return null;
+    }
+
+    private static void handleException(String message, Exception e) throws AxisFault {
+        log.error(message, e);
+        throw new AxisFault(message, e);
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java	(revision 1502663)
@@ -0,0 +1,335 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.util.MessageProcessorSelector;
+import org.apache.commons.io.IOUtils;
+import org.apache.http.*;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.message.BasicHttpEntityEnclosingRequest;
+import org.apache.http.message.BasicHttpRequest;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.http.params.DefaultedHttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;
+import org.apache.synapse.transport.passthru.util.RelayUtils;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.stream.XMLStreamException;
+
+/**
+ * This is a class for representing a request to be sent to a target.
+ */
+public class TargetRequest {
+    /** Configuration of the sender */
+    private TargetConfiguration targetConfiguration;
+
+    private Pipe pipe = null;
+    /** Headers map */
+    private Map<String, String> headers = new HashMap<String, String>();
+    /** URL */
+    private URL url;
+    /** HTTP Method */
+    private String method;
+    /** HTTP request created for sending the message */
+    private HttpRequest request = null;
+    /** Weather chunk encoding should be used */
+    private boolean chunk = true;
+    /** HTTP version that should be used */
+    private ProtocolVersion version = null;
+    /** Weather full url is used for the request */
+    private boolean fullUrl = false;
+    /** Port to be used for the request */
+    private int port = 80;
+    /** Weather this request has a body */
+    private boolean hasEntityBody = true;
+    /** Keep alive request */
+    private boolean keepAlive = true;
+    
+    /**
+     * Create a target request.
+     *
+     * @param targetConfiguration the configuration of the sender
+     * @param url the url to be used
+     * @param method the HTTP method
+     * @param hasEntityBody weather request has an entity body
+     */
+    public TargetRequest(TargetConfiguration targetConfiguration, URL url,
+                         String method, boolean hasEntityBody) {
+        this(targetConfiguration, method, url, hasEntityBody);
+    }
+
+    public TargetRequest(TargetConfiguration targetConfiguration, String method,
+                         URL url, boolean hasEntityBody) {
+        this.method = method;
+        this.url = url;
+        this.targetConfiguration = targetConfiguration;
+        this.hasEntityBody = hasEntityBody;
+    }
+
+    public void connect(Pipe pipe) {
+        this.pipe = pipe;
+    }
+
+    public void start(NHttpClientConnection conn) throws IOException, HttpException {
+        if (pipe != null) {
+            TargetContext.get(conn).setWriter(pipe);
+        }
+
+        String path = fullUrl ?
+                    url.toString() : url.getPath() +
+                    (url.getQuery() != null ? "?" + url.getQuery() : "");
+
+        long contentLength = -1;
+        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);
+        if (contentLengthHeader != null) {
+            contentLength = Integer.parseInt(contentLengthHeader);
+            headers.remove(HTTP.CONTENT_LEN);
+        }
+        
+        MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
+        
+        if(requestMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_MESSAGE_LENGTH) != null){
+        	contentLength = (Long)requestMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_MESSAGE_LENGTH);
+        }
+        
+       
+        //fix for  POST_TO_URI
+        if(requestMsgCtx.isPropertyTrue(NhttpConstants.POST_TO_URI)){
+        	path = url.toString();
+        }
+                                                            
+        if (hasEntityBody) {
+            request = new BasicHttpEntityEnclosingRequest(method, path,
+                    version != null ? version : HttpVersion.HTTP_1_1);
+
+            BasicHttpEntity entity = new BasicHttpEntity();
+
+            if (contentLength != -1) {
+                entity.setChunked(false);
+                entity.setContentLength(contentLength);
+            } else {
+                entity.setChunked(chunk);
+            }
+            ((BasicHttpEntityEnclosingRequest) request).setEntity(entity);
+           
+        } else {
+            request = new BasicHttpRequest(method, path,
+                    version != null ? version : HttpVersion.HTTP_1_1);
+        }
+
+        Set<Map.Entry<String, String>> entries = headers.entrySet();
+        for (Map.Entry<String, String> entry : entries) {
+            request.setHeader(entry.getKey(), entry.getValue());
+        }
+        
+        //setup wsa action..
+        if(request != null){
+        	
+    		String soapAction = requestMsgCtx.getSoapAction();
+            if (soapAction == null) {
+                soapAction = requestMsgCtx.getWSAAction();
+            }
+            if (soapAction == null) {
+            	requestMsgCtx.getAxisOperation().getInputAction();
+            }
+
+            if (requestMsgCtx.isSOAP11() && soapAction != null &&
+                    soapAction.length() > 0) {
+                Header existingHeader =
+                	request.getFirstHeader(HTTPConstants.HEADER_SOAP_ACTION);
+                if (existingHeader != null) {
+                	request.removeHeader(existingHeader);
+                }
+                MessageFormatter messageFormatter =
+                    MessageFormatterDecoratorFactory.createMessageFormatterDecorator(requestMsgCtx);
+                request.setHeader(HTTPConstants.HEADER_SOAP_ACTION,
+                        messageFormatter.formatSOAPAction(requestMsgCtx, null, soapAction));
+                request.setHeader(HTTPConstants.USER_AGENT,"Synapse-PT-HttpComponents-NIO");
+            }
+    	}
+
+        request.setParams(new DefaultedHttpParams(request.getParams(),
+                targetConfiguration.getHttpParameters()));
+        
+        
+	
+		
+		this.processChunking(conn, requestMsgCtx);
+		
+
+        if (!keepAlive) {
+            request.setHeader(HTTP.CONN_DIRECTIVE, HTTP.CONN_CLOSE);
+        }
+        
+       
+
+        // Pre-process HTTP request
+        conn.getContext().setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
+        conn.getContext().setAttribute(ExecutionContext.HTTP_TARGET_HOST,
+                new HttpHost(url.getHost(), port));
+        conn.getContext().setAttribute(ExecutionContext.HTTP_REQUEST, request);
+
+        // start the request
+        targetConfiguration.getHttpProcessor().process(request, conn.getContext());
+        
+        
+        conn.submitRequest(request);
+
+        if (hasEntityBody) {
+            TargetContext.updateState(conn, ProtocolState.REQUEST_HEAD);
+        } else {
+            TargetContext.updateState(conn, ProtocolState.REQUEST_DONE);
+        }
+    }
+
+	/**
+	 * Handles the chuking messages in Passthough context, create a temporary buffer and calculate the message
+	 * size before writing to the external buffer, which is required the context of handling DISABLED chunking 
+	 * messages
+	 * 
+	 * @param conn
+	 * @param requestMsgCtx
+	 * @param disableChunking
+	 * @throws IOException
+	 * @throws AxisFault
+	 */
+	private void processChunking(NHttpClientConnection conn, MessageContext requestMsgCtx) throws IOException,
+	                                                                                                        AxisFault {
+		String disableChunking = (String) requestMsgCtx.getProperty(PassThroughConstants.DISABLE_CHUNKING);
+		String forceHttp10 = (String) requestMsgCtx.getProperty(PassThroughConstants.FORCE_HTTP_1_0);
+	    if ("true".equals(disableChunking) || "true".equals(forceHttp10)) {
+	    	if (requestMsgCtx.getEnvelope().getBody().getFirstElement() == null) {
+				BasicHttpEntity entity = (BasicHttpEntity) ((BasicHttpEntityEnclosingRequest) request).getEntity();    
+				try {
+					RelayUtils.buildMessage(requestMsgCtx);
+					this.hasEntityBody = true;
+					Pipe pipe = (Pipe) requestMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+					if (pipe != null) {
+						pipe.attachConsumer(conn);
+						this.connect(pipe);
+						if (Boolean.TRUE.equals(requestMsgCtx.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {
+							ByteArrayOutputStream out = new ByteArrayOutputStream();
+							MessageFormatter formatter =  MessageProcessorSelector.getMessageFormatter(requestMsgCtx);
+							OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(requestMsgCtx);
+							formatter.writeTo(requestMsgCtx, format, out, false);
+							OutputStream _out = pipe.getOutputStream();
+							IOUtils.write(out.toByteArray(), _out);
+						
+							entity.setContentLength(new Long(out.toByteArray().length));
+							entity.setChunked(false);
+						}
+					}
+					// pipe.setSerializationComplete(true);
+				} catch (XMLStreamException e) {
+					 e.printStackTrace();
+				
+				}
+			}
+
+		}  
+    }
+
+    /**
+     * Consume the data from the pipe and write it to the wire.
+     *
+     * @param conn the connection to the target
+     * @param encoder encoder for writing the message through
+     * @throws java.io.IOException if an error occurs
+     * @return number of bytes written
+     */
+    public int write(NHttpClientConnection conn, ContentEncoder encoder) throws IOException {
+        int bytes = 0;
+        if (pipe != null) {
+            bytes = pipe.consume(encoder);
+        }
+
+        if (encoder.isCompleted()) {
+            targetConfiguration.getMetrics().
+                    notifySentMessageSize(conn.getMetrics().getSentBytesCount());
+
+            TargetContext.updateState(conn, ProtocolState.REQUEST_DONE);
+        }
+        
+        return bytes;
+
+    }
+
+    public boolean hasEntityBody() {
+        return hasEntityBody;
+    }
+    
+    
+    public void setHasEntityBody(boolean hasEntityBody) {
+		this.hasEntityBody = hasEntityBody;
+	}
+
+	public void addHeader(String name, String value) {
+        headers.put(name, value);
+    }
+
+    public String getMethod() {
+        return method;
+    }
+
+    public void setChunk(boolean chunk) {
+        this.chunk = chunk;
+    }
+
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    public void setFullUrl(boolean fullUrl) {
+        this.fullUrl = fullUrl;
+    }
+
+    public void setVersion(ProtocolVersion version) {
+        this.version = version;
+    }
+
+    public void setKeepAlive(boolean keepAlive) {
+        this.keepAlive = keepAlive;
+    }
+
+	public HttpRequest getRequest() {
+		return request;
+	}
+    
+    
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/HostConnections.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/HostConnections.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/HostConnections.java	(revision 1502663)
@@ -0,0 +1,163 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.connections;
+
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HttpContext;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This stores connections for a particular host + port.
+ */
+public class HostConnections {
+    private static final Log log = LogFactory.getLog(HostConnections.class);
+    // host
+    private String host;
+    // port
+    private int port;
+    // maximum number of connections allowed for this host + port
+    private int maxSize;
+    // number of awaiting connections
+    private int pendingConnections;
+    // list of free connections available
+    private List<NHttpClientConnection> freeConnections = new ArrayList<NHttpClientConnection>();
+    // list of connections in use
+    private List<NHttpClientConnection> busyConnections = new ArrayList<NHttpClientConnection>();
+
+    private Lock lock = new ReentrantLock();
+
+    public HostConnections(String host, int port, int maxSize) {
+        if (log.isDebugEnabled()) {
+            log.debug("Creating new connection pool to the host: " + host + ", port: " + port);
+        }
+        this.host = host;
+        this.port = port;
+        this.maxSize = maxSize;
+    }
+
+    /**
+     * Get a connection for the host:port
+     *
+     * @return a connection
+     */
+    public NHttpClientConnection getConnection() {
+        lock.lock();
+        try {
+            if (freeConnections.size() > 0) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Returning an existing free connection to " + host + ":" + port);
+                }
+                NHttpClientConnection conn = freeConnections.get(0);
+                freeConnections.remove(conn);
+                busyConnections.add(conn);
+                return conn;
+            }
+        } finally {
+            lock.unlock();
+        }
+        return null;
+    }
+
+    public void release(NHttpClientConnection conn) {
+        conn.getMetrics().reset();
+        HttpContext ctx = conn.getContext();
+        ctx.removeAttribute(ExecutionContext.HTTP_REQUEST);
+        ctx.removeAttribute(ExecutionContext.HTTP_RESPONSE);
+
+        lock.lock();
+        try {
+            if (busyConnections.remove(conn)) {
+                freeConnections.add(conn);
+            } else {
+                log.error("Attempted to releaseConnection connection not in the busy list");
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void forget(NHttpClientConnection conn) {
+        lock.lock();
+        try {
+            if (!freeConnections.remove(conn)) {
+                busyConnections.remove(conn);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void addConnection(NHttpClientConnection conn) {
+        if (log.isDebugEnabled()) {
+            log.debug("New connection to " + host + ":" + port + " is added to the free list");
+        }
+        lock.lock();
+        try {
+            freeConnections.add(conn);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Indicates that a connection has been successfully established with a remote server
+     * as notified by the session request call back.
+     */
+    public synchronized void pendingConnectionSucceeded() {
+        lock.lock();
+        try {
+            pendingConnections--;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Keep track of the number of times connections to this host:port has failed
+     * consecutively
+     */
+    public void pendingConnectionFailed() {
+        lock.lock();
+        try {
+            pendingConnections--;
+        } finally {
+            lock.unlock();
+        }
+    }    
+
+    public String getHost() {
+        return host;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public boolean canHaveMoreConnections() {
+        return busyConnections.size() + pendingConnections < maxSize;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/SourceConnections.java	(revision 1502663)
@@ -0,0 +1,178 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.connections;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.synapse.transport.passthru.SourceContext;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * Keeps track of the connections coming in to the transport.
+ */
+public class SourceConnections {
+    private static Log log = LogFactory.getLog(SourceConnections.class);
+
+    /** The pool of connections in use */
+    private volatile List<NHttpServerConnection> busyConnections = new ArrayList<NHttpServerConnection>();
+
+    /** The pool of connections that are not being used */
+    private volatile List<NHttpServerConnection> freeConnections = new ArrayList<NHttpServerConnection>();
+
+    /** Lock for synchronizing the access to the pools */
+    private final Lock lock = new ReentrantLock();
+
+    /** Max free connections allowed in a given instance of time */
+    private int maxFreeConnections;
+
+    /** Max busy connections allowed in a given instance of time */
+    private int maxBusyConnections;
+
+    /**
+     * Add a connection to the pool.
+     *
+     * @param conn connection to be added
+     */
+    public void addConnection(NHttpServerConnection conn) {
+        lock.lock();
+        try {
+            freeConnections.add(conn);
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * This method should be called when ever a connection being used for processing
+     * a request-response.
+     *
+     * @param conn the connection to be used
+     */
+    public void useConnection(NHttpServerConnection conn) {
+        lock.lock();
+        try {
+            boolean freeConnection = freeConnections.remove(conn);
+            if (freeConnection) {
+                busyConnections.add(conn);
+            } else {
+                if (busyConnections.contains(conn)) {
+                    throw new IllegalStateException("The connection is busy. " +
+                            "Cannot use it for new request");
+                } else {
+                    throw new IllegalStateException("Trying to use a connection " +
+                            "which is not in free connections " + conn);
+                }
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * This method should be called after a connection is being used for a request-response.
+     *
+     * @param conn the connection being used
+     */
+    public void releaseConnection(NHttpServerConnection conn) {
+        lock.lock();
+        try {
+            SourceContext.get(conn).reset();
+
+            if (busyConnections.remove(conn)) {
+                freeConnections.add(conn);
+            } else {
+                throw new IllegalStateException("Trying to finish using a connection " +
+                        "which is not in busy connections " + conn);
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Shutdown a connection
+     *
+     * @param conn the connection that needs to be shut down
+     */
+    public void shutDownConnection(NHttpServerConnection conn) {
+        if (log.isDebugEnabled()) {
+            log.debug("Shutting down connection forcefully " + conn);
+        }
+        lock.lock();
+        try {
+            SourceContext.get(conn).reset();
+
+            if (!busyConnections.remove(conn)) {
+                freeConnections.remove(conn);
+            }
+
+            try {
+                conn.shutdown();
+            } catch (IOException ignored) {
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+
+    /**
+     * Close a connection gracefully.
+     *
+     * @param conn the connection that needs to be closed.
+     */
+    public void closeConnection(NHttpServerConnection conn) {
+        if (log.isDebugEnabled()) {
+            log.debug("Shutting down connection forcefully " + conn);
+        }
+        lock.lock();
+        try {
+            SourceContext.get(conn).reset();
+
+            if (!busyConnections.remove(conn)) {
+                freeConnections.remove(conn);
+            }
+
+            try {
+                conn.close();
+            } catch (IOException ignored) {
+            }
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void destroy() {
+        for (NHttpServerConnection conn : freeConnections) {
+            shutDownConnection(conn);
+        }
+
+        // for all the busy connections we have to notify that their cannot
+        // be anymore requests over them
+        for (NHttpServerConnection conn : busyConnections) {
+            SourceContext.get(conn).setShutDown(true);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/TargetConnections.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/TargetConnections.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/connections/TargetConnections.java	(revision 1502663)
@@ -0,0 +1,179 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.connections;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.http.nio.reactor.ConnectingIOReactor;
+import org.apache.synapse.transport.passthru.ConnectCallback;
+import org.apache.synapse.transport.passthru.PassThroughConstants;
+import org.apache.synapse.transport.passthru.TargetContext;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.net.InetSocketAddress;
+
+/**
+ * Manages the connection from transport to the back end servers. It keeps track of the
+ * connections for host:port pair. 
+ */
+public class TargetConnections {
+    private static final Log log = LogFactory.getLog(TargetConnections.class);
+
+    /** map to hold the ConnectionPools. The key is host:port */
+    private final Map<String, HostConnections> poolMap =
+            new ConcurrentHashMap<String, HostConnections>();
+
+    /** max connections per host:port pair. At the moment all the host:ports can
+     * have the same max */
+    private int maxConnections;
+
+    /** io-reactor to use for creating connections */
+    private ConnectingIOReactor ioReactor;
+
+    /** callback invoked when a connection is made */
+    private ConnectCallback callback = null;
+
+    /**
+     * Create a TargetConnections with the given IO-Reactor
+     *
+     * @param ioReactor the IO-Reactor
+     * @param targetConfiguration the configuration of the sender
+     * @param callback the callback
+     */
+    public TargetConnections(ConnectingIOReactor ioReactor,
+                             TargetConfiguration targetConfiguration,
+                             ConnectCallback callback) {
+
+        this.maxConnections = targetConfiguration.getMaxConnections();
+        this.ioReactor = ioReactor;
+        this.callback = callback;
+    }
+
+    /**
+     * Return a connection to the host:port pair. If a connection is not available
+     * return <code>null</code>. If the particular host:port allows to create more connections
+     * this method will try to connect asynchronously. If the connection is successful it will
+     * be notified in a separate thread.
+     *
+     * @param host host
+     * @param port port
+     * @return Either returns a connection if already available or returns null and notifies
+     *         the delivery agent when the connection is available
+     */
+    public NHttpClientConnection getConnection(String host, int port) {
+        if (log.isDebugEnabled()) {
+            log.debug("Trying to get a connection to the " + host + ":" + port);
+        }
+
+        HostConnections pool = getConnectionPool(host, port);
+
+        // trying to get an existing connection
+        NHttpClientConnection connection = pool.getConnection();
+        if (connection == null) {
+            if (pool.canHaveMoreConnections()) {
+                ioReactor.connect(new InetSocketAddress(host, port), null, pool, callback);
+            } else {
+                log.warn("Connection pool reached maximum allowed connections for: "
+                        + host + ":" + port + ". Target server may have become slow");
+            }
+        }
+
+        return connection;
+    }
+
+    /**
+     * This connection is no longer valid. So we need to shutdownConnection connection.
+     *
+     * @param conn connection to shutdownConnection
+     */
+    public void shutdownConnection(NHttpClientConnection conn) {
+        HostConnections pool = (HostConnections) conn.getContext().getAttribute(
+                PassThroughConstants.CONNECTION_POOL);
+
+        TargetContext.get(conn).reset();
+
+        if (pool != null) {
+            pool.forget(conn);
+        } else {
+            // we shouldn't get here
+            log.fatal("Connection without a pool. Something wrong. Need to fix.");
+        }
+
+        try {
+            conn.shutdown();
+        } catch (IOException ignored) {
+        }
+    }
+
+    /**
+     * Release an active connection to the pool
+     *
+     * @param conn connection to be released
+     */
+    public void releaseConnection(NHttpClientConnection conn) {
+        HostConnections pool = (HostConnections) conn.getContext().getAttribute(
+                PassThroughConstants.CONNECTION_POOL);
+
+        TargetContext.get(conn).reset();
+
+        if (pool != null) {
+            pool.release(conn);
+        } else {
+            // we shouldn't get here
+            log.fatal("Connection without a pool. Something wrong. Need to fix.");
+        }
+    }
+
+    /**
+     * This method is called when a new connection is made.
+     *
+     * @param conn connection to the target server     
+     */
+    public void addConnection(NHttpClientConnection conn) {
+        HostConnections pool = (HostConnections) conn.getContext().getAttribute(
+                PassThroughConstants.CONNECTION_POOL);
+        if (pool != null) {
+            pool.addConnection(conn);
+        } else {
+            // we shouldn't get here
+            log.fatal("Connection without a pool. Something wrong. Need to fix.");            
+        }
+    }
+
+    private HostConnections getConnectionPool(String host, int port) {
+        String key = host + ":" + port;
+        // see weather a pool already exists for this host:port
+        HostConnections pool = poolMap.get(key);
+        synchronized (poolMap) {
+            if (pool == null) {
+                pool = new HostConnections(host, port, maxConnections);
+                poolMap.put(key, pool);
+            }
+        }
+
+        return pool;
+    }
+
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/DeliveryAgent.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/DeliveryAgent.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/DeliveryAgent.java	(revision 1502663)
@@ -0,0 +1,252 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+import org.apache.synapse.transport.passthru.connections.TargetConnections;
+import org.apache.synapse.transport.passthru.util.TargetRequestFactory;
+
+import java.io.OutputStream;
+import java.util.Queue;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.net.URL;
+import java.net.MalformedURLException;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This class acts as a gateway for differed delivery of the messages. When a message is to be
+ * delivered it is submitted to this class. If a connection is available to the target this
+ * class will try to deliver the message immediately over that connection. If a connection is
+ * not available it will queue the message and request a connection from the pool. When a new
+ * connection is available a queued message will be sent through it. 
+ */
+public class DeliveryAgent {
+
+    private static final Log log = LogFactory.getLog(DeliveryAgent.class);
+
+    /**
+     * This Map holds the messages that need to be delivered. But at the moment maximum
+     * number of connections to the host:pair is being used. So these messages has to wait
+     * until a new connection is available.
+     */
+    private Map<String, Queue<MessageContext>> waitingMessages =
+            new ConcurrentHashMap<String, Queue<MessageContext>>();
+
+    /** The connection management */
+    private TargetConnections targetConnections;
+
+    /** Configuration of the sender */
+    private TargetConfiguration targetConfiguration;
+
+    /** The maximum number of messages that can wait for a connection */
+    private int maxWaitingMessages = Integer.MAX_VALUE;
+
+    private TargetErrorHandler targetErrorHandler;
+
+    /** Lock for synchronizing access */
+    private Lock lock = new ReentrantLock();
+
+    /**
+     * Create a delivery agent with the target configuration and connection management.
+     *
+     * @param targetConfiguration configuration of the sender
+     * @param targetConnections connection management
+     */
+    public DeliveryAgent(TargetConfiguration targetConfiguration,
+                         TargetConnections targetConnections) {
+        this.targetConfiguration = targetConfiguration;
+        this.targetConnections = targetConnections;
+        this.targetErrorHandler = new TargetErrorHandler(targetConfiguration);
+    }
+
+
+    /**
+     * This method queues the message for delivery. If a connection is already existing for
+     * the destination epr, the message will be delivered immediately. Otherwise message has
+     * to wait until a connection is established. In this case this method will inform the
+     * system about the need for a connection.
+     *
+     * @param msgContext the message context to be sent
+     * @param epr the endpoint to which the message should be sent
+     * @throws AxisFault if an error occurs
+     */
+    public void submit(MessageContext msgContext, EndpointReference epr)
+            throws AxisFault {
+        try {
+            URL url = new URL(epr.getAddress());
+            String host = url.getHost();
+            int port = url.getPort();
+            if (port == -1) {
+                // use default
+                if ("http".equals(url.getProtocol())) {
+                    port = 80;
+                } else if ("https".equals(url.getProtocol())) {
+                    port = 443;
+                }
+            }
+
+            String key = host + ":" + port;
+
+            // first we queue the message
+            Queue<MessageContext> queue = null;
+            lock.lock();
+            try {
+                queue = waitingMessages.get(key);
+                if (queue == null) {
+                    queue = new ConcurrentLinkedQueue<MessageContext>();
+                    waitingMessages.put(key, queue);
+                }
+                if (queue.size() == maxWaitingMessages) {
+                    MessageContext msgCtx = queue.poll();
+
+                    targetErrorHandler.handleError(msgCtx,
+                            ErrorCodes.CONNECTION_TIMEOUT,
+                            "Error connecting to the back end",
+                            null,
+                            ProtocolState.REQUEST_READY);
+                }
+
+                queue.add(msgContext);
+            } finally {
+                lock.unlock();
+            }
+
+            NHttpClientConnection conn = targetConnections.getConnection(host, port);
+            if (conn != null) {
+            	conn.resetInput();
+            	conn.resetOutput();
+                MessageContext messageContext = queue.poll();
+
+                if (messageContext != null) {
+                    tryNextMessage(messageContext, conn);
+                }
+            }
+
+        } catch (MalformedURLException e) {
+            handleException("Malformed URL in the target EPR", e);
+        }
+    }
+
+    public void errorConnecting(String host, int port, int errorCode, String message) {
+        String key = host + ":" + port;
+
+        Queue<MessageContext> queue = waitingMessages.get(key);
+        if (queue != null) {
+            MessageContext msgCtx = queue.poll();
+
+            if (msgCtx != null) {
+                targetErrorHandler.handleError(msgCtx,
+                        errorCode,
+                        "Error connecting to the back end",
+                        null,
+                        ProtocolState.REQUEST_READY);
+            }
+        } else {
+            throw new IllegalStateException("Queue cannot be null for: " + key);
+        }
+    }
+
+    /**
+     * Notification for a connection availability. When this occurs a message in the
+     * queue for delivery will be tried.
+     *
+     * @param host name of the remote host
+     * @param port remote port number
+     */
+    public void connected(String host, int port) {
+        Queue<MessageContext> queue = null;
+        lock.lock();
+        try {
+            queue = waitingMessages.get(host + ":" + port);
+        } finally {
+            lock.unlock();
+        }
+
+        while (queue.size() > 0) {
+            NHttpClientConnection conn = targetConnections.getConnection(host, port);
+            if (conn != null) {
+                MessageContext messageContext = queue.poll();
+
+                if (messageContext != null) {
+                    tryNextMessage(messageContext, conn);
+                }
+            } else {
+                break;
+            }
+        }
+    }
+
+    private void tryNextMessage(MessageContext messageContext, NHttpClientConnection conn) {
+        if (conn != null) {
+            try {
+                TargetContext.get(conn).setRequestMsgCtx(messageContext);
+
+                submitRequest(conn, messageContext);
+            } catch (AxisFault e) {
+                log.error("IO error while sending the request out", e);
+            }
+        }
+    }
+
+    private void submitRequest(NHttpClientConnection conn, MessageContext msgContext) throws AxisFault {
+        if (log.isDebugEnabled()) {
+            log.debug("Submitting new request to the connection: " + conn);
+        }
+
+        TargetRequest request = TargetRequestFactory.create(msgContext, targetConfiguration);
+        TargetContext.setRequest(conn, request);
+
+        Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+        if (pipe != null) {
+            pipe.attachConsumer(conn);
+            request.connect(pipe);
+            if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {
+                synchronized (msgContext) {
+                    OutputStream out = pipe.getOutputStream();
+                    msgContext.setProperty("GET_ME_OUT", out);
+                    msgContext.setProperty("READY2ROCK", Boolean.TRUE);
+                    msgContext.notifyAll();
+                }
+                return;
+            }
+        }
+
+        conn.requestOutput();
+    }    
+
+    /**
+     * Throws an AxisFault if an error occurs at this level
+     * @param s a message describing the error
+     * @param e original exception leads to the error condition
+     * @throws AxisFault wrapping the original exception
+     */
+    private void handleException(String s, Exception e) throws AxisFault {
+        log.error(s, e);
+        throw new AxisFault(s, e);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java	(revision 1502663)
@@ -0,0 +1,129 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+public class PassThroughConstants {
+
+    public static final int DEFAULT_IO_THREAD_COUNT = Runtime.getRuntime().availableProcessors();
+    public static final int DEFAULT_MAX_CONN_PER_HOST_PORT = Integer.MAX_VALUE;
+    
+    public static final String REQUEST_MESSAGE_CONTEXT = "REQUEST_MESSAGE_CONTEXT";
+    public static final String CONNECTION_POOL = "CONNECTION_POOL";
+
+    public static final String TRUE = "TRUE";
+
+    public static final String FAULT_MESSAGE = "FAULT_MESSAGE"; // corresponds with BaseConstants
+    public static final String FAULTS_AS_HTTP_200 = "FAULTS_AS_HTTP_200";
+    public static final String SC_ACCEPTED = "SC_ACCEPTED";
+    public static final String HTTP_SC = "HTTP_SC";
+    public static final String FORCE_HTTP_1_0 = "FORCE_HTTP_1.0";
+    public static final String DISABLE_CHUNKING = "DISABLE_CHUNKING";
+    public static final String FULL_URI = "FULL_URI";
+    public static final String NO_KEEPALIVE = "NO_KEEPALIVE";
+    public static final String DISABLE_KEEPALIVE = "http.connection.disable.keepalive";
+    public static final String IGNORE_SC_ACCEPTED = "IGNORE_SC_ACCEPTED";
+    public static final String FORCE_SC_ACCEPTED = "FORCE_SC_ACCEPTED";
+    public static final String DISCARD_ON_COMPLETE = "DISCARD_ON_COMPLETE";
+
+    public static final String SERVICE_URI_LOCATION = "ServiceURI";
+
+    public static final String WSDL_EPR_PREFIX = "WSDLEPRPrefix";
+
+    public static final String EPR_TO_SERVICE_NAME_MAP = "service.epr.map";
+    public static final String NON_BLOCKING_TRANSPORT = "NonBlockingTransport";
+    public static final String SERIALIZED_BYTES = "SerializedBytes";
+
+    public static final String CONTENT_TYPE = "CONTENT_TYPE";
+
+    public static final String DEFAULT_CONTENT_TYPE = "application/octet-stream";
+
+    public static final String HIDDEN_SERVICE_PARAM_NAME = "hiddenService";
+
+    /** An Axis2 message context property indicating a transport send failure */
+    public static final String SENDING_FAULT = "SENDING_FAULT";
+    /** The message context property name which holds the error code for the last encountered exception */
+    public static final String ERROR_CODE = "ERROR_CODE";
+    /** The MC property name which holds the error message for the last encountered exception */
+    public static final String ERROR_MESSAGE = "ERROR_MESSAGE";
+    /** The message context property name which holds the error detail (stack trace) for the last encountered exception */
+    public static final String ERROR_DETAIL = "ERROR_DETAIL";
+    /** The message context property name which holds the exception (if any) for the last encountered exception */
+    public static final String ERROR_EXCEPTION = "ERROR_EXCEPTION";
+
+    // ********** DO NOT CHANGE THESE UNLESS CORRESPONDING SYNAPSE CONSTANT ARE CHANGED ************
+
+    public static final String REST_URL_POSTFIX = "REST_URL_POSTFIX";
+    public static final String SERVICE_PREFIX = "SERVICE_PREFIX";
+    public static final String NO_ENTITY_BODY = "NO_ENTITY_BODY";
+
+    protected static final String PASS_THROUGH_TRANSPORT_WORKER_POOL =
+            "PASS_THROUGH_TRANSPORT_WORKER_POOL";
+    protected static final String PASS_THROUGH_SOURCE_CONFIGURATION =
+            "PASS_THROUGH_SOURCE_CONFIGURATION";
+    protected static final String PASS_THROUGH_SOURCE_CONNECTION = "pass-through.Source-Connection";
+    protected static final String PASS_THROUGH_SOURCE_REQUEST = "pass-through.Source-Request";
+
+    protected static final String PASS_THROUGH_TARGET_CONNECTION = "pass-through.Target-Connection";
+    protected static final String PASS_THROUGH_TARGET_RESPONSE = "pass-through.Target-Response";
+
+    public static final String PASS_THROUGH_PIPE = "pass-through.pipe";
+
+    // used to define the default content type as a parameter in the axis2.xml
+    public static final String REQUEST_CONTENT_TYPE = "DEFAULT_REQUEST_CONTENT_TYPE";
+
+    // This is a workaround  for  axis2 RestUtils behaviour
+    public static final String REST_REQUEST_CONTENT_TYPE = "synapse.internal.rest.contentType";
+
+    public static final String MESSAGE_BUILDER_INVOKED = "message.builder.invoked";
+    
+    public static final String CLONE_PASS_THROUGH_PIPE_REQUEST = "clone_pass-through.pipe_connected";
+    
+    /**
+     * Name of the .mar file
+     */
+    public final static String SECURITY_MODULE_NAME = "rampart";
+    
+    public final static String REST_GET_DELETE_INVOKE ="rest_get_delete_invoke";
+    
+    public final static String PASS_THROUGH_MESSAGE_LENGTH ="PASS_THROUGH_MESSAGE_LENGTH";
+    
+	public static final String CONF_LOCATION = "conf.location";
+
+    public static final String LOCATION = "Location";
+    
+	public static final String BUFFERED_INPUT_STREAM = "bufferedInputStream";
+	
+	//JMX statistic calculation Constants
+	public static final String REQ_ARRIVAL_TIME = "REQ_ARRIVAL_TIME";
+	public static final String REQ_DEPARTURE_TIME = "REQ_DEPARTURE_TIME";
+	public static final String RES_ARRIVAL_TIME = "RES_ARRIVAL_TIME";
+	public static final String RES_HEADER_ARRIVAL_TIME = "RES_HEADER_ARRIVAL_TIME";
+	public static final String RES_DEPARTURE_TIME = "RES_DEPARTURE_TIME";
+
+	public static final String MESSAGE_OUTPUT_FORMAT = "MESSAGE_OUTPUT_FORMAT";
+	
+	public static final String FORCE_SOAP_FAULT = "FORCE_SOAP_FAULT";
+	
+	public static final String FORCE_PASS_THROUGH_BUILDER = "force.passthrough.builder";
+	
+	public static final String WSDL_GEN_HANDLED = "WSDL_GEN_HANDLED";
+
+	
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceContext.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceContext.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceContext.java	(revision 1502663)
@@ -0,0 +1,205 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.nio.NHttpConnection;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This class represents the information about a TCP Connection at a given point in time.
+ * In a Single TCP Connection there can be multiple HTTP Requests.
+ */
+public class SourceContext {
+    public static final String CONNECTION_INFORMATION = "CONNECTION_INFORMATION";
+
+    private SourceConfiguration sourceConfiguration;
+
+    private ProtocolState state = ProtocolState.REQUEST_READY;
+
+    private SourceRequest request;
+
+    private SourceResponse response;
+
+    /** Mark the connection to be shut down after the current request-response is completed. */
+    private boolean shutDown = false;
+
+    private Pipe reader;
+
+    private Pipe writer;
+
+    private Lock lock = new ReentrantLock();
+
+    public SourceContext(SourceConfiguration sourceConfiguration) {
+        this.sourceConfiguration = sourceConfiguration;
+    }
+
+    public ProtocolState getState() {
+        return state;
+    }
+
+    public void setState(ProtocolState state) {
+        this.state = state;
+    }
+
+    public SourceRequest getRequest() {
+        return request;
+    }
+
+    public void setRequest(SourceRequest request) {
+        this.request = request;
+    }
+
+    public SourceResponse getResponse() {
+        return response;
+    }
+
+    public void setResponse(SourceResponse response) {
+        this.response = response;
+    }
+
+    public void reset() {
+        this.request = null;
+        this.response = null;
+        this.state = ProtocolState.REQUEST_READY;
+
+        if (writer != null) {
+            ByteBuffer buffer = writer.getBuffer();
+            buffer.clear();
+            sourceConfiguration.getBufferFactory().release(buffer);
+        }
+
+        this.reader = null;
+        this.writer = null;
+    }
+
+    public Lock getLock() {
+        return lock;
+    }
+
+    public boolean isShutDown() {
+        return shutDown;
+    }
+
+    public void setShutDown(boolean shutDown) {
+        this.shutDown = shutDown;
+    }
+
+    public Pipe getReader() {
+        return reader;
+    }
+
+    public void setReader(Pipe reader) {
+        this.reader = reader;
+    }
+
+    public Pipe getWriter() {
+        return writer;
+    }
+
+    public void setWriter(Pipe writer) {
+        this.writer = writer;
+    }
+
+    public static void create(NHttpConnection conn, ProtocolState state,
+                              SourceConfiguration configuration) {
+        SourceContext info = new SourceContext(configuration);
+
+        conn.getContext().setAttribute(CONNECTION_INFORMATION, info);
+
+        info.setState(state);
+    }
+
+    public static void updateState(NHttpConnection conn, ProtocolState state) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setState(state);
+        }  else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static boolean assertState(NHttpConnection conn, ProtocolState state) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null && info.getState() == state;
+
+    }
+
+    public static ProtocolState getState(NHttpConnection conn) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getState() : null;
+    }
+
+    public static void setRequest(NHttpConnection conn, SourceRequest request) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setRequest(request);
+        } else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static void setResponse(NHttpConnection conn, SourceResponse response) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        if (info != null) {
+            info.setResponse(response);
+        } else {
+            throw new IllegalStateException("Connection information should be present");
+        }
+    }
+
+    public static SourceRequest getRequest(NHttpConnection conn) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getRequest() : null;
+    }
+
+    public static SourceResponse getResponse(NHttpConnection conn) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getResponse() : null;
+    }
+
+    public static SourceContext get(NHttpConnection conn) {
+        return (SourceContext) conn.getContext().getAttribute(CONNECTION_INFORMATION);
+    }
+
+    public static Lock getLock(NHttpConnection conn) {
+        SourceContext info = (SourceContext)
+                conn.getContext().getAttribute(CONNECTION_INFORMATION);
+
+        return info != null ? info.getLock() : null;
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java	(revision 1502663)
@@ -0,0 +1,248 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axis2.addressing.AddressingConstants;
+import org.apache.axis2.context.MessageContext;
+import org.apache.http.HttpStatus;
+import org.apache.http.protocol.HTTP;
+import org.apache.axis2.builder.BuilderUtil;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.Constants;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.axis2.description.WSDL2Constants;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.engine.AxisEngine;
+import org.apache.axiom.soap.*;
+import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.Comparator;
+
+public class ClientWorker implements Runnable {
+    private Log log = LogFactory.getLog(ClientWorker.class);
+    /** the Axis2 configuration context */
+    private ConfigurationContext cfgCtx = null;
+    /** the response message context that would be created */
+    private org.apache.axis2.context.MessageContext responseMsgCtx = null;
+    /** the HttpResponse received */
+    private TargetResponse response = null;
+    /** weather a body is expected or not */
+    private boolean expectEntityBody = true;
+
+    public ClientWorker(ConfigurationContext cfgCtx,
+                        MessageContext outMsgCtx,
+                        TargetResponse response) {
+        this.cfgCtx = cfgCtx;
+        this.response = response;
+        this.expectEntityBody = response.isExpectResponseBody();
+
+        Map<String,String> headers = response.getHeaders();
+      
+		String oriURL = headers.get(PassThroughConstants.LOCATION);
+		
+		// Special casing 302 scenario in following section. Not sure whether it's the correct fix,
+		// but this fix makes it possible to do http --> https redirection.
+		if (oriURL != null && response.getStatus() != HttpStatus.SC_MOVED_TEMPORARILY) {
+			URL url = null;
+			try {
+				url = new URL(oriURL);
+			} catch (MalformedURLException e) {
+				log.error("Invalid URL received",e);
+	            return;
+			}
+
+			headers.remove(PassThroughConstants.LOCATION);
+			String prfix =  (String) outMsgCtx.getProperty(PassThroughConstants.SERVICE_PREFIX);
+			if (prfix != null) {
+				headers.put(PassThroughConstants.LOCATION, prfix + url.getFile());
+			}
+
+		}
+        
+        try {
+            responseMsgCtx = outMsgCtx.getOperationContext().
+                getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);
+            // fix for RM to work because of a soapAction and wsaAction conflict
+            if (responseMsgCtx != null) {
+                responseMsgCtx.setSoapAction("");
+            }
+        } catch (AxisFault af) {
+            log.error("Error getting IN message context from the operation context", af);
+            return;
+        }
+
+        if (responseMsgCtx == null) {
+            if (outMsgCtx.getOperationContext().isComplete()) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Error getting IN message context from the operation context. " +
+                            "Possibly an RM terminate sequence message");
+                }
+                return;
+
+            }
+            responseMsgCtx = new MessageContext();
+            responseMsgCtx.setOperationContext(outMsgCtx.getOperationContext());
+        }
+
+        // copy the important properties from the original message context
+        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION,
+                outMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION));
+        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION,
+                outMsgCtx.getProperty(PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION));
+
+        responseMsgCtx.setServerSide(true);
+        responseMsgCtx.setDoingREST(outMsgCtx.isDoingREST());
+        responseMsgCtx.setProperty(MessageContext.TRANSPORT_IN, outMsgCtx
+                .getProperty(MessageContext.TRANSPORT_IN));
+        responseMsgCtx.setTransportIn(outMsgCtx.getTransportIn());
+        responseMsgCtx.setTransportOut(outMsgCtx.getTransportOut());
+
+        // set any transport headers received
+        Set<Map.Entry<String, String>> headerEntries = response.getHeaders().entrySet();
+        Map<String, String> headerMap = new TreeMap<String, String>(new Comparator<String>() {
+            public int compare(String o1, String o2) {
+                return o1.compareToIgnoreCase(o2);
+            }
+        });
+
+        for (Map.Entry<String, String> headerEntry : headerEntries) {
+            headerMap.put(headerEntry.getKey(), headerEntry.getValue());
+        }
+        responseMsgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
+
+        if (response.getStatus() == 202) {
+            responseMsgCtx.setProperty(AddressingConstants.
+                    DISABLE_ADDRESSING_FOR_OUT_MESSAGES, Boolean.TRUE);
+            responseMsgCtx.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);
+            responseMsgCtx.setProperty(NhttpConstants.SC_ACCEPTED, Boolean.TRUE);
+        }
+
+        responseMsgCtx.setAxisMessage(outMsgCtx.getOperationContext().getAxisOperation().
+                getMessage(WSDLConstants.MESSAGE_LABEL_IN_VALUE));
+        responseMsgCtx.setOperationContext(outMsgCtx.getOperationContext());
+        responseMsgCtx.setConfigurationContext(outMsgCtx.getConfigurationContext());
+        responseMsgCtx.setTo(null);
+
+        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, response.getPipe());
+        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TARGET_RESPONSE, response);
+        responseMsgCtx.setProperty(PassThroughConstants.PASS_THROUGH_TARGET_CONNECTION,
+                response.getConnection());
+    }
+
+    public void run() {
+        if (responseMsgCtx == null) {
+            return;
+        }
+       
+        try {
+            if (expectEntityBody) {
+                String cType = response.getHeader(HTTP.CONTENT_TYPE);
+                String contentType;
+                if (cType != null) {
+                    // This is the most common case - Most of the time servers send the Content-Type
+                    contentType = cType;
+                } else {
+                    // Server hasn't sent the header - Try to infer the content type
+                    contentType = inferContentType();
+                }
+
+                responseMsgCtx.setProperty(Constants.Configuration.CONTENT_TYPE, contentType);
+
+                String charSetEnc = BuilderUtil.getCharSetEncoding(contentType);
+                if (charSetEnc == null) {
+                    charSetEnc = MessageContext.DEFAULT_CHAR_SET_ENCODING;
+                }
+
+                responseMsgCtx.setProperty(
+                        Constants.Configuration.CHARACTER_SET_ENCODING,
+                        contentType.indexOf(HTTP.CHARSET_PARAM) > 0 ?
+                                charSetEnc : MessageContext.DEFAULT_CHAR_SET_ENCODING);
+                
+                responseMsgCtx.setServerSide(false);
+                SOAPFactory fac = OMAbstractFactory.getSOAP11Factory();
+                SOAPEnvelope envelope = fac.getDefaultEnvelope();
+                try {
+                    responseMsgCtx.setEnvelope(envelope);
+                } catch (AxisFault axisFault) {
+                    log.error("Error setting SOAP envelope", axisFault);
+                }
+
+                responseMsgCtx.setServerSide(true);
+            } else {
+                // there is no response entity-body
+                responseMsgCtx.setProperty(PassThroughConstants.NO_ENTITY_BODY, Boolean.TRUE);
+                responseMsgCtx.setEnvelope(new SOAP11Factory().getDefaultEnvelope());
+            }
+
+            // copy the HTTP status code as a message context property with the key HTTP_SC to be
+            // used at the sender to set the proper status code when passing the message
+            int statusCode = this.response.getStatus();
+            responseMsgCtx.setProperty(PassThroughConstants.HTTP_SC, statusCode);
+            if (statusCode >= 400) {
+                responseMsgCtx.setProperty(PassThroughConstants.FAULT_MESSAGE,
+                        PassThroughConstants.TRUE);
+            } /*else if (statusCode == 202 && responseMsgCtx.getOperationContext().isComplete()) {
+                // Handle out-only invocation scenario
+                responseMsgCtx.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);
+            }*/
+            responseMsgCtx.setProperty(PassThroughConstants.NON_BLOCKING_TRANSPORT, true);
+
+            // process response received
+            try {
+                AxisEngine.receive(responseMsgCtx);
+            } catch (AxisFault af) {
+                log.error("Fault processing response message through Axis2", af);
+            }
+
+        } catch (AxisFault af) {
+            log.error("Fault creating response SOAP envelope", af);            
+        } catch (IOException e) {
+            log.error("Error closing input stream from which message was read", e);
+        }
+    }
+
+    private String inferContentType() {
+        // Try to get the content type from the message context
+        Object cTypeProperty = responseMsgCtx.getProperty(PassThroughConstants.CONTENT_TYPE);
+        if (cTypeProperty != null) {
+            return cTypeProperty.toString();
+        }
+        // Try to get the content type from the axis configuration
+        Parameter cTypeParam = cfgCtx.getAxisConfiguration().getParameter(
+                PassThroughConstants.CONTENT_TYPE);
+        if (cTypeParam != null) {
+            return cTypeParam.getValue().toString();
+        }
+        // Unable to determine the content type - Return default value
+        return PassThroughConstants.DEFAULT_CONTENT_TYPE;
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HostnameVerifier.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HostnameVerifier.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/HostnameVerifier.java	(revision 1502663)
@@ -0,0 +1,577 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+
+/**
+ * ************************************************************************
+ * Copied from the not-yet-commons-ssl project at http://juliusdavies.ca/commons-ssl/
+ * As the above project is accepted into Apache and its JARs become available in
+ * the Maven 2 repos, we will have to switch to using the JARs instead
+ * ************************************************************************
+ * <p/>
+ * Interface for checking if a hostname matches the names stored inside the
+ * server's X.509 certificate.  Correctly implements
+ * javax.net.ssl.HostnameVerifier, but that interface is not recommended.
+ * Instead we added several check() methods that take SSLSocket,
+ * or X509Certificate, or ultimately (they all end up calling this one),
+ * String.  (It's easier to supply JUnit with Strings instead of mock
+ * SSLSession objects!)
+ * </p><p>Our check() methods throw exceptions if the name is
+ * invalid, whereas javax.net.ssl.HostnameVerifier just returns true/false.
+ * <p/>
+ * We provide the HostnameVerifier.DEFAULT, HostnameVerifier.STRICT, and
+ * HostnameVerifier.ALLOW_ALL implementations.  We also provide the more
+ * specialized HostnameVerifier.DEFAULT_AND_LOCALHOST, as well as
+ * HostnameVerifier.STRICT_IE6.  But feel free to define your own
+ * implementations!
+ * <p/>
+ * Inspired by Sebastian Hauer's original StrictSSLProtocolSocketFactory in the
+ * HttpClient "contrib" repository.
+ *
+ * @author Julius Davies
+ * @author <a href="mailto:hauer@psicode.com">Sebastian Hauer</a>
+ * @since 8-Dec-2006
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import javax.net.ssl.SSLException;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocket;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.cert.Certificate;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.util.*;
+
+public interface HostnameVerifier extends javax.net.ssl.HostnameVerifier {
+
+    boolean verify(String host, SSLSession session);
+
+    void check(String host, SSLSocket ssl) throws IOException;
+
+    void check(String host, X509Certificate cert) throws SSLException;
+
+    void check(String host, String[] cns, String[] subjectAlts)
+        throws SSLException;
+
+    void check(String[] hosts, SSLSocket ssl) throws IOException;
+
+    void check(String[] hosts, X509Certificate cert) throws SSLException;
+
+
+    /**
+     * Checks to see if the supplied hostname matches any of the supplied CNs
+     * or "DNS" Subject-Alts.  Most implementations only look at the first CN,
+     * and ignore any additional CNs.  Most implementations do look at all of
+     * the "DNS" Subject-Alts. The CNs or Subject-Alts may contain wildcards
+     * according to RFC 2818.
+     *
+     * @param cns         CN fields, in order, as extracted from the X.509
+     *                    certificate.
+     * @param subjectAlts Subject-Alt fields of type 2 ("DNS"), as extracted
+     *                    from the X.509 certificate.
+     * @param hosts       The array of hostnames to verify.
+     * @throws SSLException If verification failed.
+     */
+    void check(String[] hosts, String[] cns, String[] subjectAlts)
+        throws SSLException;
+
+
+    /**
+     * The DEFAULT HostnameVerifier works the same way as Curl and Firefox.
+     * <p/>
+     * The hostname must match either the first CN, or any of the subject-alts.
+     * A wildcard can occur in the CN, and in any of the subject-alts.
+     * <p/>
+     * The only difference between DEFAULT and STRICT is that a wildcard (such
+     * as "*.foo.com") with DEFAULT matches all subdomains, including
+     * "a.b.foo.com".
+     */
+    public final static HostnameVerifier DEFAULT =
+        new AbstractVerifier() {
+            public final void check(final String[] hosts, final String[] cns,
+                final String[] subjectAlts)
+                throws SSLException {
+                check(hosts, cns, subjectAlts, false, false);
+            }
+
+            public final String toString() {
+                return "DEFAULT";
+            }
+        };
+
+
+    /**
+     * The DEFAULT_AND_LOCALHOST HostnameVerifier works like the DEFAULT
+     * one with one additional relaxation:  a host of "localhost",
+     * "localhost.localdomain", "127.0.0.1", "::1" will always pass, no matter
+     * what is in the server's certificate.
+     */
+    public final static HostnameVerifier DEFAULT_AND_LOCALHOST =
+        new AbstractVerifier() {
+            public final void check(final String[] hosts, final String[] cns,
+                final String[] subjectAlts)
+                throws SSLException {
+                if (isLocalhost(hosts[0])) {
+                    return;
+                }
+                check(hosts, cns, subjectAlts, false, false);
+            }
+
+            public final String toString() {
+                return "DEFAULT_AND_LOCALHOST";
+            }
+        };
+
+    /**
+     * The STRICT HostnameVerifier works the same way as java.net.URL in Sun
+     * Java 1.4, Sun Java 5, Sun Java 6.  It's also pretty close to IE6.
+     * This implementation appears to be compliant with RFC 2818 for dealing
+     * with wildcards.
+     * <p/>
+     * The hostname must match either the first CN, or any of the subject-alts.
+     * A wildcard can occur in the CN, and in any of the subject-alts.  The
+     * one divergence from IE6 is how we only check the first CN.  IE6 allows
+     * a match against any of the CNs present.  We decided to follow in
+     * Sun Java 1.4's footsteps and only check the first CN.
+     * <p/>
+     * A wildcard such as "*.foo.com" matches only subdomains in the same
+     * level, for example "a.foo.com".  It does not match deeper subdomains
+     * such as "a.b.foo.com".
+     */
+    public final static HostnameVerifier STRICT =
+        new AbstractVerifier() {
+            public final void check(final String[] host, final String[] cns,
+                final String[] subjectAlts)
+                throws SSLException {
+                check(host, cns, subjectAlts, false, true);
+            }
+
+            public final String toString() {
+                return "STRICT";
+            }
+        };
+
+    /**
+     * The STRICT_IE6 HostnameVerifier works just like the STRICT one with one
+     * minor variation:  the hostname can match against any of the CN's in the
+     * server's certificate, not just the first one.  This behaviour is
+     * identical to IE6's behaviour.
+     */
+    public final static HostnameVerifier STRICT_IE6 =
+        new AbstractVerifier() {
+            public final void check(final String[] host, final String[] cns,
+                final String[] subjectAlts)
+                throws SSLException {
+                check(host, cns, subjectAlts, true, true);
+            }
+
+            public final String toString() {
+                return "STRICT_IE6";
+            }
+        };
+
+    /**
+     * The ALLOW_ALL HostnameVerifier essentially turns hostname verification
+     * off.  This implementation is a no-op, and never throws the SSLException.
+     */
+    public final static HostnameVerifier ALLOW_ALL =
+        new AbstractVerifier() {
+            public final void check(final String[] host, final String[] cns,
+                final String[] subjectAlts) {
+                // Allow everything - so never blowup.
+            }
+
+            public final String toString() {
+                return "ALLOW_ALL";
+            }
+        };
+
+    abstract class AbstractVerifier implements HostnameVerifier {
+
+        /**
+         * This contains a list of 2nd-level domains that aren't allowed to
+         * have wildcards when combined with country-codes.
+         * For example: [*.co.uk].
+         * <p/>
+         * The [*.co.uk] problem is an interesting one.  Should we just hope
+         * that CA's would never foolishly allow such a certificate to happen?
+         * Looks like we're the only implementation guarding against this.
+         * Firefox, Curl, Sun Java 1.4, 5, 6 don't bother with this check.
+         */
+        private final static String[] BAD_COUNTRY_2LDS =
+            {"ac", "co", "com", "ed", "edu", "go", "gouv", "gov", "info",
+                "lg", "ne", "net", "or", "org"};
+
+        private final static String[] LOCALHOSTS = {"::1", "127.0.0.1",
+            "localhost",
+            "localhost.localdomain"};
+
+
+        static {
+            // Just in case developer forgot to manually sort the array.  :-)
+            Arrays.sort(BAD_COUNTRY_2LDS);
+            Arrays.sort(LOCALHOSTS);
+        }
+
+        protected AbstractVerifier() {
+        }
+
+        /**
+         * The javax.net.ssl.HostnameVerifier contract.
+         *
+         * @param host    'hostname' we used to create our socket
+         * @param session SSLSession with the remote server
+         * @return true if the host matched the one in the certificate.
+         */
+        public boolean verify(String host, SSLSession session) {
+            try {
+                Certificate[] certs = session.getPeerCertificates();
+                X509Certificate x509 = (X509Certificate) certs[0];
+                check(new String[]{host}, x509);
+                return true;
+            }
+            catch (SSLException e) {
+                return false;
+            }
+        }
+
+        public void check(String host, SSLSocket ssl) throws IOException {
+            check(new String[]{host}, ssl);
+        }
+
+        public void check(String host, X509Certificate cert)
+            throws SSLException {
+            check(new String[]{host}, cert);
+        }
+
+        public void check(String host, String[] cns, String[] subjectAlts)
+            throws SSLException {
+            check(new String[]{host}, cns, subjectAlts);
+        }
+
+        public void check(String host[], SSLSocket ssl)
+            throws IOException {
+            if (host == null) {
+                throw new NullPointerException("host to verify is null");
+            }
+
+            SSLSession session = ssl.getSession();
+            if (session == null) {
+                // In our experience this only happens under IBM 1.4.x when
+                // spurious (unrelated) certificates show up in the server'
+                // chain.  Hopefully this will unearth the real problem:
+                InputStream in = ssl.getInputStream();
+                in.available();
+                /*
+                  If you're looking at the 2 lines of code above because
+                  you're running into a problem, you probably have two
+                  options:
+
+                    #1.  Clean up the certificate chain that your server
+                         is presenting (e.g. edit "/etc/apache2/server.crt"
+                         or wherever it is your server's certificate chain
+                         is defined).
+
+                                               OR
+
+                    #2.   Upgrade to an IBM 1.5.x or greater JVM, or switch
+                          to a non-IBM JVM.
+                */
+
+                // If ssl.getInputStream().available() didn't cause an
+                // exception, maybe at least now the session is available?
+                session = ssl.getSession();
+                if (session == null) {
+                    // If it's still null, probably a startHandshake() will
+                    // unearth the real problem.
+                    ssl.startHandshake();
+
+                    // Okay, if we still haven't managed to cause an exception,
+                    // might as well go for the NPE.  Or maybe we're okay now?
+                    session = ssl.getSession();
+                }
+            }
+            Certificate[] certs;
+            try {
+                certs = session.getPeerCertificates();
+            } catch (SSLPeerUnverifiedException spue) {
+                InputStream in = ssl.getInputStream();
+                in.available();
+                // Didn't trigger anything interesting?  Okay, just throw
+                // original.
+                throw spue;
+            }
+            X509Certificate x509 = (X509Certificate) certs[0];
+            check(host, x509);
+        }
+
+        public void check(String[] host, X509Certificate cert)
+            throws SSLException {
+
+            String[] cns = Certificates.getCNs(cert);
+            String[] subjectAlts = Certificates.getDNSSubjectAlts(cert);
+            check(host, cns, subjectAlts);
+
+        }
+
+        public void check(final String[] hosts, final String[] cns,
+            final String[] subjectAlts, final boolean ie6,
+            final boolean strictWithSubDomains)
+            throws SSLException {
+            // Build up lists of allowed hosts For logging/debugging purposes.
+            StringBuffer buf = new StringBuffer(32);
+            buf.append('<');
+            for (int i = 0; i < hosts.length; i++) {
+                String h = hosts[i];
+                h = h != null ? h.trim().toLowerCase() : "";
+                hosts[i] = h;
+                if (i > 0) {
+                    buf.append('/');
+                }
+                buf.append(h);
+            }
+            buf.append('>');
+            String hostnames = buf.toString();
+            // Build the list of names we're going to check.  Our DEFAULT and
+            // STRICT implementations of the HostnameVerifier only use the
+            // first CN provided.  All other CNs are ignored.
+            // (Firefox, wget, curl, Sun Java 1.4, 5, 6 all work this way).
+            TreeSet names = new TreeSet();
+            if (cns != null && cns.length > 0 && cns[0] != null) {
+                names.add(cns[0]);
+                if (ie6) {
+                    for (int i = 1; i < cns.length; i++) {
+                        names.add(cns[i]);
+                    }
+                }
+            }
+            if (subjectAlts != null) {
+                for (int i = 0; i < subjectAlts.length; i++) {
+                    if (subjectAlts[i] != null) {
+                        names.add(subjectAlts[i]);
+                    }
+                }
+            }
+            if (names.isEmpty()) {
+                String msg = "Certificate for " + hosts[0] + " doesn't contain CN or DNS subjectAlt";
+                throw new SSLException(msg);
+            }
+
+            // StringBuffer for building the error message.
+            buf = new StringBuffer();
+
+            boolean match = false;
+            out:
+            for (Iterator it = names.iterator(); it.hasNext();) {
+                // Don't trim the CN, though!
+                String cn = (String) it.next();
+                cn = cn.toLowerCase();
+                // Store CN in StringBuffer in case we need to report an error.
+                buf.append(" <");
+                buf.append(cn);
+                buf.append('>');
+                if (it.hasNext()) {
+                    buf.append(" OR");
+                }
+
+                // The CN better have at least two dots if it wants wildcard
+                // action.  It also can't be [*.co.uk] or [*.co.jp] or
+                // [*.org.uk], etc...
+                boolean doWildcard = cn.startsWith("*.") &&
+                    cn.lastIndexOf('.') >= 0 &&
+                    !isIP4Address(cn) &&
+                    acceptableCountryWildcard(cn);
+
+                for (int i = 0; i < hosts.length; i++) {
+                    final String hostName = hosts[i].trim().toLowerCase();
+                    if (doWildcard) {
+                        match = hostName.endsWith(cn.substring(1));
+                        if (match && strictWithSubDomains) {
+                            // If we're in strict mode, then [*.foo.com] is not
+                            // allowed to match [a.b.foo.com]
+                            match = countDots(hostName) == countDots(cn);
+                        }
+                    } else {
+                        match = hostName.equals(cn);
+                    }
+                    if (match) {
+                        break out;
+                    }
+                }
+            }
+            if (!match) {
+                throw new SSLException("hostname in certificate didn't match: " + hostnames + " !=" + buf);
+            }
+        }
+
+        public static boolean isIP4Address(final String cn) {
+            boolean isIP4 = true;
+            String tld = cn;
+            int x = cn.lastIndexOf('.');
+            // We only bother analyzing the characters after the final dot
+            // in the name.
+            if (x >= 0 && x + 1 < cn.length()) {
+                tld = cn.substring(x + 1);
+            }
+            for (int i = 0; i < tld.length(); i++) {
+                if (!Character.isDigit(tld.charAt(0))) {
+                    isIP4 = false;
+                    break;
+                }
+            }
+            return isIP4;
+        }
+
+        public static boolean acceptableCountryWildcard(final String cn) {
+            int cnLen = cn.length();
+            if (cnLen >= 7 && cnLen <= 9) {
+                // Look for the '.' in the 3rd-last position:
+                if (cn.charAt(cnLen - 3) == '.') {
+                    // Trim off the [*.] and the [.XX].
+                    String s = cn.substring(2, cnLen - 3);
+                    // And test against the sorted array of bad 2lds:
+                    int x = Arrays.binarySearch(BAD_COUNTRY_2LDS, s);
+                    return x < 0;
+                }
+            }
+            return true;
+        }
+
+        public static boolean isLocalhost(String host) {
+            host = host != null ? host.trim().toLowerCase() : "";
+            if (host.startsWith("::1")) {
+                int x = host.lastIndexOf('%');
+                if (x >= 0) {
+                    host = host.substring(0, x);
+                }
+            }
+            int x = Arrays.binarySearch(LOCALHOSTS, host);
+            return x >= 0;
+        }
+
+        /**
+         * Counts the number of dots "." in a string.
+         *
+         * @param s string to count dots from
+         * @return number of dots
+         */
+        public static int countDots(final String s) {
+            int count = 0;
+            for (int i = 0; i < s.length(); i++) {
+                if (s.charAt(i) == '.') {
+                    count++;
+                }
+            }
+            return count;
+        }
+    }
+
+    class Certificates {
+        public static String[] getCNs(X509Certificate cert) {
+            LinkedList cnList = new LinkedList();
+            /*
+           Sebastian Hauer's original StrictSSLProtocolSocketFactory used
+           getName() and had the following comment:
+
+              Parses a X.500 distinguished name for the value of the
+              "Common Name" field.  This is done a bit sloppy right
+              now and should probably be done a bit more according to
+              <code>RFC 2253</code>.
+
+            I've noticed that toString() seems to do a better job than
+            getName() on these X500Principal objects, so I'm hoping that
+            addresses Sebastian's concern.
+
+            For example, getName() gives me this:
+            1.2.840.113549.1.9.1=#16166a756c6975736461766965734063756362632e636f6d
+
+            whereas toString() gives me this:
+            EMAILADDRESS=juliusdavies@cucbc.com
+
+            Looks like toString() even works with non-ascii domain names!
+            I tested it with "&#x82b1;&#x5b50;.co.jp" and it worked fine.
+           */
+            String subjectPrincipal = cert.getSubjectX500Principal().toString();
+            StringTokenizer st = new StringTokenizer(subjectPrincipal, ",");
+            while (st.hasMoreTokens()) {
+                String tok = st.nextToken();
+                int x = tok.indexOf("CN=");
+                if (x >= 0) {
+                    cnList.add(tok.substring(x + 3));
+                }
+            }
+            if (!cnList.isEmpty()) {
+                String[] cns = new String[cnList.size()];
+                cnList.toArray(cns);
+                return cns;
+            } else {
+                return null;
+            }
+        }
+
+        /**
+         * Extracts the array of SubjectAlt DNS names from an X509Certificate.
+         * Returns null if there aren't any.
+         * <p/>
+         * Note:  Java doesn't appear able to extract international characters
+         * from the SubjectAlts.  It can only extract international characters
+         * from the CN field.
+         * <p/>
+         * (Or maybe the version of OpenSSL I'm using to test isn't storing the
+         * international characters correctly in the SubjectAlts?).
+         *
+         * @param cert X509Certificate
+         * @return Array of SubjectALT DNS names stored in the certificate.
+         */
+        public static String[] getDNSSubjectAlts(X509Certificate cert) {
+            LinkedList subjectAltList = new LinkedList();
+            Collection c = null;
+            try {
+                c = cert.getSubjectAlternativeNames();
+            }
+            catch (CertificateParsingException cpe) {
+                // Should probably log.debug() this?
+                cpe.printStackTrace();
+            }
+            if (c != null) {
+                Iterator it = c.iterator();
+                while (it.hasNext()) {
+                    List list = (List) it.next();
+                    int type = ((Integer) list.get(0)).intValue();
+                    // If type is 2, then we've got a dNSName
+                    if (type == 2) {
+                        String s = (String) list.get(1);
+                        subjectAltList.add(s);
+                    }
+                }
+            }
+            if (!subjectAltList.isEmpty()) {
+                String[] subjectAlts = new String[subjectAltList.size()];
+                subjectAltList.toArray(subjectAlts);
+                return subjectAlts;
+            } else {
+                return null;
+            }
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java	(revision 1502663)
@@ -0,0 +1,186 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.*;
+import org.apache.http.entity.BasicHttpEntity;
+import org.apache.http.impl.DefaultConnectionReuseStrategy;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.params.DefaultedHttpParams;
+import org.apache.http.protocol.ExecutionContext;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class SourceResponse {
+    private Pipe pipe = null;
+    /** Transport headers */
+    private Map<String, String> headers = new HashMap<String, String>();
+    /** Status of the response */
+    private int status = HttpStatus.SC_OK;
+    /** Status line */
+    private String statusLine = null;
+    /** Actual response submitted */
+    private HttpResponse response = null;
+    /** Configuration of the receiver */
+    private SourceConfiguration sourceConfiguration;
+    /** Version of the response */
+    private ProtocolVersion version = HttpVersion.HTTP_1_1;
+    /** Connection strategy */
+    private ConnectionReuseStrategy connStrategy = new DefaultConnectionReuseStrategy();
+    /** Chunk response or not */
+    // private boolean chunk = true;
+
+    private SourceRequest request = null;
+
+    public SourceResponse(SourceConfiguration config, int status, SourceRequest request) {
+        this(config, status, null, request);
+    }
+
+    public SourceResponse(SourceConfiguration config, int status, String statusLine,
+                          SourceRequest request) {
+        this.status = status;
+        this.statusLine = statusLine;
+        this.sourceConfiguration = config;
+        this.request = request;
+    }
+
+    public void connect(Pipe pipe) {
+        this.pipe = pipe;
+
+        if (request != null && pipe != null) {
+            SourceContext.get(request.getConnection()).setWriter(pipe);
+        }
+    }
+
+    /**
+     * Starts the response by writing the headers
+     * @param conn connection
+     * @throws java.io.IOException if an error occurs
+     * @throws org.apache.http.HttpException if an error occurs
+     */
+    public void start(NHttpServerConnection conn) throws IOException, HttpException {
+        // create the response
+        response = sourceConfiguration.getResponseFactory().newHttpResponse(
+                request.getVersion(), HttpStatus.SC_OK,
+                request.getConnection().getContext());
+
+        if (statusLine != null) {
+            response.setStatusLine(version, status, statusLine);
+        } else {
+            response.setStatusCode(status);
+        }
+
+        BasicHttpEntity entity = new BasicHttpEntity();
+
+        int contentLength = -1;
+        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);
+        if (contentLengthHeader != null) {
+            contentLength = Integer.parseInt(contentLengthHeader);
+
+            headers.remove(HTTP.CONTENT_LEN);
+        }
+
+        if (contentLength != -1) {
+            entity.setChunked(false);
+            entity.setContentLength(contentLength);
+        } else {
+            entity.setChunked(true);
+        }
+
+        response.setEntity(entity);
+
+        // set any transport headers
+        Set<Map.Entry<String, String>> entries = headers.entrySet();
+
+        for (Map.Entry<String, String> entry : entries) {
+            if (entry.getKey() != null) {
+                response.addHeader(entry.getKey(), entry.getValue());
+            }
+        }
+
+        response.setParams(new DefaultedHttpParams(response.getParams(),
+                sourceConfiguration.getHttpParameters()));
+
+        SourceContext.updateState(conn, ProtocolState.RESPONSE_HEAD);
+
+        // Pre-process HTTP response
+        conn.getContext().setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
+        conn.getContext().setAttribute(ExecutionContext.HTTP_RESPONSE, response);
+        conn.getContext().setAttribute(ExecutionContext.HTTP_REQUEST,
+                SourceContext.getRequest(conn).getRequest());
+        
+        sourceConfiguration.getHttpProcessor().process(response, conn.getContext());
+        conn.submitResponse(response);        
+    }
+
+    /**
+     * Consume the content through the Pipe and write them to the wire
+     * @param conn connection
+     * @param encoder encoder
+     * @throws java.io.IOException if an error occurs
+     * @return number of bytes written
+     */
+    public int write(NHttpServerConnection conn, ContentEncoder encoder) throws IOException {        
+        int bytes = 0;
+        if (pipe != null) {
+            bytes = pipe.consume(encoder);
+        } else {
+            encoder.complete();
+        }
+        // Update connection state
+        if (encoder.isCompleted()) {
+            SourceContext.updateState(conn, ProtocolState.RESPONSE_DONE);
+
+            sourceConfiguration.getMetrics().
+                    notifySentMessageSize(conn.getMetrics().getSentBytesCount());
+
+            if (!this.connStrategy.keepAlive(response, conn.getContext())) {
+                SourceContext.updateState(conn, ProtocolState.CLOSING);
+
+                sourceConfiguration.getSourceConnections().closeConnection(conn);
+            } else if (SourceContext.get(conn).isShutDown()) {
+                // we need to shut down if the shutdown flag is set
+                SourceContext.updateState(conn, ProtocolState.CLOSING);
+
+                sourceConfiguration.getSourceConnections().closeConnection(conn);
+            } else {
+                // Reset connection state
+                sourceConfiguration.getSourceConnections().releaseConnection(conn);
+                // Ready to deal with a new request                
+                conn.requestInput();
+            }
+        }
+        return bytes;
+    }
+
+    public void addHeader(String name, String value) {
+        headers.put(name, value);
+    }
+
+    public void setStatus(int status) {
+        this.status = status;
+    }        
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/Pipe.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/Pipe.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/Pipe.java	(revision 1502663)
@@ -0,0 +1,493 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.nio.IOControl;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.synapse.transport.passthru.config.BaseConfiguration;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * This is a buffer shared by both producers and consumers.
+ */
+public class Pipe {
+
+    /** IOControl of the reader */
+    private IOControl producerIoControl;
+
+    /** IOControl of the consumer */
+    private IOControl consumerIoControl;
+
+    /** Fixed size buffer to read and write data */
+    private ByteBuffer buffer;
+
+    private ByteBuffer outputBuffer;
+
+    private boolean producerCompleted = false;
+
+    public boolean isProducerCompleted() {
+		return producerCompleted;
+	}
+
+	/** Lock to synchronize the producers and consumers */
+    private Lock lock = new ReentrantLock();
+
+    private Condition readCondition = lock.newCondition();
+    private Condition writeCondition = lock.newCondition();
+
+    /** Name to identify the buffer */
+    private String name = "Buffer";
+
+    private boolean consumerError = false;
+
+    private boolean producerError = false;
+
+    private BaseConfiguration baseConfig;
+
+    private boolean serializationComplete = false;
+    
+    private boolean rawSerializationComplete = false;
+
+  	private boolean hasHttpProducer = true;
+
+    private AtomicBoolean inBufferInputMode = new AtomicBoolean(true);
+    private AtomicBoolean outBufferInputMode;
+
+    private ByteBufferInputStream inputStream;
+    private ByteBufferOutputStream outputStream;
+
+    public Pipe(IOControl producerIoControl, ByteBuffer buffer,
+                String name, BaseConfiguration baseConfig) {
+        this.producerIoControl = producerIoControl;
+        this.buffer = buffer;
+        this.name += "_" + name;
+        this.baseConfig = baseConfig;
+    }
+
+    public Pipe(ByteBuffer buffer, String name, BaseConfiguration baseConfig) {
+        this.buffer = buffer;
+        this.name += "_" + name;
+        this.baseConfig = baseConfig;
+        this.hasHttpProducer = false;
+    }
+
+    /**
+     * Set the consumers IOControl
+     * @param consumerIoControl IOControl of the consumer
+     */
+    public void attachConsumer(IOControl consumerIoControl) {
+        this.consumerIoControl = consumerIoControl;
+    }
+
+    /**
+     * Consume the data from the buffer. Before calling this method attachConsumer
+     * method must be called with a valid IOControl.
+     *
+     * @param encoder encoder used to write the data means there will not be any data
+     * written in to this buffer
+     * @return number of bytes written (consumed)
+     * @throws IOException if an error occurred while consuming data
+     */
+    public int consume(final ContentEncoder encoder) throws IOException {
+        if (consumerIoControl == null) {
+            throw new IllegalStateException("Consumer cannot be null when calling consume");
+        }
+
+        if (hasHttpProducer && producerIoControl == null) {
+            throw new IllegalStateException("Producer cannot be null when calling consume");
+        }
+
+        lock.lock();
+        ByteBuffer consumerBuffer;
+        AtomicBoolean inputMode;
+        if (outputBuffer != null) {
+            consumerBuffer = outputBuffer;
+            inputMode = outBufferInputMode;
+        } else {
+            consumerBuffer = buffer;
+            inputMode = inBufferInputMode;
+        }
+        try {
+            // if producer at error we have to stop the encoding and return immediately
+            if (producerError) {
+                encoder.complete();
+                return -1;
+            }
+
+            setOutputMode(consumerBuffer, inputMode);
+            int bytesWritten = encoder.write(consumerBuffer);
+            setInputMode(consumerBuffer, inputMode);
+
+            if (consumerBuffer.position() == 0) {
+                if (outputBuffer == null) {
+                    if (producerCompleted) {
+                        encoder.complete();
+                    } else {
+                        // buffer is empty. Wait until the producer fills up
+                        // the buffer
+                        consumerIoControl.suspendOutput();
+                    }
+                } else if (serializationComplete || rawSerializationComplete) {
+                    encoder.complete();
+                }
+            }
+
+            if (bytesWritten > 0) {
+                if (!encoder.isCompleted() && !producerCompleted && hasHttpProducer) {
+                    producerIoControl.requestInput();
+                }
+                writeCondition.signalAll();
+            }
+
+            return bytesWritten;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Produce data in to the buffer.
+     *
+     * @param decoder decoder to read bytes from the underlying stream
+     * @return bytes read (consumed)
+     * @throws IOException if an error occurs while reading data
+     */
+    public int produce(final ContentDecoder decoder) throws IOException {
+        if (producerIoControl == null) {
+            throw new IllegalStateException("Producer cannot be null when calling produce");
+        }
+
+        lock.lock();
+        try {
+            setInputMode(buffer, inBufferInputMode);
+            int bytesRead = decoder.read(buffer);
+
+            // if consumer is at error we have to let the producer complete
+            if (consumerError) {
+                buffer.clear();
+            }
+
+            if (!buffer.hasRemaining()) {
+                // Input buffer is full. Suspend client input
+                // until the origin handler frees up some space in the buffer
+                producerIoControl.suspendInput();
+            }
+
+            // If there is some content in the input buffer make sure consumer output is active
+            if (buffer.position() > 0 || decoder.isCompleted()) {
+                if (consumerIoControl != null) {
+                    consumerIoControl.requestOutput();
+                }
+                readCondition.signalAll();
+            }
+
+            if (decoder.isCompleted()) {
+                producerCompleted = true;
+            }
+           return bytesRead;
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public void consumerError() {
+        lock.lock();
+        try {
+            this.consumerError = true;
+            writeCondition.signalAll();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    public void producerError() {
+        lock.lock();
+        try {
+            this.producerError = true;
+            readCondition.signalAll();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    /**
+     * Creates an InputStream object on the underlying ByteBuffer. The returned
+     * InputStream can be used to read bytes from the underlying buffer which
+     * is being filled by the producer.
+     *
+     * @return An InputStream object
+     */
+    public synchronized InputStream getInputStream() {
+        if (inputStream == null) {
+            inputStream = new ByteBufferInputStream();
+        }
+        return inputStream;
+    }
+
+    /**
+     * Creates a separate ByteBuffer for the output data and returns an OutputStream
+     * on top of it.
+     *
+     * @return An OutputStream object
+     */
+    public synchronized OutputStream getOutputStream() {
+        if (outputStream == null) {
+            outputBuffer = baseConfig.getBufferFactory().getBuffer();
+            outBufferInputMode = new AtomicBoolean(true);
+            outputStream = new ByteBufferOutputStream();
+        }
+        return outputStream;
+    }
+    
+    
+    /**
+     * Creates a separate ByteBuffer for the output data and returns an OutputStream
+     * on top of it.
+     *
+     * @return An OutputStream object
+     */
+    public synchronized OutputStream resetOutputStream() {
+    	outputBuffer = baseConfig.getBufferFactory().getBuffer();
+        outBufferInputMode = new AtomicBoolean(true);
+        outputStream = new ByteBufferOutputStream();
+        return outputStream;
+    }
+    
+    
+    public synchronized void resetBufferPossition() {
+    	if(buffer != null){
+    		buffer.rewind();
+    	}
+    	
+    	if(outputBuffer != null){
+    		outputBuffer.rewind();
+    	}
+    }
+
+    public synchronized void setSerializationComplete(boolean serializationComplete) {
+        if (!this.serializationComplete) {
+            this.serializationComplete = serializationComplete;
+            if (consumerIoControl != null && hasData(outputBuffer, outBufferInputMode)) {
+                consumerIoControl.requestOutput();
+            }
+        }
+    }
+    
+    public synchronized void setSerializationCompleteWithoutData(boolean serializationComplete) {
+        if (!this.serializationComplete) {
+            this.serializationComplete = serializationComplete;
+            consumerIoControl.requestOutput();
+        }
+    }
+    
+    public void setRawSerializationComplete(boolean rawSerializationComplete) {
+    	this.rawSerializationComplete = rawSerializationComplete;
+    }
+    
+    public void forceSetSerializationRest(){
+    	if(this.serializationComplete){
+    		this.serializationComplete = false;
+    	}
+    }
+
+    
+    
+
+    public boolean isSerializationComplete() {
+		return serializationComplete;
+	}
+
+	public ByteBuffer getBuffer() {
+        return buffer;
+    }
+
+    public boolean hasHttpProducer() {
+        return hasHttpProducer;
+    }
+
+    private void setInputMode(ByteBuffer buffer, AtomicBoolean inputMode) {
+        if (inputMode.compareAndSet(false, true)) {
+            if (buffer.hasRemaining()) {
+                buffer.compact();
+            } else {
+                buffer.clear();
+            }
+        }
+    }
+
+    private void setOutputMode(ByteBuffer buffer, AtomicBoolean inputMode) {
+        if (inputMode.compareAndSet(true, false)) {
+            buffer.flip();
+        }
+    }
+
+    private boolean hasData(ByteBuffer buffer, AtomicBoolean inputMode) {
+        lock.lock();
+        try {
+            setOutputMode(buffer, inputMode);
+            return buffer.hasRemaining();
+        } finally {
+            lock.unlock();
+        }
+    }
+
+    private class ByteBufferInputStream extends InputStream {
+
+        @Override
+        public int read() throws IOException {
+            lock.lock();
+            try {
+                if (!hasData(buffer, inBufferInputMode)) {
+                    waitForData();
+                }
+                if (isEndOfStream()) {
+                    return -1;
+                }
+                return buffer.get() & 0xff;
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        public int read(byte[] b, int off, int len) throws IOException {
+            if (b == null) {
+                return 0;
+            }
+
+            lock.lock();
+            try {
+                if (!hasData(buffer, inBufferInputMode)) {
+                    waitForData();
+                }
+                if (isEndOfStream()) {
+                    return -1;
+                }
+                setOutputMode(buffer, inBufferInputMode);
+                int chunk = len;
+                if (chunk > buffer.remaining()) {
+                    chunk = buffer.remaining();
+                }
+                buffer.get(b, off, chunk);
+                return chunk;
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        private void waitForData() throws IOException {
+            lock.lock();
+            try {
+                try {
+                    while (!hasData(buffer, inBufferInputMode) && !producerCompleted) {
+                        producerIoControl.requestInput();
+                        readCondition.await();
+                    }
+                } catch (InterruptedException e) {
+                    throw new IOException("Interrupted while waiting for data");
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        private boolean isEndOfStream() {
+            return !hasData(buffer, inBufferInputMode) && producerCompleted;
+        }
+    }
+
+    private class ByteBufferOutputStream extends OutputStream {
+
+        @Override
+        public void write(int b) throws IOException {
+            lock.lock();
+            try {
+                setInputMode(outputBuffer, outBufferInputMode);
+                if (!outputBuffer.hasRemaining()) {
+                    flushContent();
+                    setInputMode(outputBuffer, outBufferInputMode);
+                }
+                outputBuffer.put((byte) b);
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        public void write(final byte[] b, int off, int len) throws IOException {
+            if (b == null) {
+                return;
+            }
+            lock.lock();
+            try {
+                setInputMode(outputBuffer, outBufferInputMode);
+                int remaining = len;
+                while (remaining > 0) {
+                    if (!outputBuffer.hasRemaining()) {
+                        flushContent();
+                        setInputMode(outputBuffer, outBufferInputMode);
+                    }
+                    int chunk = Math.min(remaining, outputBuffer.remaining());
+                    outputBuffer.put(b, off, chunk);
+                    remaining -= chunk;
+                    off += chunk;
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
+
+        private void flushContent() throws IOException {
+            lock.lock();
+           
+            if(rawSerializationComplete){
+            	return;
+            }
+            
+            try {
+                try {
+					while (hasData(outputBuffer, outBufferInputMode)) {
+						if (consumerIoControl != null && writeCondition != null) {
+							consumerIoControl.requestOutput();
+							writeCondition.await();
+						}
+					}
+                     	
+                } catch (InterruptedException ex) {
+                    throw new IOException("Interrupted while flushing the content buffer");
+                }
+            } finally {
+                lock.unlock();
+            }
+        }
+    }
+
+}
+
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSSLListener.java	(revision 1502663)
@@ -0,0 +1,173 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.description.Parameter;
+import org.apache.axis2.description.TransportInDescription;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.impl.nio.SSLServerIOEventDispatch;
+import org.apache.http.impl.nio.reactor.SSLIOSessionHandler;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.reactor.IOEventDispatch;
+import org.apache.http.params.HttpParams;
+
+import javax.net.ssl.*;
+import javax.xml.namespace.QName;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.net.SocketAddress;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+
+public class PassThroughHttpSSLListener extends PassThroughHttpListener {
+    
+    private Log log = LogFactory.getLog(PassThroughHttpSSLListener.class);
+
+    protected IOEventDispatch getEventDispatch(
+        NHttpServiceHandler handler, SSLContext sslContext,
+        SSLIOSessionHandler sslIOSessionHandler, HttpParams params) {
+        return new SSLServerIOEventDispatch(handler, sslContext, sslIOSessionHandler, params);
+    }
+
+    /**
+     * Create the SSLContext to be used by this listener
+     * @param transportIn the Axis2 transport description
+     * @return the SSLContext to be used
+     * @throws org.apache.axis2.AxisFault if an error occurs
+     */
+    protected SSLContext getSSLContext(TransportInDescription transportIn) throws AxisFault {
+
+        KeyManager[] keymanagers  = null;
+        TrustManager[] trustManagers = null;
+
+        Parameter keyParam    = transportIn.getParameter("keystore");
+        Parameter trustParam  = transportIn.getParameter("truststore");
+
+        if (keyParam != null) {
+            OMElement ksEle      = keyParam.getParameterElement().getFirstElement();
+            String location      = ksEle.getFirstChildWithName(new QName("Location")).getText();
+            String type          = ksEle.getFirstChildWithName(new QName("Type")).getText();
+            String storePassword = ksEle.getFirstChildWithName(new QName("Password")).getText();
+            String keyPassword   = ksEle.getFirstChildWithName(new QName("KeyPassword")).getText();
+
+            FileInputStream fis = null;
+            try {
+                KeyStore keyStore = KeyStore.getInstance(type);
+                fis = new FileInputStream(location);
+                log.info("Loading Identity Keystore from : " + location);
+
+                keyStore.load(fis, storePassword.toCharArray());
+                KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
+                    KeyManagerFactory.getDefaultAlgorithm());
+                kmfactory.init(keyStore, keyPassword.toCharArray());
+                keymanagers = kmfactory.getKeyManagers();
+
+            } catch (GeneralSecurityException gse) {
+                log.error("Error loading Key store : " + location, gse);
+                throw new AxisFault("Error loading Key store : " + location, gse);
+            } catch (IOException ioe) {
+                log.error("Error opening Key store : " + location, ioe);
+                throw new AxisFault("Error opening Key store : " + location, ioe);
+            } finally {
+                if (fis != null) {
+                    try {
+                        fis.close();
+                    } catch (IOException ignore) {}
+                }
+            }
+        }
+
+        if (trustParam != null) {
+            OMElement tsEle      = trustParam.getParameterElement().getFirstElement();
+            String location      = tsEle.getFirstChildWithName(new QName("Location")).getText();
+            String type          = tsEle.getFirstChildWithName(new QName("Type")).getText();
+            String storePassword = tsEle.getFirstChildWithName(new QName("Password")).getText();
+
+            FileInputStream fis = null;
+            try {
+                KeyStore trustStore = KeyStore.getInstance(type);
+                fis = new FileInputStream(location);
+                log.info("Loading Trust Keystore from : " + location);
+
+                trustStore.load(fis, storePassword.toCharArray());
+                TrustManagerFactory trustManagerfactory = TrustManagerFactory.getInstance(
+                    TrustManagerFactory.getDefaultAlgorithm());
+                trustManagerfactory.init(trustStore);
+                trustManagers = trustManagerfactory.getTrustManagers();
+
+            } catch (GeneralSecurityException gse) {
+                log.error("Error loading Key store : " + location, gse);
+                throw new AxisFault("Error loading Key store : " + location, gse);
+            } catch (IOException ioe) {
+                log.error("Error opening Key store : " + location, ioe);
+                throw new AxisFault("Error opening Key store : " + location, ioe);
+            } finally {
+                if (fis != null) {
+                    try {
+                        fis.close();
+                    } catch (IOException ignore) {}
+                }
+            }
+        }
+
+        try {
+            SSLContext sslcontext = SSLContext.getInstance("TLS");
+            sslcontext.init(keymanagers, trustManagers, null);
+            return sslcontext;
+
+        } catch (GeneralSecurityException gse) {
+            log.error("Unable to create SSL context with the given configuration", gse);
+            throw new AxisFault("Unable to create SSL context with the given configuration", gse);
+        }
+    }
+
+    /**
+     * Create the SSLIOSessionHandler to initialize the SSL session / engine, and request for
+     * client authentication at the following levels, through an Axis2 transport configuration
+     * parameter as follows:
+     * SSLVerifyClient - none, optional, require
+     *
+     * @param transportIn the Axis2 transport configuration
+     * @return the SSLIOSessionHandler to be used
+     * @throws AxisFault if a configuration error occurs
+     */
+    protected SSLIOSessionHandler getSSLIOSessionHandler(TransportInDescription transportIn) throws AxisFault {
+
+        final Parameter clientAuth = transportIn.getParameter("SSLVerifyClient");
+
+        return new SSLIOSessionHandler() {
+
+            public void initalize(SSLEngine sslengine, HttpParams params) {
+                if (clientAuth != null) {
+                    if ("optional".equals(clientAuth.getValue())) {
+                        sslengine.setWantClientAuth(true);
+                    } else if ("require".equals(clientAuth.getValue())) {
+                        sslengine.setNeedClientAuth(true);
+                    }
+                }
+            }
+
+            public void verify(SocketAddress removeAddress, SSLSession session)
+                throws SSLException {}
+        };
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ProtocolState.java	(revision 1502663)
@@ -0,0 +1,48 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+
+package org.apache.synapse.transport.passthru;
+
+/**
+ * State of a request or a response in transport receiver or sender
+ * is represented in these values.
+ */
+public enum ProtocolState {
+    /** Connection is at the initial stage ready to receive a request */
+    REQUEST_READY,
+    /** The connection is reading the request headers */
+    REQUEST_HEAD,
+    /** The connection is reading the request body */
+    REQUEST_BODY,
+    /** Request is completely received */
+    REQUEST_DONE,
+    /** The connection is reading the response headers */
+    RESPONSE_HEAD,
+    /** The connection si reading the response body */
+    RESPONSE_BODY,
+    /** The response is completed */
+    RESPONSE_DONE,
+    /** The connection is closing */
+    CLOSING,
+    /** The connection is closed */
+    CLOSED,
+    
+    WSDL_RESPONSE_DONE
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingUtils.java	(revision 1502663)
@@ -0,0 +1,113 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.NHttpClientIOTarget;
+import org.apache.http.nio.NHttpServerIOTarget;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.HttpResponseFactory;
+import org.apache.http.HttpRequestFactory;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.impl.nio.DefaultNHttpServerConnection;
+import org.apache.http.params.HttpParams;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+
+public class LoggingUtils {
+    public final static String HEADER_LOG_ID = "org.wso2.carbon.transport.passthru.headers";
+    public final static String WIRE_LOG_ID = "org.wso2.carbon.transport.passthru.wire";
+
+    public static IOSession decorate(IOSession session, final String id) {
+        Log log = LogFactory.getLog(session.getClass());
+        Log wirelog = LogFactory.getLog(WIRE_LOG_ID);
+        if (wirelog.isDebugEnabled() || log.isDebugEnabled()) {
+            session = new LoggingIOSession(wirelog, session, id);
+        }
+        return session;
+    }
+
+    public static NHttpClientHandler decorate(NHttpClientHandler handler) {
+        Log log = LogFactory.getLog(handler.getClass());
+        if (log.isDebugEnabled()) {
+            handler = new LoggingTargetHandler(handler);
+        }
+        return handler;
+    }
+
+    public static NHttpServiceHandler decorate(NHttpServiceHandler handler) {
+        Log log = LogFactory.getLog(handler.getClass());
+        if (log.isDebugEnabled()) {
+            handler = new LoggingSourceHandler(handler);
+        }
+        return handler;
+    }
+
+    public static NHttpClientIOTarget createClientConnection(
+            final IOSession iosession,
+            final HttpResponseFactory responseFactory,
+            final ByteBufferAllocator allocator,
+            final HttpParams params) {
+        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);
+        Log headerlog = LogFactory.getLog(HEADER_LOG_ID);
+        if (headerlog.isDebugEnabled() || log.isDebugEnabled()) {
+            return new LoggingNHttpTargetConnection(
+                    log,
+                    headerlog,
+                    iosession,
+                    responseFactory,
+                    allocator,
+                    params);
+        } else {
+            return new DefaultNHttpClientConnection(
+                    iosession,
+                    responseFactory,
+                    allocator,
+                    params);
+        }
+    }
+
+    public static NHttpServerIOTarget createServerConnection(
+            final IOSession iosession,
+            final HttpRequestFactory requestFactory,
+            final ByteBufferAllocator allocator,
+            final HttpParams params) {
+        Log log = LogFactory.getLog(DefaultNHttpClientConnection.class);
+        Log headerlog = LogFactory.getLog(HEADER_LOG_ID);
+        if (headerlog.isDebugEnabled() || log.isDebugEnabled()) {
+            return new LoggingNHttpSourceConnection(
+                    log,
+                    headerlog,
+                    iosession,
+                    requestFactory,
+                    allocator,
+                    params);
+        } else {
+            return new DefaultNHttpServerConnection(
+                    iosession,
+                    requestFactory,
+                    allocator,
+                    params);
+        }
+    }
+
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughHttpSender.java	(revision 1502663)
@@ -0,0 +1,506 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import javax.net.ssl.SSLContext;
+
+import org.apache.axiom.om.OMOutputFormat;
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.addressing.AddressingConstants;
+import org.apache.axis2.addressing.AddressingHelper;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.description.TransportOutDescription;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.transport.MessageFormatter;
+import org.apache.axis2.transport.OutTransportInfo;
+import org.apache.axis2.transport.TransportSender;
+import org.apache.axis2.transport.base.BaseConstants;
+import org.apache.axis2.transport.base.threads.NativeThreadFactory;
+import org.apache.axis2.transport.base.threads.WorkerPool;
+import org.apache.axis2.util.MessageProcessorSelector;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.HttpException;
+import org.apache.http.HttpStatus;
+import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
+import org.apache.http.impl.nio.reactor.SSLSetupHandler;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.nio.reactor.IOEventDispatch;
+import org.apache.http.nio.reactor.IOReactorException;
+import org.apache.http.nio.reactor.IOReactorExceptionHandler;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
+import org.apache.synapse.transport.nhttp.util.NhttpUtil;
+import org.apache.synapse.transport.passthru.config.SourceConfiguration;
+import org.apache.synapse.transport.passthru.config.TargetConfiguration;
+import org.apache.synapse.transport.passthru.connections.TargetConnections;
+import org.apache.synapse.transport.passthru.jmx.MBeanRegistrar;
+import org.apache.synapse.transport.passthru.jmx.PassThroughTransportMetricsCollector;
+import org.apache.synapse.transport.passthru.jmx.TransportView;
+import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;
+import org.apache.synapse.transport.passthru.util.SourceResponseFactory;
+
+/**
+ * PassThroughHttpSender for Synapse based on HttpCore and NIO extensions
+ */
+public class PassThroughHttpSender extends AbstractHandler implements TransportSender {
+
+    protected Log log;
+
+    /** IOReactor used to create connections and manage them */
+    private DefaultConnectingIOReactor ioReactor;
+
+    /** Delivery agent used for delivering the messages to the servers */
+    private DeliveryAgent deliveryAgent;
+
+    /** The configuration of the sender */
+    private TargetConfiguration targetConfiguration;
+
+    /** state of the sender */
+    private volatile int state = BaseConstants.STOPPED;
+
+    private String namePrefix;
+
+    public PassThroughHttpSender() {
+        log = LogFactory.getLog(this.getClass().getName());
+    }
+
+    public void init(ConfigurationContext configurationContext,
+                     TransportOutDescription transportOutDescription) throws AxisFault {
+        log.info("Initializing Pass-through HTTP/S Sender...");
+
+        // is this an SSL Sender?
+        SSLContext sslContext = getSSLContext(transportOutDescription);
+        SSLSetupHandler sslSetupHandler = getSSLSetupHandler(transportOutDescription);
+        namePrefix = (sslContext == null) ? "HTTP" : "HTTPS";
+
+        WorkerPool workerPool = null;
+        Object obj = configurationContext.getProperty(
+                PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL);
+        if (obj != null) {
+            workerPool = (WorkerPool) obj;                                   
+        }
+
+        targetConfiguration = new TargetConfiguration(configurationContext,
+                transportOutDescription, workerPool);
+        targetConfiguration.build();
+        configurationContext.setProperty(PassThroughConstants.PASS_THROUGH_TRANSPORT_WORKER_POOL,
+                targetConfiguration.getWorkerPool());
+
+        PassThroughTransportMetricsCollector metrics = new
+                PassThroughTransportMetricsCollector(false, sslContext != null);
+        TransportView view = new TransportView(null, this, metrics, null);
+        MBeanRegistrar.getInstance().registerMBean(view, "Transport",
+                 "passthru-" + namePrefix.toLowerCase() + "-sender");
+        targetConfiguration.setMetrics(metrics);
+
+        try {
+            String prefix = namePrefix + "-Sender I/O dispatcher";
+
+            ioReactor = new DefaultConnectingIOReactor(
+                            targetConfiguration.getIOThreadsPerReactor(),
+                            new NativeThreadFactory(new ThreadGroup(prefix + " Thread Group"), prefix),
+                            targetConfiguration.getHttpParameters());
+
+            ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {
+
+                public boolean handle(IOException ioException) {
+                    log.warn("System may be unstable: " + namePrefix +
+                            " ConnectingIOReactor encountered a checked exception : " +
+                            ioException.getMessage(), ioException);
+                    return true;
+                }
+
+                public boolean handle(RuntimeException runtimeException) {
+                    log.warn("System may be unstable: " + namePrefix +
+                            " ConnectingIOReactor encountered a runtime exception : "
+                            + runtimeException.getMessage(), runtimeException);
+                    return true;
+                }
+            });
+        } catch (IOReactorException e) {
+            handleException("Error starting " + namePrefix + " ConnectingIOReactor", e);
+        }
+
+        ConnectCallback connectCallback = new ConnectCallback();
+        // manage target connections
+        TargetConnections targetConnections =
+                new TargetConnections(ioReactor, targetConfiguration, connectCallback);
+        targetConfiguration.setConnections(targetConnections);
+
+        // create the delivery agent to hand over messages
+        deliveryAgent = new DeliveryAgent(targetConfiguration, targetConnections);
+        // we need to set the delivery agent
+        connectCallback.setDeliveryAgent(deliveryAgent);        
+
+        TargetHandler handler = new TargetHandler(deliveryAgent, targetConfiguration);
+        final IOEventDispatch ioEventDispatch =
+                getEventDispatch(handler, sslContext, sslSetupHandler,
+                        targetConfiguration.getHttpParameters(), transportOutDescription);
+
+        // start the sender in a separate thread
+        Thread t = new Thread(new Runnable() {
+            public void run() {
+                try {
+                    ioReactor.execute(ioEventDispatch);
+                } catch (Exception ex) {
+                   log.fatal("Exception encountered in the " + namePrefix + " Sender. " +
+                            "No more connections will be initiated by this transport", ex);
+                }
+                log.info(namePrefix + " Sender shutdown");
+            }
+        }, "PassThrough" + namePrefix + "Sender");
+        t.start();
+
+        state = BaseConstants.STARTED;
+
+        log.info("Pass-through " + namePrefix + " Sender started...");
+    }
+
+    public void cleanup(org.apache.axis2.context.MessageContext messageContext) throws AxisFault {
+
+    }
+
+    public void stop() {
+        try {
+            ioReactor.shutdown();
+        } catch (IOException e) {
+            log.error("Error shutting down the PassThroughHttpSender", e);
+        }
+    }
+
+
+    public InvocationResponse invoke(org.apache.axis2.context.MessageContext msgContext) throws AxisFault {
+        // remove unwanted HTTP headers (if any from the current message)
+        PassThroughTransportUtils.removeUnwantedHeaders(msgContext,
+                targetConfiguration.isPreserveServerHeader(),
+                targetConfiguration.isPreserveUserAgentHeader());
+
+        if (AddressingHelper.isReplyRedirected(msgContext)
+                && !msgContext.getReplyTo().hasNoneAddress()) {
+
+            msgContext.setProperty(PassThroughConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
+        }
+
+        EndpointReference epr = PassThroughTransportUtils.getDestinationEPR(msgContext);
+        if (epr != null) {
+            if (!epr.hasNoneAddress()) {
+                if (msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE) == null) {
+                    Pipe pipe = new Pipe(targetConfiguration.getBufferFactory().getBuffer(),
+                            "Test", targetConfiguration);
+                    msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, pipe);
+                    msgContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);
+                }
+                deliveryAgent.submit(msgContext, epr);
+                sendRequestContent(msgContext);
+            } else {
+                handleException("Cannot send message to " + AddressingConstants.Final.WSA_NONE_URI);
+            }
+        } else {
+            if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) != null) {
+                if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) instanceof ServerWorker) {
+                    try {
+                        submitResponse(msgContext);
+                    } catch (Exception e) {
+                        handleException("Failed to submit the response", e);
+                    }
+                }else {
+                    //handleException("No valid destination EPR to send message");
+                	//should be able to handle sendUsingOutputStream  Ref NHTTP_NIO
+                	sendUsingOutputStream(msgContext);
+                }
+            } else {
+                handleException("No valid destination EPR to send message");
+            }
+        }
+
+        if (msgContext.getOperationContext() != null) {
+            msgContext.getOperationContext().setProperty(
+                Constants.RESPONSE_WRITTEN, Constants.VALUE_TRUE);
+        }
+
+        return InvocationResponse.CONTINUE;
+    }
+    
+    
+    private void sendUsingOutputStream(MessageContext msgContext) throws AxisFault {
+
+        OMOutputFormat format = NhttpUtil.getOMOutputFormat(msgContext);
+        MessageFormatter messageFormatter =
+                MessageFormatterDecoratorFactory.createMessageFormatterDecorator(msgContext);
+        OutputStream out = (OutputStream) msgContext.getProperty(MessageContext.TRANSPORT_OUT);
+
+        if (msgContext.isServerSide()) {
+            OutTransportInfo transportInfo =
+                (OutTransportInfo) msgContext.getProperty(Constants.OUT_TRANSPORT_INFO);
+
+            if (transportInfo != null) {
+                transportInfo.setContentType(
+                messageFormatter.getContentType(msgContext, format, msgContext.getSoapAction()));
+            } else {
+                throw new AxisFault(Constants.OUT_TRANSPORT_INFO + " has not been set");
+            }
+        }
+
+        try {
+            messageFormatter.writeTo(msgContext, format, out, false);
+            out.close();
+        } catch (IOException e) {
+            handleException("IO Error sending response message", e);
+        }
+    }
+
+
+	private void sendRequestContent(final MessageContext msgContext) throws AxisFault {
+		if (Boolean.TRUE.equals(msgContext.getProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED))) {
+			synchronized (msgContext) {
+				while (!Boolean.TRUE.equals(msgContext.getProperty("READY2ROCK")) &&
+				       !Boolean.TRUE.equals(msgContext.getProperty("PASSTHRU_CONNECT_ERROR"))) {
+					try {
+						msgContext.wait();
+					} catch (InterruptedException e) {
+						e.printStackTrace();
+					}
+				}
+			}
+
+			if (Boolean.TRUE.equals(msgContext.getProperty("PASSTHRU_CONNECT_ERROR"))) {
+				return;
+			}
+
+			OutputStream out = (OutputStream) msgContext.getProperty("GET_ME_OUT");
+			if (out != null) {
+				String disableChunking = (String) msgContext.getProperty(PassThroughConstants.DISABLE_CHUNKING);
+				String forceHttp10 = (String) msgContext.getProperty(PassThroughConstants.FORCE_HTTP_1_0);
+				Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+				
+				if("true".equals(disableChunking) || "true".equals(forceHttp10) ){
+					ByteArrayOutputStream _out = new ByteArrayOutputStream();
+					MessageFormatter formatter =  MessageProcessorSelector.getMessageFormatter(msgContext);
+					OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);
+					formatter.writeTo(msgContext, format, _out, false);
+					try {
+	                    IOUtils.write(_out.toByteArray(),out);
+	                    msgContext.setProperty(PassThroughConstants.PASS_THROUGH_MESSAGE_LENGTH,new Long(_out.toByteArray().length));
+                    } catch (IOException e) {
+	                    // TODO Auto-generated catch block
+                    	 handleException("IO while building message", e);
+                    }
+                	pipe.setSerializationComplete(true);
+				}else {
+					
+					if ((disableChunking == null || !"true".equals(disableChunking)) ||
+					    (forceHttp10 == null || !"true".equals(forceHttp10))) {
+						MessageFormatter formatter =  MessageProcessorSelector.getMessageFormatter(msgContext);
+						OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);
+						formatter.writeTo(msgContext, format, out, false);
+					}
+					
+					if ((msgContext.getProperty(PassThroughConstants.REST_GET_DELETE_INVOKE) != null &&
+						    (Boolean) msgContext.getProperty(PassThroughConstants.REST_GET_DELETE_INVOKE))) {
+							pipe.setSerializationCompleteWithoutData(true);
+					}else{
+						pipe.setSerializationComplete(true);
+					}
+			
+				}
+			}
+		}
+	}
+
+    /**
+     * Return the IOEventDispatch implementation to be used. This is overridden by the
+     * SSL sender
+     *
+     * @param handler The passthru target handler instance
+     * @param sslContext SSL context used by the sender or null
+     * @param sslIOSessionHandler SSL session handler or null
+     * @param params HTTP parameters
+     * @param trpOut Transport out description
+     * @return an IOEventDispatch instance
+     * @throws AxisFault on error
+     */
+    protected IOEventDispatch getEventDispatch(NHttpClientHandler handler,
+                                               SSLContext sslContext,
+                                               SSLSetupHandler sslIOSessionHandler,
+                                               HttpParams params, TransportOutDescription trpOut) throws AxisFault {
+
+        return new TargetIOEventDispatch(handler, params);
+    }
+
+    /**
+     * Always return null, as this implementation does not support outgoing SSL
+     *
+     * @param transportOut The transport out description
+     * @return null
+     * @throws AxisFault on error
+     */
+    protected SSLContext getSSLContext(TransportOutDescription transportOut) throws AxisFault {
+        return null;
+    }
+
+    /**
+     * Create the SSL IO Session handler to be used by this listener
+     *
+     * @param transportOut Transport out description
+     * @return always null
+     * @throws AxisFault on error
+     */
+    protected SSLSetupHandler getSSLSetupHandler(TransportOutDescription transportOut)
+        throws AxisFault {
+        return null;
+    }
+
+    public void submitResponse(MessageContext msgContext)
+            throws IOException, HttpException {
+        SourceConfiguration sourceConfiguration = (SourceConfiguration) msgContext.getProperty(
+                        PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION);
+
+        NHttpServerConnection conn = (NHttpServerConnection) msgContext.getProperty(
+                PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION);
+        if (conn == null) {
+            ServerWorker serverWorker = (ServerWorker) msgContext.getProperty(Constants.OUT_TRANSPORT_INFO);
+            if (serverWorker != null) {
+                MessageContext requestContext = serverWorker.getRequestContext();
+                conn = (NHttpServerConnection) requestContext.getProperty(
+                        PassThroughConstants.PASS_THROUGH_SOURCE_CONNECTION);
+                sourceConfiguration = (SourceConfiguration) requestContext.getProperty(
+                        PassThroughConstants.PASS_THROUGH_SOURCE_CONFIGURATION);
+            } else {
+                throw new IllegalStateException("Unable to correlate the response to a request");
+            }
+        }
+
+        SourceRequest sourceRequest = SourceContext.getRequest(conn);
+
+        SourceResponse sourceResponse = SourceResponseFactory.create(msgContext,
+                sourceRequest, sourceConfiguration);
+
+        SourceContext.setResponse(conn, sourceResponse);
+
+        Boolean noEntityBody = (Boolean) msgContext.getProperty(PassThroughConstants.NO_ENTITY_BODY);
+        Pipe pipe = (Pipe) msgContext.getProperty(PassThroughConstants.PASS_THROUGH_PIPE);
+        if ((noEntityBody == null || !noEntityBody) || pipe != null) {
+            if (pipe == null) {
+                pipe = new Pipe(sourceConfiguration.getBufferFactory().getBuffer(),
+                        "Test", sourceConfiguration);
+                msgContext.setProperty(PassThroughConstants.PASS_THROUGH_PIPE, pipe);
+                msgContext.setProperty(PassThroughConstants.MESSAGE_BUILDER_INVOKED, Boolean.TRUE);
+            }
+
+            pipe.attachConsumer(conn);
+            sourceResponse.connect(pipe);
+        }
+
+        Integer errorCode = (Integer) msgContext.getProperty(PassThroughConstants.ERROR_CODE);
+        if (errorCode != null) {
+            sourceResponse.setStatus(HttpStatus.SC_BAD_GATEWAY);
+            SourceContext.get(conn).setShutDown(true);
+        }
+
+        ProtocolState state = SourceContext.getState(conn);
+        if (state != null && state.compareTo(ProtocolState.REQUEST_DONE) <= 0) {
+            // start sending the response if we
+            if (msgContext.isPropertyTrue(PassThroughConstants.MESSAGE_BUILDER_INVOKED) && pipe != null) {
+                OutputStream out = pipe.getOutputStream();
+                if (msgContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED)) {
+                    out.write(new byte[0]);
+                }else {
+                    MessageFormatter formatter = MessageProcessorSelector.getMessageFormatter(msgContext);
+                    OMOutputFormat format = PassThroughTransportUtils.getOMOutputFormat(msgContext);
+                    formatter.writeTo(msgContext, format, out, false);
+                }
+                pipe.setSerializationComplete(true);
+                out.close();
+            }
+            
+            if(noEntityBody != null && Boolean.TRUE == noEntityBody && pipe != null){
+                OutputStream out = pipe.getOutputStream();
+            	out.write(new byte[0]);
+            	pipe.setRawSerializationComplete(true);
+                out.close();
+            }
+            conn.requestOutput();
+        } else {
+            // nothing much to do as we have started the response already
+            if (errorCode != null) {
+                if (log.isDebugEnabled()) {
+                    log.warn("A Source connection is closed because of an " +
+                            "error in target: " + conn);
+                }
+            } else {
+                log.debug("A Source Connection is closed, because source handler " +
+                        "is already in the process of writing a response while " +
+                        "another response is submitted: " + conn);
+            }
+
+            SourceContext.updateState(conn, ProtocolState.CLOSED);
+            sourceConfiguration.getSourceConnections().shutDownConnection(conn);
+        }
+    }
+
+    public void pause() throws AxisFault {
+        if (state != BaseConstants.STARTED) {
+            return;
+        }
+        state = BaseConstants.PAUSED;
+        log.info(namePrefix + " Sender Paused");
+    }
+
+    public void resume() throws AxisFault {
+        if (state != BaseConstants.PAUSED) {
+            return;
+        }
+        state = BaseConstants.STARTED;
+        log.info(namePrefix + " Sender Resumed");
+    }
+
+    public void maintenanceShutdown(long millis) throws AxisFault {
+        if (state != BaseConstants.STARTED) return;
+        try {
+            long start = System.currentTimeMillis();
+            ioReactor.shutdown(millis);
+            state = BaseConstants.STOPPED;
+            log.info("Sender shutdown in : " + (System.currentTimeMillis() - start) / 1000 + "s");
+        } catch (IOException e) {
+            handleException("Error shutting down the IOReactor for maintenence", e);
+        }
+    }
+
+    private void handleException(String s, Exception e) throws AxisFault {
+        log.error(s, e);
+        throw new AxisFault(s, e);
+    }
+
+    private void handleException(String msg) throws AxisFault {
+        log.error(msg);
+        throw new AxisFault(msg);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyView.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyView.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyView.java	(revision 1502663)
@@ -0,0 +1,260 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import org.apache.axis2.AxisFault;
+
+import java.util.Calendar;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * <p>LatencyView provides statistical information related to the latency (overhead) incurred by
+ * the Synapse NHTTP transport, when mediating messages back and forth. Statistics are available
+ * under two main categories, namely short term data and long term data. Short term data is
+ * statistical information related to the last 15 minutes of execution and these metrics are
+ * updated every 5 seconds. Long term data is related to the last 24 hours of execution and
+ * they are updated every 5 minutes. Two timer tasks and a single threaded scheduled executor
+ * is used to perform these periodic calculations.</p>
+ *
+ * <p>Latency calculation for a single invocation is carried out by taking timestamps on
+ * following events:</p>
+ *
+ * <ul>
+ *  <li>t1 - Receiving a new request (ServerHandler#requestReceived)</li>
+ *  <li>t2 - Obtaining a connection to forward the request (Clienthandler#processConnection)</li>
+ *  <li>t3 - Reading the complete response from the backend server (ClientHandler#inputReady)</li>
+ *  <li>t4 - Writing the complete response to the client (ServerHandler#outputReady)</li>
+ * <ul>
+ *
+ * <p>Having taken these timestamps, the latency for the invocation is calculated as follows:<br/>
+ *    Latency = (t4 - t1) - (t3 - t2)
+ * </p>
+ *
+ */
+public class LatencyView implements LatencyViewMBean {
+
+    private static final String NHTTP_LATENCY_VIEW = "NhttpTransportLatency";
+
+    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;
+    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;
+    private static final int SAMPLES_PER_MINUTE = 60/ SMALL_DATA_COLLECTION_PERIOD;
+    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;
+
+    /** Keeps track of th last reported latency value */
+    private AtomicLong lastLatency = new AtomicLong(0);
+
+    /**
+     * Queue of all latency values reported. The short term data collector clears this queue up
+     * time to time thus ensuring it doesn't grow indefinitely.
+     */
+    private Queue<Long> latencyDataQueue = new ConcurrentLinkedQueue<Long>();
+
+    /**
+     * Queue of samples collected by the short term data collector. This is maintained
+     * as a fixed length queue
+     */
+    private Queue<Long> shortTermLatencyDataQueue = new LinkedList<Long>();
+
+    /**
+     * Queue of samples collected by the long term data collector. This is maintained
+     * as a fixed length queue
+     */
+    private Queue<Long> longTermLatencyDataQueue = new LinkedList<Long>();
+
+    /** Scheduled executor on which data collectors are executed */
+    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
+
+    private double allTimeAvgLatency = 0.0;
+    private int count = 0;
+    private Date resetTime = Calendar.getInstance().getTime();
+
+    private String name;
+
+    public LatencyView(boolean isHttps) throws AxisFault {
+        name = "nio-http" + (isHttps ? "s" : "");
+        scheduler.scheduleAtFixedRate(new ShortTermDataCollector(), SMALL_DATA_COLLECTION_PERIOD,
+                SMALL_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);
+        scheduler.scheduleAtFixedRate(new LongTermDataCollector(), LARGE_DATA_COLLECTION_PERIOD,
+                LARGE_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);
+
+        MBeanRegistrar.getInstance().registerMBean(this, NHTTP_LATENCY_VIEW, name);
+
+    }
+
+    public void destroy() {
+        MBeanRegistrar.getInstance().unRegisterMBean(NHTTP_LATENCY_VIEW, name);
+        scheduler.shutdownNow();
+    }
+
+    /**
+     * Report the timestamp values captured during mediating messages back and forth
+     *
+     * @param reqArrival The request arrival time
+     * @param reqDeparture The request departure time (backend connection establishment)
+     * @param resArrival The resoponse arrival time
+     * @param resDeparture The response departure time
+     */
+    public void notifyTimes(long reqArrival, long reqDeparture,
+                            long resArrival, long resDeparture) {
+
+        long latency = (resDeparture - reqArrival) - (resArrival - reqDeparture);
+        lastLatency.set(latency);
+        latencyDataQueue.offer(latency);
+    }
+
+    public double getAllTimeAvgLatency() {
+        return allTimeAvgLatency;
+    }
+
+    public double getLastMinuteAvgLatency() {
+        return getAverageLatencyByMinute(1);
+    }
+
+    public double getLast5MinuteAvgLatency() {
+        return getAverageLatencyByMinute(5);
+    }
+
+    public double getLast15MinuteAvgLatency() {
+        return getAverageLatencyByMinute(15);
+    }
+
+    public double getLastHourAvgLatency() {
+        return getAverageLatencyByHour(1);
+    }
+
+    public double getLast8HourAvgLatency() {
+        return getAverageLatencyByHour(8);
+    }
+
+    public double getLast24HourAvgLatency() {
+        return getAverageLatencyByHour(24);
+    }
+
+    public void reset() {
+        lastLatency.set(0);
+        allTimeAvgLatency = 0.0;
+        latencyDataQueue.clear();
+        shortTermLatencyDataQueue.clear();
+        longTermLatencyDataQueue.clear();
+        count = 0;
+        resetTime = Calendar.getInstance().getTime();
+    }
+
+    public Date getLastResetTime() {
+        return resetTime;
+    }
+
+    private double getAverageLatencyByMinute(int n) {
+        int samples = n * SAMPLES_PER_MINUTE;
+        double sum = 0.0;
+        Long[] array = shortTermLatencyDataQueue.toArray(new Long[shortTermLatencyDataQueue.size()]);
+
+        if (samples > array.length) {
+            // If we don't have enough samples collected yet
+            // add up everything we have
+            samples = array.length;
+            for (Long anArray : array) {
+                sum += anArray;
+            }
+        } else {
+            // We have enough samples to make the right calculation
+            // Add up starting from the end of the queue (to give the most recent values)
+            for (int i = 0; i < samples; i++) {
+                sum += array[array.length - 1 - i];
+            }
+        }
+
+        if (samples == 0) {
+            return 0.0;
+        }
+        return sum/samples;
+    }
+
+    private double getAverageLatencyByHour(int n) {
+        int samples = n * SAMPLES_PER_HOUR;
+        double sum = 0.0;
+        Long[] array = longTermLatencyDataQueue.toArray(new Long[longTermLatencyDataQueue.size()]);
+
+        if (samples > array.length) {
+            samples = array.length;
+            for (Long anArray : array) {
+                sum += anArray;
+            }
+        } else {
+            for (int i = 0; i < samples; i++) {
+                sum += array[array.length - 1 - i];
+            }
+        }
+
+        if (samples == 0) {
+            return 0.0;
+        }
+        return sum/samples;
+    }
+
+    private class ShortTermDataCollector implements Runnable {
+        public void run() {
+            long latency = lastLatency.get();
+
+            // calculate all time average latency
+            int size = latencyDataQueue.size();
+            if (size > 0) {
+                long sum = 0;
+                for (int i = 0; i < size; i++) {
+                    sum += latencyDataQueue.poll();
+                }
+                allTimeAvgLatency = (allTimeAvgLatency * count + sum)/(count + size);
+                count = count + size;
+            }
+
+            if (shortTermLatencyDataQueue.size() == 0 && latency == 0) {
+                // we haven't started collecting data yet - skip ahead...
+                return;
+            }
+
+            // take a sample for the short term latency calculation
+            if (shortTermLatencyDataQueue.size() == SAMPLES_PER_MINUTE * 15) {
+                shortTermLatencyDataQueue.remove();
+            }
+            shortTermLatencyDataQueue.offer(latency);
+        }
+    }
+
+    private class LongTermDataCollector implements Runnable {
+        public void run() {
+            long latency = lastLatency.get();
+            if (longTermLatencyDataQueue.size() == 0 && latency == 0) {
+                return;
+            }
+
+            if (longTermLatencyDataQueue.size() == SAMPLES_PER_HOUR * 24) {
+                longTermLatencyDataQueue.remove();
+            }
+            longTermLatencyDataQueue.offer(latency);
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsViewMBean.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsViewMBean.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsViewMBean.java	(revision 1502663)
@@ -0,0 +1,40 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import java.util.Date;
+import java.util.Map;
+
+public interface ConnectionsViewMBean {
+
+    public int getActiveConnections();
+    public int getLastMinuteConnections();
+    public int getLast5MinuteConnections();
+    public int getLast15MinuteConnections();
+    public int getLastHourConnections();
+    public int getLast8HourConnections();
+    public int getLast24HourConnections();
+    public Map getRequestSizesMap();
+    public Map getResponseSizesMap();
+    public Date getLastResetTime();
+
+    public void reset();
+
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/Wire.java	(revision 1502663)
@@ -0,0 +1,109 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.commons.logging.Log;
+
+import java.nio.ByteBuffer;
+
+public class Wire {
+    private final Log log;
+
+    public Wire(final Log log) {
+        super();
+        this.log = log;
+    }
+
+    private void wire(final String header, final byte[] b, int pos, int off) {
+        StringBuilder buffer = new StringBuilder();
+        for (int i = 0; i < off; i++) {
+            int ch = b[pos + i];
+            if (ch == 13) {
+                buffer.append("[\\r]");
+            } else if (ch == 10) {
+                    buffer.append("[\\n]\"");
+                    buffer.insert(0, "\"");
+                    buffer.insert(0, header);
+                    this.log.debug(buffer.toString());
+                    buffer.setLength(0);
+            } else if ((ch < 32) || (ch > 127)) {
+                buffer.append("[0x");
+                buffer.append(Integer.toHexString(ch));
+                buffer.append("]");
+            } else {
+                buffer.append((char) ch);
+            }
+        }
+        if (buffer.length() > 0) {
+            buffer.append('\"');
+            buffer.insert(0, '\"');
+            buffer.insert(0, header);
+            this.log.debug(buffer.toString());
+        }
+    }
+
+
+    public boolean isEnabled() {
+        return this.log.isDebugEnabled();
+    }
+
+    public void output(final byte[] b, int pos, int off) {
+        wire("<< ", b, pos, off);
+    }
+
+    public void input(final byte[] b, int pos, int off) {
+        wire(">> ", b, pos, off);
+    }
+
+    public void output(byte[] b) {
+        output(b, 0, b.length);
+    }
+
+    public void input(byte[] b) {
+        input(b, 0, b.length);
+    }
+
+    public void output(int b) {
+        output(new byte[] {(byte) b});
+    }
+
+    public void input(int b) {
+        input(new byte[] {(byte) b});
+    }
+
+    public void output(final ByteBuffer b) {
+        if (b.hasArray()) {
+            output(b.array(), b.arrayOffset() + b.position(), b.remaining());
+        } else {
+            byte[] tmp = new byte[b.remaining()];
+            b.get(tmp);
+            output(tmp);
+        }
+    }
+
+    public void input(final ByteBuffer b) {
+        if (b.hasArray()) {
+            input(b.array(), b.arrayOffset() + b.position(), b.remaining());
+        } else {
+            byte[] tmp = new byte[b.remaining()];
+            b.get(tmp);
+            input(tmp);
+        }
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ErrorCodes.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ErrorCodes.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ErrorCodes.java	(revision 1502663)
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+/**
+ * Error codes exposed by this transport. 
+ */
+public class ErrorCodes {
+    public static final int SND_IO_ERROR       = 101500;
+
+    public static final int SND_HTTP_ERROR     = 102510;
+
+    public static final int SND_INVALID_STATE  = 102510;
+
+    public static final int CONNECTION_FAILED  = 101503;
+
+    public static final int CONNECTION_TIMEOUT = 101504;
+
+    public static final int CONNECTION_CLOSED  = 101505;
+
+    public static final int PROTOCOL_VIOLATION = 101506;
+
+    public static final int CONNECT_CANCEL     = 101507;
+
+    public static final int CONNECT_TIMEOUT    = 101508;    
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportView.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportView.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportView.java	(revision 1502663)
@@ -0,0 +1,223 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import org.apache.axis2.AxisFault;
+import org.apache.synapse.transport.passthru.PassThroughHttpListener;
+import org.apache.synapse.transport.passthru.PassThroughHttpSender;
+
+import java.util.Map;
+import java.util.concurrent.ThreadPoolExecutor;
+
+public class TransportView implements TransportViewMBean {
+
+    private PassThroughHttpListener listener = null;
+
+    private PassThroughHttpSender sender = null;
+
+    private PassThroughTransportMetricsCollector metrics = null;
+
+    private ThreadPoolExecutor threadPool = null;
+
+    public TransportView(PassThroughHttpListener listener,
+                         PassThroughHttpSender sender,
+                         PassThroughTransportMetricsCollector metrics,
+                         ThreadPoolExecutor threadPool) throws AxisFault {
+        this.listener = listener;
+        this.metrics = metrics;
+        this.threadPool = threadPool;
+        this.sender = sender;
+    }
+
+    public void pause() throws AxisFault {
+        if (listener != null) {
+            listener.pause();
+        } else if (sender != null) {
+            sender.pause();
+        }
+    }
+
+    public void resume() throws AxisFault {
+        if (listener != null) {
+            listener.resume();
+        } else if (sender != null) {
+            sender.resume();
+        }
+    }
+
+    public void maintenenceShutdown(long l) throws AxisFault {
+        if (listener != null) {
+            listener.maintenanceShutdown(l);
+        } else if (sender != null) {
+            sender.maintenanceShutdown(l);
+        }
+    }
+
+    public int getActiveThreadCount() {
+        if (threadPool != null) {
+            return threadPool.getActiveCount();
+        }
+        return 0;
+    }
+
+    public int getQueueSize() {
+        if (threadPool != null && threadPool.getQueue() != null) {
+            return threadPool.getQueue().size();
+        }
+        return 0;
+    }
+
+    public long getMessagesReceived() {
+        if (metrics != null) {
+            return metrics.getMessagesReceived();
+        }
+        return -1;
+    }
+
+    public long getFaultsReceiving() {
+        if (metrics != null) {
+            return metrics.getFaultsReceiving();
+        }
+        return -1;
+    }
+
+    public long getBytesReceived() {
+        if (metrics != null) {
+            return metrics.getBytesReceived();
+        }
+        return -1;
+    }
+
+    public long getMessagesSent() {
+        if (metrics != null) {
+            return metrics.getMessagesSent();
+        }
+        return -1;
+    }
+
+    public long getFaultsSending() {
+        if (metrics != null) {
+            return metrics.getFaultsSending();
+        }
+        return -1;
+    }
+
+    public long getBytesSent() {
+        if (metrics != null) {
+            return metrics.getBytesSent();
+        }
+        return -1;
+    }
+
+    public long getTimeoutsReceiving() {
+        if (metrics != null) {
+            return metrics.getTimeoutsReceiving();
+        }
+        return -1;
+    }
+
+    public long getTimeoutsSending() {
+        if (metrics != null) {
+            return metrics.getTimeoutsSending();
+        }
+        return -1;
+    }
+
+    public long getMinSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMinSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMaxSizeReceived();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeReceived() {
+        if (metrics != null) {
+            return metrics.getAvgSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMinSizeSent() {
+        if (metrics != null) {
+            return metrics.getMinSizeSent();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeSent() {
+        if (metrics != null) {
+            return metrics.getMaxSizeSent();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeSent() {
+        if (metrics != null) {
+            return metrics.getAvgSizeSent();
+        }
+        return -1;
+    }
+
+    public Map getResponseCodeTable() {
+        if (metrics != null) {
+            return metrics.getResponseCodeTable();
+        }
+        return null;
+    }
+
+    public void start() throws Exception {
+        if (listener != null) {
+            listener.start();
+        }
+    }
+
+    public void stop() throws Exception {
+        if (listener != null) {
+            listener.stop();
+        }
+    }
+
+    public void resetStatistics() {
+        if (metrics != null) {
+            metrics.reset();
+        }
+    }
+
+    public long getLastResetTime() {
+        if (metrics != null) {
+            return metrics.getLastResetTime();
+        }
+        return -1;
+    }
+
+    public long getMetricsWindow() {
+        if (metrics != null) {
+            return System.currentTimeMillis() - metrics.getLastResetTime();
+        }
+        return -1;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyViewMBean.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyViewMBean.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/LatencyViewMBean.java	(revision 1502663)
@@ -0,0 +1,36 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import java.util.Date;
+
+public interface LatencyViewMBean {
+
+    public double getAllTimeAvgLatency();
+    public double getLastMinuteAvgLatency();
+    public double getLast5MinuteAvgLatency();
+    public double getLast15MinuteAvgLatency();
+    public double getLastHourAvgLatency();
+    public double getLast8HourAvgLatency();
+    public double getLast24HourAvgLatency();
+    public void reset();
+    public Date getLastResetTime();
+
+}
\ No newline at end of file
Index: java/modules/integration/src/test/resources/axis2Xml/synapse/axis2_def.xml
===================================================================
--- java/modules/integration/src/test/resources/axis2Xml/synapse/axis2_def.xml	(revision 1502662)
+++ java/modules/integration/src/test/resources/axis2Xml/synapse/axis2_def.xml	(revision 1502663)
@@ -127,15 +127,15 @@
     <!--format  serialization in Axis2. These message formats are expected to be resolved based on the content type. -->
     <messageFormatters>
         <messageFormatter contentType="application/x-www-form-urlencoded"
-                         class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                         class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="multipart/form-data"
-                         class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                         class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="application/xml"
-                         class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                         class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="text/xml"
-                         class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                         class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="multipart/related"
-                         class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                         class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
 
         <!--messageFormatter contentType="application/x-www-form-urlencoded"
                          class="org.apache.axis2.transport.http.XFormURLEncodedFormatter"/>
@@ -159,15 +159,15 @@
     <!--formats in Axis2. These message formats are expected to be resolved based on the content type. -->
     <messageBuilders>
         <messageBuilder contentType="application/xml"
-                         class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                         class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="application/x-www-form-urlencoded"
-                         class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                         class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="multipart/form-data"
-                         class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                         class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="text/xml"
-                         class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                         class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="multipart/related"
-                         class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                         class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
 
         <!--messageBuilder contentType="application/xml"
                          class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingSourceHandler.java	(revision 1502663)
@@ -0,0 +1,123 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.NHttpServerConnection;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.ConnectionClosedException;
+import org.apache.http.HttpException;
+import org.apache.http.HttpRequest;
+
+import java.io.IOException;
+
+public class LoggingSourceHandler implements NHttpServiceHandler {
+
+    private final Log log;
+
+    private final NHttpServiceHandler handler;
+
+    public LoggingSourceHandler (final NHttpServiceHandler handler) {
+        super();
+        if (handler == null) {
+            throw new IllegalArgumentException("HTTP service handler may not be null");
+        }
+        this.handler = handler;
+        this.log = LogFactory.getLog(handler.getClass());
+    }
+
+    public void connected(final NHttpServerConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Connected");
+        }
+        this.handler.connected(conn);
+    }
+
+    public void closed(final NHttpServerConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed");
+        }
+        this.handler.closed(conn);
+    }
+
+    public void exception(final NHttpServerConnection conn, final IOException ex) {
+        if (ex instanceof ConnectionClosedException ||
+                ex.getMessage().contains("Connection reset by peer") ||
+                ex.getMessage().contains("forcibly closed")) {
+            if (this.log.isDebugEnabled()) {
+                this.log.debug("HTTP connection " + conn + ": " + ex.getMessage() +
+                    " (Probably the keepalive connection was closed)");
+            }
+        } else {
+            this.log.error("IO Error occured on HTTP connection " + conn + ": " + ex.getMessage(), ex);
+        }
+        this.handler.exception(conn, ex);
+    }
+
+    public void exception(final NHttpServerConnection conn, final HttpException ex) {
+        this.log.error("HTTP Error occured on connection " + conn + ": " + ex.getMessage(), ex);
+        this.handler.exception(conn, ex);
+    }
+
+    public void requestReceived(final NHttpServerConnection conn) {
+        HttpRequest request = conn.getHttpRequest();
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP InRequest Received on connection " + conn + ": "
+                    + request.getRequestLine());
+        }
+        this.handler.requestReceived(conn);
+    }
+
+    public void outputReady(final NHttpServerConnection conn, final ContentEncoder encoder) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Output ready");
+        }
+        this.handler.outputReady(conn, encoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
+        }
+    }
+
+    public void responseReady(final NHttpServerConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Response ready");
+        }
+        this.handler.responseReady(conn);
+    }
+
+    public void inputReady(final NHttpServerConnection conn, final ContentDecoder decoder) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Input ready");
+        }
+        this.handler.inputReady(conn, decoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
+        }
+    }
+
+    public void timeout(final NHttpServerConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Timeout");
+        }
+        this.handler.timeout(conn);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingTargetHandler.java	(revision 1502663)
@@ -0,0 +1,122 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpClientConnection;
+import org.apache.http.nio.ContentEncoder;
+import org.apache.http.nio.ContentDecoder;
+import org.apache.http.HttpException;
+import org.apache.http.HttpResponse;
+
+import java.io.IOException;
+
+public class LoggingTargetHandler implements NHttpClientHandler {
+
+    private final Log log;
+    
+    private final NHttpClientHandler handler;
+
+    public LoggingTargetHandler(final NHttpClientHandler handler) {
+        super();
+        if (handler == null) {
+            throw new IllegalArgumentException("HTTP client handler may not be null");
+        }
+        this.handler = handler;
+        this.log = LogFactory.getLog(handler.getClass());
+    }
+
+    public void connected(final NHttpClientConnection conn, final Object attachment) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Connected (" + attachment + ")");
+        }
+        this.handler.connected(conn, attachment);
+    }
+
+    public void closed(final NHttpClientConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Closed");
+        }
+        this.handler.closed(conn);
+    }
+
+    public void exception(final NHttpClientConnection conn, final IOException ex) {
+        this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
+        this.handler.exception(conn, ex);
+    }
+
+    public void exception(final NHttpClientConnection conn, final HttpException ex) {
+        this.log.error("HTTP connection " + conn + ": " + ex.getMessage(), ex);
+        this.handler.exception(conn, ex);
+    }
+
+    public void requestReady(final NHttpClientConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": InRequest ready" + getRequestMessageID(conn));
+        }
+        this.handler.requestReady(conn);
+    }
+
+    public void outputReady(final NHttpClientConnection conn, final ContentEncoder encoder) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Output ready" + getRequestMessageID(conn));
+        }
+        this.handler.outputReady(conn, encoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content encoder " + encoder);
+        }
+    }
+
+    public void responseReceived(final NHttpClientConnection conn) {
+        HttpResponse response = conn.getHttpResponse();
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + " : "
+                    + response.getStatusLine() + getRequestMessageID(conn));
+        }
+        this.handler.responseReceived(conn);
+    }
+
+    public void inputReady(final NHttpClientConnection conn, final ContentDecoder decoder) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Input ready" + getRequestMessageID(conn));
+        }
+        this.handler.inputReady(conn, decoder);
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Content decoder " + decoder);
+        }
+    }
+
+    public void timeout(final NHttpClientConnection conn) {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + conn + ": Timeout" + getRequestMessageID(conn));
+        }
+        this.handler.timeout(conn);
+    }
+
+    private static String getRequestMessageID(final NHttpClientConnection conn) {
+        /*Axis2HttpRequest axis2Request = (Axis2HttpRequest)
+                conn.getContext().getAttribute(ClientHandler.AXIS2_HTTP_REQUEST);
+        if (axis2Request != null) {
+            return " [InRequest Message ID : " + axis2Request.getMsgContext().getMessageID() + "]";
+        }*/        
+        return "";
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/MBeanRegistrar.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/MBeanRegistrar.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/MBeanRegistrar.java	(revision 1502663)
@@ -0,0 +1,102 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import org.apache.axis2.AxisFault;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+import java.lang.management.ManagementFactory;
+import java.util.Set;
+
+public class MBeanRegistrar {
+
+    private static final MBeanRegistrar ourInstance = new MBeanRegistrar();
+    private static final Log log = LogFactory.getLog(MBeanRegistrar.class);
+
+    public static MBeanRegistrar getInstance() {
+        return ourInstance;
+    }
+
+    private MBeanRegistrar() {
+    }
+
+    public void registerMBean(Object mBeanInstance, String category, String id) throws AxisFault {
+        assertNull(mBeanInstance, "MBean instance is null");
+        assertNull(category, "MBean instance category is null");
+        assertNull(id, "MBean instance name is null");
+        try {
+            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+            ObjectName name = new ObjectName(getObjectName(category, id));
+            Set set = mbs.queryNames(name, null);
+            if (set != null && set.isEmpty()) {
+                mbs.registerMBean(mBeanInstance, name);
+            } else {
+                mbs.unregisterMBean(name);
+                mbs.registerMBean(mBeanInstance, name);
+            }
+        } catch (Exception e) {
+            log.warn("Error registering a MBean with name ' " + id +
+                    " ' and category name ' " + category + "' for JMX management", e);
+        }
+    }
+
+    public void unRegisterMBean(String category, String id) {
+        try {
+            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+            ObjectName objName = new ObjectName(getObjectName(category, id));
+            if (mbs.isRegistered(objName)) {
+                mbs.unregisterMBean(objName);
+            }
+        } catch (Exception e) {
+            log.warn("Error un-registering a  MBean with name ' " + id +
+                    " ' and category name ' " + category + "' for JMX management", e);
+        }
+    }
+
+    private String getObjectName(String category, String id) {
+
+        String jmxAgentName = System.getProperty("jmx.agent.name");
+        if (jmxAgentName == null || "".equals(jmxAgentName)) {
+            jmxAgentName = "org.apache.synapse";
+        }
+        return jmxAgentName + ":Type=" + category + ",Name=" + id;
+    }
+
+    private void assertNull(String name, String msg) throws AxisFault {
+        if (name == null || "".equals(name)) {
+            handleException(msg);
+        }
+    }
+
+    private void assertNull(Object object, String msg) throws AxisFault {
+        if (object == null) {
+            handleException(msg);
+        }
+    }
+
+    private static void handleException(String msg) throws AxisFault {
+        log.error(msg);
+        throw new AxisFault(msg);
+    }
+
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsView.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsView.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/ConnectionsView.java	(revision 1502663)
@@ -0,0 +1,267 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import org.apache.axis2.AxisFault;
+
+import java.util.*;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * ConnectionsView MBean can be used to collect and monitor statistics on HTTP connections
+ * created by the NHTTP transport. Connection statistics can be divided into two categories,
+ * namely short term data and long term data. Short term data is related to the last 15
+ * minutes of execution and they are updated every minute. Long term data is related to
+ * the last 24 hours of execution and they get updated every 5 minutes.  In addition to the
+ * connection statistics this MBean also provides information on the request and response
+ * sizes received over the HTTP connections. All messages are divided into six categories
+ * based on their sizes and the resulting counts are made available as a table.
+ */
+public class ConnectionsView implements ConnectionsViewMBean {
+
+    private static final String PASS_THROUGH_CONNECTIONS = "PassThroughConnections";
+
+    // Bucket definitions
+    private static final int LESS_THAN_1K       = 0;
+    private static final int LESS_THAN_10K      = 1;
+    private static final int LESS_THAN_100K     = 2;
+    private static final int LESS_THAN_1M       = 3;
+    private static final int LESS_THAN_10M      = 4;
+    private static final int GREATER_THAN_10M   = 5;
+
+    private static final int SHORT_DATA_COLLECTION_PERIOD = 60;
+    private static final int LONG_DATA_COLLECTION_PERIOD = 60 * 5;
+
+    private static final int SAMPLES_PER_HOUR = (60 * 60)/LONG_DATA_COLLECTION_PERIOD;
+
+    private Queue<Integer> shortTermDataQueue = new LinkedList<Integer>();
+    private Queue<Integer> longTermDataQueue = new LinkedList<Integer>();
+
+    private AtomicInteger activeConnections = new AtomicInteger(0);
+    private AtomicInteger shortTermOpenedConnections = new AtomicInteger(0);
+    private AtomicInteger longTermOpenedConnections = new AtomicInteger(0);
+
+    // The array length must be equal to the number of buckets
+    private AtomicInteger[] requestSizeCounters = new AtomicInteger[6];
+    private AtomicInteger[] responseSizeCounters = new AtomicInteger[6];
+
+    private Date resetTime = Calendar.getInstance().getTime();
+
+    private ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
+
+    private String name;
+
+    public ConnectionsView(String name) throws AxisFault {
+        this.name = name;
+
+        initCounters(requestSizeCounters);
+        initCounters(responseSizeCounters);
+
+        Runnable task = new Runnable() {
+            public void run() {
+                // We only need historical data for the last 15 minutes
+                // Therefore no need to keep data older than that...
+                if (shortTermDataQueue.size() == 15) {
+                    shortTermDataQueue.remove();
+                }
+                shortTermDataQueue.offer(shortTermOpenedConnections.getAndSet(0));
+            }
+        };
+        // Delay the timer by 1 minute to prevent the task from starting immediately
+        scheduler.scheduleAtFixedRate(task, SHORT_DATA_COLLECTION_PERIOD,
+                SHORT_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);
+
+        Runnable longTermCollector = new Runnable() {
+            public void run() {
+                // We only need historical data for the last 24 hours
+                // Therefore no need to keep data older than that...
+                if (longTermDataQueue.size() == 24 * SAMPLES_PER_HOUR) {
+                    longTermDataQueue.remove();
+                }
+                longTermDataQueue.offer(longTermOpenedConnections.getAndSet(0));
+            }
+        };
+        scheduler.scheduleAtFixedRate(longTermCollector, LONG_DATA_COLLECTION_PERIOD,
+                LONG_DATA_COLLECTION_PERIOD, TimeUnit.SECONDS);
+
+        MBeanRegistrar.getInstance().registerMBean(this, PASS_THROUGH_CONNECTIONS, name);
+
+    }
+
+    public void destroy() {
+        MBeanRegistrar.getInstance().unRegisterMBean(PASS_THROUGH_CONNECTIONS, name);
+        scheduler.shutdownNow();
+    }
+
+    private void initCounters(AtomicInteger[] counters) {
+        for (int i = 0; i < counters.length; i++) {
+            if (counters[i] == null) {
+                counters[i] = new AtomicInteger(0);
+            } else {
+                counters[i].set(0);
+            }
+        }
+    }
+
+    protected void connected() {
+        activeConnections.incrementAndGet();
+        shortTermOpenedConnections.incrementAndGet();
+        longTermOpenedConnections.incrementAndGet();
+    }
+
+    protected void disconnected() {
+        activeConnections.decrementAndGet();
+    }
+
+    protected void notifyMessageSize(long size, boolean isRequest) {
+        // This logic gets executed for each and every transaction. For a typical
+        // mediation scenario this method will be called 4 times. Therefore I'm using
+        // arrays of integers to keep the overhead down to a minimum. Since the number
+        // of buckets is 6, this can be easily managed without using a slow data structure
+        // like a HashMap. This approach guarantees O(1) complexity.
+
+        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;
+
+        if (size < 1024) {
+            counters[LESS_THAN_1K].incrementAndGet();
+        } else if (size < 10240) {
+            counters[LESS_THAN_10K].incrementAndGet();
+        } else if (size < 102400) {
+            counters[LESS_THAN_100K].incrementAndGet();
+        } else if (size < 1048576) {
+            counters[LESS_THAN_1M].incrementAndGet();
+        } else if (size < 10485760) {
+            counters[LESS_THAN_10M].incrementAndGet();
+        } else {
+            counters[GREATER_THAN_10M].incrementAndGet();
+        }
+    }
+
+    public int getActiveConnections() {
+        return activeConnections.get();
+    }
+
+    public int getLastMinuteConnections() {
+        return getTotalConnections(1);
+    }
+
+    public int getLast5MinuteConnections() {
+        return getTotalConnections(5);
+    }
+
+    public int getLast15MinuteConnections() {
+        return getTotalConnections(15);
+    }
+
+    public int getLastHourConnections() {
+        return getTotalConnectionsByHour(1);
+    }
+
+    public int getLast8HourConnections() {
+        return getTotalConnectionsByHour(8);
+    }
+
+    public int getLast24HourConnections() {
+        return getTotalConnectionsByHour(24);
+    }
+
+    public Map getRequestSizesMap() {
+        return getCountersMap(requestSizeCounters);
+    }
+
+    public Map getResponseSizesMap() {
+        return getCountersMap(responseSizeCounters);
+    }
+
+    public Date getLastResetTime() {
+        return resetTime;
+    }
+
+    private Map<String,Integer> getCountersMap(AtomicInteger[] counters) {
+        // This ensures that keys are returned in the same order we insert them
+        // Provides better readability in the JMX consoles
+        Map<String,Integer> map = new LinkedHashMap<String,Integer>();
+        map.put("< 1 K", counters[LESS_THAN_1K].get());
+        map.put("< 10 K", counters[LESS_THAN_10K].get());
+        map.put("< 100 K", counters[LESS_THAN_100K].get());
+        map.put("< 1 M", counters[LESS_THAN_1M].get());
+        map.put("< 10 M", counters[LESS_THAN_10M].get());
+        map.put("> 10 M", counters[GREATER_THAN_10M].get());
+        return map;
+    }
+
+    public void reset() {
+        initCounters(requestSizeCounters);
+        initCounters(responseSizeCounters);
+        shortTermDataQueue.clear();
+        longTermDataQueue.clear();
+        resetTime = Calendar.getInstance().getTime();
+    }
+
+    /**
+     * Return the number of total connections opened during last 'n' munites
+     * of execution
+     *
+     * @param n Number of minutes in the execution history
+     * @return The number of connections opened
+     */
+    private int getTotalConnections(int n) {
+        int sum = 0;
+        Integer[] array = shortTermDataQueue.toArray(new Integer[shortTermDataQueue.size()]);
+
+        if (n > array.length) {
+            for (int i = 0; i < array.length; i++) {
+                sum += array[i];
+            }
+        } else {
+            for (int i = 0; i < n; i++) {
+                sum += array[array.length - 1 - i];
+            }
+        }
+        return sum;
+    }
+
+    /**
+     * Return the number of total connections opened during last 'n' hours
+     * of execution
+     *
+     * @param n Number of hours in the execution history
+     * @return The number of connections opened
+     */
+    private int getTotalConnectionsByHour(int n) {
+        int samples = n * SAMPLES_PER_HOUR;
+        int sum = 0;
+        Integer[] array = longTermDataQueue.toArray(new Integer[longTermDataQueue.size()]);
+
+        if (samples > array.length) {
+            for (int i = 0; i < array.length; i++) {
+                sum += array[i];
+            }
+        } else {
+            for (int i = 0; i < samples; i++) {
+                sum += array[array.length - 1 - i];
+            }
+        }
+        return sum;
+    }
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SSLTargetIOEventDispatch.java	(revision 1502663)
@@ -0,0 +1,80 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.impl.nio.reactor.SSLIOSession;
+import org.apache.http.impl.nio.reactor.SSLSetupHandler;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpClientIOTarget;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.passthru.logging.LoggingUtils;
+
+import javax.net.ssl.SSLContext;
+import java.net.InetSocketAddress;
+import java.util.Map;
+
+public class SSLTargetIOEventDispatch extends org.apache.http.impl.nio.ssl.SSLClientIOEventDispatch {
+
+    private Map<String, SSLContext> contextMap;
+
+    private HttpParams params = null;
+
+    public SSLTargetIOEventDispatch(NHttpClientHandler handler,
+                                    SSLContext sslcontext,
+                                    SSLSetupHandler sslHandler,
+                                    HttpParams params) {
+        super(handler, sslcontext, sslHandler, params);
+        this.params = params;
+    }
+
+    public void setContextMap(Map<String,SSLContext> contextMap) {
+        this.contextMap = contextMap;
+    }
+
+    @Override
+    protected SSLIOSession createSSLIOSession(IOSession session,
+                                              SSLContext sslcontext,
+                                              SSLSetupHandler sslHandler) {
+
+        InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();
+        String host = address.getHostName() + ":" + address.getPort();
+        SSLContext customContext = null;
+        if (contextMap != null) {
+            // See if there's a custom SSL profile configured for this server
+            customContext = contextMap.get(host);
+        }
+
+        if (customContext == null) {
+            customContext = sslcontext;
+        }
+
+        return super.createSSLIOSession(session, customContext, sslHandler);
+    }
+
+    @Override
+    protected NHttpClientIOTarget createConnection(IOSession session) {
+        session = LoggingUtils.decorate(session, "sslclient");
+        return LoggingUtils.createClientConnection(
+                session,
+                createHttpResponseFactory(),
+                createByteBufferAllocator(),
+                params);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/logging/LoggingNHttpTargetConnection.java	(revision 1502663)
@@ -0,0 +1,160 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.logging;
+
+import org.apache.commons.logging.Log;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.reactor.SessionOutputBuffer;
+import org.apache.http.nio.reactor.SessionInputBuffer;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.NHttpMessageWriter;
+import org.apache.http.nio.NHttpMessageParser;
+import org.apache.http.*;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
+import org.apache.http.params.HttpParams;
+
+import java.io.IOException;
+import java.nio.channels.ReadableByteChannel;
+
+public class LoggingNHttpTargetConnection extends DefaultNHttpClientConnection {
+    private final Log log;
+    private final Log headerLog;
+
+    public LoggingNHttpTargetConnection(
+            final Log log,
+            final Log headerlog,
+            final IOSession iosession,
+            final HttpResponseFactory responseFactory,
+            final ByteBufferAllocator allocator,
+            final HttpParams params) {
+        super(iosession, responseFactory, allocator, params);
+        this.log = log;
+        this.headerLog = headerlog;
+    }
+
+    @Override
+    public void close() throws IOException {
+        this.log.debug("Close connection");
+        super.close();
+    }
+
+    @Override
+    public void shutdown() throws IOException {
+        this.log.debug("Shutdown connection");
+        super.shutdown();
+    }
+
+    @Override
+    public void submitRequest(final HttpRequest request) throws IOException, HttpException {
+        if (this.log.isDebugEnabled()) {
+            this.log.debug("HTTP connection " + this + ": "  + request.getRequestLine().toString());
+        }
+        super.submitRequest(request);
+    }
+
+    @Override
+    public void consumeInput(final NHttpClientHandler handler) {
+        this.log.debug("Consume input");
+        super.consumeInput(handler);
+    }
+
+    @Override
+    public void produceOutput(final NHttpClientHandler handler) {
+        this.log.debug("Produce output");
+        super.produceOutput(handler);
+    }
+
+    @Override
+    protected NHttpMessageWriter createRequestWriter(
+            final SessionOutputBuffer buffer,
+            final HttpParams params) {
+        return new LoggingNHttpMessageWriter(
+                super.createRequestWriter(buffer, params));
+    }
+
+    @Override
+    protected NHttpMessageParser createResponseParser(
+            final SessionInputBuffer buffer,
+            final HttpResponseFactory responseFactory,
+            final HttpParams params) {
+        return new LoggingNHttpMessageParser(
+                super.createResponseParser(buffer, responseFactory, params));
+    }
+
+    class LoggingNHttpMessageWriter implements NHttpMessageWriter {
+
+        private final NHttpMessageWriter writer;
+
+        public LoggingNHttpMessageWriter(final NHttpMessageWriter writer) {
+            super();
+            this.writer = writer;
+        }
+
+        public void reset() {
+            this.writer.reset();
+        }
+
+        public void write(final HttpMessage message) throws IOException, HttpException {
+            if (message != null && headerLog.isDebugEnabled()) {
+                HttpRequest request = (HttpRequest) message;
+                headerLog.debug(">> " + request.getRequestLine().toString());
+                Header[] headers = request.getAllHeaders();
+                for (Header header : headers) {
+                    headerLog.debug(">> " + header.toString());
+                }
+            }
+            this.writer.write(message);
+        }
+
+    }
+
+    class LoggingNHttpMessageParser implements NHttpMessageParser {
+
+        private final NHttpMessageParser parser;
+
+        public LoggingNHttpMessageParser(final NHttpMessageParser parser) {
+            super();
+            this.parser = parser;
+        }
+
+        public void reset() {
+            this.parser.reset();
+        }
+
+        public int fillBuffer(final ReadableByteChannel channel) throws IOException {
+            return this.parser.fillBuffer(channel);
+        }
+
+        public HttpMessage parse() throws IOException, HttpException {
+            HttpMessage message = this.parser.parse();
+            if (message != null && headerLog.isDebugEnabled()) {
+                HttpResponse response = (HttpResponse) message;
+                headerLog.debug("<< " + response.getStatusLine().toString());
+                Header[] headers = response.getAllHeaders();
+                for (Header header : headers) {
+                    headerLog.debug("<< " + header.toString());
+                }
+            }
+            return message;
+        }
+
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceIOEventDispatch.java	(revision 1502663)
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru;
+
+import org.apache.http.impl.nio.DefaultServerIOEventDispatch;
+import org.apache.http.nio.NHttpServiceHandler;
+import org.apache.http.nio.NHttpServerIOTarget;
+import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.params.HttpParams;
+import org.apache.synapse.transport.passthru.logging.LoggingUtils;
+
+/**
+ * This is a factory for creating the logging sessions or non-logging sessions.
+ */
+public class SourceIOEventDispatch extends DefaultServerIOEventDispatch {
+
+    public SourceIOEventDispatch(final NHttpServiceHandler handler, final HttpParams params) {
+        super(LoggingUtils.decorate(handler), params);
+    }
+
+    @Override
+    protected NHttpServerIOTarget createConnection(IOSession session) {
+        session = LoggingUtils.decorate(session, "server");
+        return LoggingUtils.createServerConnection(
+                session,
+                createHttpRequestFactory(),
+                this.allocator,
+                this.params);
+    }
+}
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportViewMBean.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportViewMBean.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/TransportViewMBean.java	(revision 1502663)
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import java.util.Map;
+
+public interface TransportViewMBean {
+
+    // JMX Attributes
+    public long getMessagesReceived();
+    public long getFaultsReceiving();
+    public long getTimeoutsReceiving();
+    public long getMessagesSent();
+    public long getFaultsSending();
+    public long getTimeoutsSending();
+    public long getBytesReceived();
+    public long getBytesSent();
+    public long getMinSizeReceived();
+    public long getMaxSizeReceived();
+    public double getAvgSizeReceived();
+    public long getMinSizeSent();
+    public long getMaxSizeSent();
+    public double getAvgSizeSent();
+    public int  getActiveThreadCount();
+    public int getQueueSize();
+    public Map getResponseCodeTable();
+
+    // JMX Operations
+    public void start() throws Exception;
+    public void stop() throws Exception;
+    public void pause() throws Exception;
+    public void resume() throws Exception;
+    public void maintenenceShutdown(long seconds) throws Exception;
+
+    public void resetStatistics();
+    public long getLastResetTime();
+    public long getMetricsWindow();
+}
\ No newline at end of file
Index: java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/PassThroughTransportMetricsCollector.java
===================================================================
--- java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/PassThroughTransportMetricsCollector.java	(nonexistent)
+++ java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/jmx/PassThroughTransportMetricsCollector.java	(revision 1502663)
@@ -0,0 +1,75 @@
+/*
+*  Licensed to the Apache Software Foundation (ASF) under one
+*  or more contributor license agreements.  See the NOTICE file
+*  distributed with this work for additional information
+*  regarding copyright ownership.  The ASF licenses this file
+*  to you under the Apache License, Version 2.0 (the
+*  "License"); you may not use this file except in compliance
+*  with the License.  You may obtain a copy of the License at
+*
+*   http://www.apache.org/licenses/LICENSE-2.0
+*
+*  Unless required by applicable law or agreed to in writing,
+*  software distributed under the License is distributed on an
+*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+*  KIND, either express or implied.  See the License for the
+*  specific language governing permissions and limitations
+*  under the License.
+*/
+
+package org.apache.synapse.transport.passthru.jmx;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.transport.base.MetricsCollector;
+
+/**
+ * <p>This simple extension of the Axis2 transport MetricsCollector implementation,
+ * maintains a ConnectionsView instance, which is updated based on the events fired
+ * by the pass-through transport implementation. In addition to the usual events handled
+ * by the Axis2 MetricsCollector, this implementation handles two new events:</p>
+ * <ul>
+ *    <li>connected (this should get called whenever a new connection is created)</li>
+ *    <li>disconnected (this should get called whenever an existing connection is closed)</li>
+ * <ul>
+ * <p>These new events are used to update the ConnectionsView at runtime.</p>
+ */
+public class PassThroughTransportMetricsCollector extends MetricsCollector {
+
+    private ConnectionsView view;
+    private boolean listener;
+
+    public PassThroughTransportMetricsCollector(boolean listener, boolean isHttps)
+            throws AxisFault {
+        this.listener = listener;
+        String name = "http" + (isHttps ? "s" : "") + "-" + (listener ? "listener" : "sender");
+        this.view = new ConnectionsView(name);
+    }
+
+    public void destroy() {
+        view.destroy();
+    }
+
+    public void connected() {
+        view.connected();
+    }
+
+    public void disconnected() {
+        view.disconnected();
+    }
+
+    @Override
+    public void notifyReceivedMessageSize(long l) {
+        super.notifyReceivedMessageSize(l);
+        if (l > 0) {
+            view.notifyMessageSize(l, listener);
+        }
+    }
+
+    @Override
+    public void notifySentMessageSize(long l) {
+        super.notifySentMessageSize(l);
+        if (l > 0) {
+            view.notifyMessageSize(l, !listener);
+        }
+    }
+}
\ No newline at end of file
Index: java/modules/core/src/main/java/org/apache/synapse/core/relay/ServiceRequestEarlyBuilder.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/core/relay/ServiceRequestEarlyBuilder.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/core/relay/ServiceRequestEarlyBuilder.java	(revision 1502663)
@@ -0,0 +1,119 @@
+/*
+*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
+*
+*  WSO2 Inc. licenses this file to you under the Apache License,
+*  Version 2.0 (the "License"); you may not use this file except
+*  in compliance with the License.
+*  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+
+package org.apache.synapse.core.relay;
+
+import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.MessageContext;
+import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.description.AxisOperation;
+import org.apache.axis2.description.AxisService;
+import org.apache.axis2.engine.AxisConfiguration;
+import org.apache.axis2.handlers.AbstractHandler;
+import org.apache.axis2.wsdl.WSDLConstants;
+import org.apache.sandesha2.Sandesha2Constants;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.config.SynapseConfiguration;
+import org.apache.synapse.core.axis2.ProxyService;
+import org.apache.synapse.transport.passthru.util.RelayConstants;
+import org.apache.synapse.transport.passthru.util.RelayUtils;
+
+import javax.xml.stream.XMLStreamException;
+import java.io.IOException;
+
+public class ServiceRequestEarlyBuilder extends AbstractHandler {
+
+    public InvocationResponse invoke(MessageContext messageContext) throws AxisFault {
+        OperationContext operationContext = messageContext.getOperationContext();
+        if (operationContext == null) {
+            AxisService service = messageContext.getAxisService();
+            if (service != null) {
+                if ("__ADDR_ONLY__".equals(service.getName())) {
+                    // handling dual channel invocations
+                    return buildMessage(messageContext);
+                }
+
+                // Possible service mediation mode
+                AxisConfiguration axisConfiguration = messageContext.getConfigurationContext().
+                        getAxisConfiguration();
+                SynapseConfiguration synapseConfig = (SynapseConfiguration) axisConfiguration.getParameterValue(
+                        SynapseConstants.SYNAPSE_CONFIG);
+                ProxyService proxy = synapseConfig.getProxyService(service.getName());
+                if (proxy != null) {
+                    AxisOperation operation = messageContext.getAxisOperation();
+                    if (proxy.isModuleEngaged() || (operation == null && proxy.isWsdlPublished())) {
+                        // We have some Axis2 level processing to do (security, RM, addressing etc)
+                        // or we have more dispatching left to do
+                        return buildMessage(messageContext);
+                    } else if (operation == null && !proxy.isWsdlPublished()) {
+                        operation = service.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);
+                    }
+
+                    if (operation != null) {
+                        return invokeMessageReceiver(messageContext, operation);
+                    }
+                }
+            } else {
+                // Message mediation mode
+                service = messageContext.getConfigurationContext().
+                        getAxisConfiguration().getService(SynapseConstants.SYNAPSE_SERVICE_NAME);
+                messageContext.setAxisService(service);
+                AxisOperation operation = service.getOperation(SynapseConstants.SYNAPSE_OPERATION_NAME);
+                messageContext.setAxisOperation(operation);
+                return invokeMessageReceiver(messageContext, operation);
+            }
+        } else {
+            MessageContext outMessage = operationContext.getMessageContext(
+                    WSDLConstants.MESSAGE_LABEL_OUT_VALUE);
+            if (outMessage != null && Boolean.TRUE.equals(
+                    outMessage.getProperty(RelayConstants.FORCE_RESPONSE_EARLY_BUILD))) {
+                return buildMessage(messageContext);
+            }
+
+            AxisOperation operation = messageContext.getAxisOperation();
+            if (operation != null && operation.getName().getLocalPart().
+                    startsWith(Sandesha2Constants.SANDESHA_OP_PREFIX)) {
+                return buildMessage(messageContext);
+            }
+        }
+
+        return InvocationResponse.CONTINUE;
+    }
+
+    private InvocationResponse invokeMessageReceiver(MessageContext messageContext,
+                                AxisOperation operation) throws AxisFault {
+        messageContext.getConfigurationContext().
+                fillServiceContextAndServiceGroupContext(messageContext);
+        OperationContext opContext = operation.findOperationContext(messageContext,
+                messageContext.getServiceContext());
+        messageContext.setOperationContext(opContext);
+        operation.getMessageReceiver().receive(messageContext);
+        return InvocationResponse.ABORT;
+    }
+
+    private InvocationResponse buildMessage(MessageContext messageContext) throws AxisFault {
+        try {
+            RelayUtils.buildMessage(messageContext, true);
+        } catch (IOException e) {
+            throw new AxisFault("I/O error while reading from the input stream");
+        } catch (XMLStreamException e) {
+            throw new AxisFault("Unexpected error while parsing the XML content");
+        }
+        return InvocationResponse.CONTINUE;
+    }
+}
\ No newline at end of file
Index: java/repository/conf/axis2.xml
===================================================================
--- java/repository/conf/axis2.xml	(revision 1502662)
+++ java/repository/conf/axis2.xml	(revision 1502663)
@@ -130,13 +130,13 @@
     <!--format  serialization in Axis2. These message formats are expected to be resolved based on the content type. -->
     <messageFormatters>
         <messageFormatter contentType="application/x-www-form-urlencoded"
-                          class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                          class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="multipart/form-data"
-                          class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                          class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="application/xml"
-                          class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                          class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
         <messageFormatter contentType="text/xml"
-                          class="org.apache.synapse.core.relay.ExpandingMessageFormatter"/>
+                          class="org.apache.synapse.transport.passthru.util.ExpandingMessageFormatter"/>
 
         <!--messageFormatter contentType="application/x-www-form-urlencoded"
                          class="org.apache.axis2.transport.http.XFormURLEncodedFormatter"/>
@@ -160,13 +160,13 @@
     <!--formats in Axis2. These message formats are expected to be resolved based on the content type. -->
     <messageBuilders>
         <messageBuilder contentType="application/xml"
-                        class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                        class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="application/x-www-form-urlencoded"
-                        class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                        class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="multipart/form-data"
-                        class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                        class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
         <messageBuilder contentType="text/xml"
-                        class="org.apache.synapse.core.relay.BinaryRelayBuilder"/>
+                        class="org.apache.synapse.transport.passthru.util.BinaryRelayBuilder"/>
 
         <!--messageBuilder contentType="application/xml"
                          class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
@@ -507,6 +507,7 @@
                      class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
                 <order phase="Transport"/>
             </handler>
+            <handler name="EarlyBuilder" class="org.apache.synapse.core.relay.ServiceRequestEarlyBuilder"/>
         </phase>
         <phase name="Addressing">
             <handler name="AddressingBasedDispatcher"
Index: java/repository/conf/axis2_server.xml
===================================================================
--- java/repository/conf/axis2_server.xml	(nonexistent)
+++ java/repository/conf/axis2_server.xml	(revision 1502663)
@@ -0,0 +1,573 @@
+<!--
+  ~  Licensed to the Apache Software Foundation (ASF) under one
+  ~  or more contributor license agreements.  See the NOTICE file
+  ~  distributed with this work for additional information
+  ~  regarding copyright ownership.  The ASF licenses this file
+  ~  to you under the Apache License, Version 2.0 (the
+  ~  "License"); you may not use this file except in compliance
+  ~  with the License.  You may obtain a copy of the License at
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing,
+  ~  software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~  KIND, either express or implied.  See the License for the
+  ~  specific language governing permissions and limitations
+  ~  under the License.
+  -->
+
+<axisconfig name="AxisJava2.0">
+    <!-- ================================================= -->
+    <!-- Parameters -->
+    <!-- ================================================= -->
+
+    <!-- WARNING: Hot deployment is turned on by default, but it is highly recommended to set this to false
+            on production environments, unless you really want to use hot deployment in production -->
+    <parameter name="hotdeployment">true</parameter>
+    <parameter name="hotupdate">true</parameter>
+    <parameter name="enableMTOM">false</parameter>
+    <parameter name="enableSwA">false</parameter>
+
+    <!--Uncomment if you want to enable file caching for attachments -->
+    <!--parameter name="cacheAttachments">true</parameter>
+    <parameter name="attachmentDIR"></parameter>
+    <parameter name="sizeThreshold">4000</parameter-->
+
+    <!--This will give out the timout of the configuration contexts, in milliseconds-->
+    <parameter name="ConfigContextTimeoutInterval">30000</parameter>
+
+    <!--During a fault, stacktrace can be sent with the fault message. The following flag will control -->
+    <!--that behavior.-->
+    <parameter name="sendStacktraceDetailsWithFaults">false</parameter>
+
+    <!--If there aren't any information available to find out the fault reason, we set the message of the exception-->
+    <!--as the faultreason/Reason. But when a fault is thrown from a service or some where, it will be -->
+    <!--wrapped by different levels. Due to this the initial exception message can be lost. If this flag-->
+    <!--is set, then Axis2 tries to get the first exception and set its message as the faultreason/Reason.-->
+    <parameter name="DrillDownToRootCauseForFaultReason">false</parameter>
+
+    <parameter name="userName">admin</parameter>
+    <parameter name="password">axis2</parameter>
+
+    <!--To override repository/services you need to uncomment following parameter and value SHOULD be absolute file path.-->
+    <!--ServicesDirectory only works on the following cases-->
+    <!---File based configurator and in that case the value should be a file URL (http:// not allowed)-->
+    <!---When creating URL Based configurator with URL "file://"  -->
+    <!--- War based configurator with expanded case , -->
+
+    <!--All the other scenarios it will be ignored.-->
+    <!--<parameter name="ServicesDirectory">service</parameter>-->
+    <!--To override repository/modules you need to uncomment following parameter and value SHOULD be absolute file path-->
+    <!--<parameter name="ModulesDirectory">modules</parameter>-->
+
+
+
+    <!--Following params will set the proper context paths for invocations. All the endpoints will have a commons context-->
+    <!--root which can configured using the following contextRoot parameter-->
+    <parameter name="contextRoot">/</parameter>
+
+    <!--Our HTTP endpoints can handle both REST and SOAP. Following parameters can be used to distinguiush those endpoints-->
+    <!--In case of a servlet, if you change this you have to manually change the settings of your servlet container to map this -->
+    <!--context path to proper Axis2 servlets-->
+    <parameter name="servicePath">services</parameter>
+    <parameter name="restPath">rest</parameter>
+
+    <!-- Following parameter will completely disable REST handling in Axis2-->
+    <parameter name="disableREST" locked="true">false</parameter>
+
+    <!-- Extension deployer
+         ***** Uncomment the following line to enable (hot) deployment of Synapse extensions (mediators and startups) ***** -->
+    <!--<deployer extension="xar" directory="extensions" class="org.apache.synapse.deployers.ExtensionDeployer"/>-->
+
+    <!-- WARNING: Synapse Artifact Deployers, it is highly recommended to comment out these deployers in production
+                unless you really want to use hot deployment/update -->
+    <deployer extension="xml" directory="conf/synapse-config/sequences" class="org.apache.synapse.deployers.SequenceDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/endpoints" class="org.apache.synapse.deployers.EndpointDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/local-entries" class="org.apache.synapse.deployers.LocalEntryDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/proxy-services" class="org.apache.synapse.deployers.ProxyServiceDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/event-sources" class="org.apache.synapse.deployers.EventSourceDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/tasks" class="org.apache.synapse.deployers.TaskDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/priority-executors" class="org.apache.synapse.deployers.PriorityExecutorDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/templates" class="org.apache.synapse.deployers.TemplateDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/message-stores" class="org.apache.synapse.deployers.MessageStoreDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/message-processors" class="org.apache.synapse.deployers.MessageProcessorDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/api" class="org.apache.synapse.deployers.APIDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/imports" class="org.apache.synapse.deployers.ImportDeployer"/>
+    <deployer extension="zip" directory="conf/synapse-libs" class="org.apache.synapse.deployers.LibraryArtifactDeployer"/>
+
+    <!-- Following parameter will set the host name for the epr-->
+    <!--<parameter name="hostname" locked="true">myhost.com</parameter>-->
+
+    <!-- If you have a frontend host which exposes this webservice using a different public URL  -->
+    <!-- use this parameter to override autodetected url -->
+    <!--<parameter name="httpFrontendHostUrl">https://someotherhost/context</parameter>-->
+
+
+    <!--    The way of adding listener to the system-->
+    <!--    <listener class="org.apache.axis2.ObserverIMPL">-->
+    <!--        <parameter name="RSS_URL">http://127.0.0.1/rss</parameter>-->
+    <!--    </listener>-->
+
+    <!-- ================================================= -->
+    <!-- Message Receivers -->
+    <!-- ================================================= -->
+    <!--This is the deafult MessageReceiver for the system , if you want to have MessageReceivers for -->
+    <!--all the other MEP implement it and add the correct entry to here , so that you can refer from-->
+    <!--any operation -->
+    <!--Note : You can ovrride this for a particular service by adding the same element with your requirement-->
+    <messageReceivers>
+        <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-only"
+                         class="org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2004/08/wsdl/in-out"
+                         class="org.apache.axis2.receivers.RawXMLINOutMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2006/01/wsdl/in-only"
+                         class="org.apache.axis2.receivers.RawXMLINOnlyMessageReceiver"/>
+        <messageReceiver mep="http://www.w3.org/2006/01/wsdl/in-out"
+                         class="org.apache.axis2.receivers.RawXMLINOutMessageReceiver"/>
+    </messageReceivers>
+
+    <!-- ================================================= -->
+    <!-- Message Formatter -->
+    <!-- ================================================= -->
+    <!--Following content type to message formatter mapping can be used to implement support for different message -->
+    <!--format  serialization in Axis2. These message formats are expected to be resolved based on the content type. -->
+    <messageFormatters>
+        <messageFormatter contentType="application/x-www-form-urlencoded"
+                         class="org.apache.axis2.transport.http.XFormURLEncodedFormatter"/>
+        <messageFormatter contentType="multipart/form-data"
+                         class="org.apache.axis2.transport.http.MultipartFormDataFormatter"/>
+        <messageFormatter contentType="application/xml"
+                         class="org.apache.axis2.transport.http.ApplicationXMLFormatter"/>
+        <!--<messageFormatter contentType="x-application/hessian"
+                         class="org.apache.synapse.format.hessian.HessianMessageFormatter"/>-->
+        <!--<messageFormatter contentType=""
+                         class="org.apache.synapse.format.hessian.HessianMessageFormatter"/>-->
+        <!--<messageFormatter contentType="application/json"
+                         class="org.apache.axis2.json.JSONMessageFormatter"/>-->
+
+    </messageFormatters>
+
+    <!-- ================================================= -->
+    <!-- Message Builders -->
+    <!-- ================================================= -->
+    <!--Following content type to builder mapping can be used to implement support for different message -->
+    <!--formats in Axis2. These message formats are expected to be resolved based on the content type. -->
+    <messageBuilders>
+        <messageBuilder contentType="application/xml"
+                         class="org.apache.axis2.builder.ApplicationXMLBuilder"/>
+        <messageBuilder contentType="application/x-www-form-urlencoded"
+                         class="org.apache.axis2.builder.XFormURLEncodedBuilder"/>
+        <messageBuilder contentType="multipart/form-data"
+                         class="org.apache.axis2.builder.MultipartFormDataBuilder"/>
+        <!--<messageBuilder contentType="x-application/hessian"
+                         class="org.apache.synapse.format.hessian.HessianMessageBuilder"/>-->
+        <!--<messageBuilder contentType=""
+                         class="org.apache.synapse.format.hessian.HessianMessageBuilder"/>-->
+        <!--<messageBuilder contentType="application/json"
+                         class="org.apache.axis2.json.JSONOMBuilder"/>-->
+    </messageBuilders>
+
+    <!-- ================================================= -->
+    <!-- Transport Ins -->
+    <!-- ================================================= -->
+    <!-- the non blocking http transport based on HttpCore + NIO extensions -->
+    <transportReceiver name="http" class="org.apache.synapse.transport.nhttp.HttpCoreNIOListener">
+    	<parameter name="port">8280</parameter>
+    	<parameter name="non-blocking">true</parameter>
+        <!--parameter name="bind-address" locked="false">hostname or IP address</parameter-->
+        <!--parameter name="WSDLEPRPrefix" locked="false">https://apachehost:port/somepath</parameter-->
+        <!-- paramter name="priorityConfigFile" locked="false">location of priority configuration file<parameter-->
+    </transportReceiver>
+
+    <!-- the non blocking https transport based on HttpCore + SSL-NIO extensions -->
+    <transportReceiver name="https" class="org.apache.synapse.transport.nhttp.HttpCoreNIOSSLListener">
+    	<parameter name="port" locked="false">8243</parameter>
+        <!--parameter name="bind-address" locked="false">hostname or IP address</parameter-->
+        <!--parameter name="WSDLEPRPrefix" locked="false">http://apachehost:port/somepath</parameter-->
+        <parameter name="non-blocking" locked="false">true</parameter>
+        <parameter name="keystore" locked="false">
+            <KeyStore>
+                <Location>lib/identity.jks</Location>
+                <Type>JKS</Type>
+                <Password>password</Password>
+                <KeyPassword>password</KeyPassword>
+            </KeyStore>
+        </parameter>
+        <parameter name="truststore" locked="false">
+            <TrustStore>
+                <Location>lib/trust.jks</Location>
+                <Type>JKS</Type>
+                <Password>password</Password>
+            </TrustStore>
+        </parameter>
+        <!--<parameter name="SSLVerifyClient">require</parameter>
+            supports optional|require or defaults to none -->
+    </transportReceiver>
+
+    <!--Uncomment this and configure as appropriate for JMS transport support, after setting up your JMS environment (e.g. ActiveMQ)
+    <transportReceiver name="jms" class="org.apache.axis2.transport.jms.JMSListener">
+        <parameter name="myTopicConnectionFactory">
+        	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+        	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+        	<parameter name="transport.jms.ConnectionFactoryJNDIName">TopicConnectionFactory</parameter>
+		<parameter name="transport.jms.ConnectionFactoryType" locked="false">topic</parameter>
+        </parameter>
+
+        <parameter name="myQueueConnectionFactory">
+        	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+        	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+        	<parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
+		<parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
+        </parameter>
+
+        <parameter name="default">
+        	<parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+        	<parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+        	<parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
+		<parameter name="transport.jms.ConnectionFactoryType" locked="false">queue</parameter>
+        </parameter>
+    </transportReceiver>-->
+
+    <transportReceiver name="vfs" class="org.apache.synapse.transport.vfs.VFSTransportListener"/>
+
+    <transportReceiver name="mailto" class="org.apache.axis2.transport.mail.MailTransportListener">
+        <!-- configure any optional POP3/IMAP properties
+        check com.sun.mail.pop3 and com.sun.mail.imap package documentation for more details-->
+    </transportReceiver>
+
+     <!--Uncomment this for FIX transport support
+    <transportReceiver name="fix" class="org.apache.synapse.transport.fix.FIXTransportListener">
+        <parameter name="non-blocking">true</parameter>
+    </transportReceiver>-->
+
+    <!--Uncomment this for TCP transport support
+    <transportReceiver name="tcp" class="org.apache.axis2.transport.tcp.TCPServer">
+        <parameter name="port">6060</parameter>
+    </transportReceiver>-->
+
+    <!--Uncomment this for UDP transport support
+    <transportReceiver name="udp" class="org.apache.axis2.transport.udp.UDPListener"/>-->
+
+    <!-- ================================================= -->
+    <!-- Transport Outs -->
+    <!-- ================================================= -->
+
+    <transportSender name="http"  class="org.apache.synapse.transport.nhttp.HttpCoreNIOSender">
+        <parameter name="non-blocking" locked="false">true</parameter>
+        <parameter name="warnOnHTTP500" locked="false">*</parameter>
+        <!--parameter name="http.proxyHost" locked="false">localhost</parameter>
+        <parameter name="http.proxyPort" locked="false">3128</parameter>
+        <parameter name="http.nonProxyHosts" locked="false">localhost|moon|sun</parameter-->
+    </transportSender>
+    <transportSender name="https" class="org.apache.synapse.transport.nhttp.HttpCoreNIOSSLSender">
+        <parameter name="non-blocking" locked="false">true</parameter>
+        <parameter name="warnOnHTTP500" locked="false">*</parameter>
+        <parameter name="keystore" locked="false">
+            <KeyStore>
+                <Location>lib/identity.jks</Location>
+                <Type>JKS</Type>
+                <Password>password</Password>
+                <KeyPassword>password</KeyPassword>
+            </KeyStore>
+        </parameter>
+        <parameter name="truststore" locked="false">
+            <TrustStore>
+                <Location>lib/trust.jks</Location>
+                <Type>JKS</Type>
+                <Password>password</Password>
+            </TrustStore>
+        </parameter>
+        <!--<parameter name="HostnameVerifier">DefaultAndLocalhost</parameter>
+            supports Strict|AllowAll|DefaultAndLocalhost or the default if none specified -->
+    </transportSender>
+
+    <!-- Uncomment Transport sender for the non blocking local transport-->
+    <!--transportSender name="local" class="org.apache.axis2.transport.local.NonBlockingLocalTransportSender"/-->
+
+    <transportSender name="jms" class="org.apache.axis2.transport.jms.JMSSender">
+        <!-- uncomment this and configure to use connection pools for sending messages
+        <parameter name="myTopicConnectionFactory">
+            <parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+            <parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+            <parameter name="transport.jms.ConnectionFactoryJNDIName">TopicConnectionFactory</parameter>
+        </parameter>
+
+        <parameter name="myQueueConnectionFactory">
+            <parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+            <parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+            <parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
+        </parameter>
+
+        <parameter name="default">
+            <parameter name="java.naming.factory.initial">org.apache.activemq.jndi.ActiveMQInitialContextFactory</parameter>
+            <parameter name="java.naming.provider.url">tcp://localhost:61616</parameter>
+            <parameter name="transport.jms.ConnectionFactoryJNDIName">QueueConnectionFactory</parameter>
+        </parameter> -->
+    </transportSender>
+
+    <transportSender name="vfs" class="org.apache.synapse.transport.vfs.VFSTransportSender"/>
+
+    <!-- Uncomment and configure the SMTP server information
+    check com.sun.mail.smtp package documentation for descriptions of properties
+    <transportSender name="mailto" class="org.apache.axis2.transport.mail.MailTransportSender">
+        <parameter name="mail.smtp.host">smtp.gmail.com</parameter>
+        <parameter name="mail.smtp.port">587</parameter>
+        <parameter name="mail.smtp.starttls.enable">true</parameter>
+        <parameter name="mail.smtp.auth">true</parameter>
+        <parameter name="mail.smtp.user">synapse.demo.0</parameter>
+        <parameter name="mail.smtp.password">mailpassword</parameter>
+        <parameter name="mail.smtp.from">synapse.demo.0@gmail.com</parameter>
+    </transportSender>-->
+
+    <!--Uncomment this for FIX transport support
+    <transportSender name="fix" class="org.apache.synapse.transport.fix.FIXTransportSender">
+	    <parameter name="non-blocking">true</parameter>
+    </transportSender>-->
+
+    <!--Uncomment this for TCP transport support
+    <transportSender name="tcp" class="org.apache.axis2.transport.tcp.TCPTransportSender"/>-->
+
+    <!--Uncomment this for UDP transport support
+    <transportSender name="udp" class="org.apache.axis2.transport.udp.UDPSender"/>-->
+
+    <!-- ================================================= -->
+    <!-- Global Modules  -->
+    <!-- ================================================= -->
+    <!-- Comment this to disable Addressing -->
+    <module ref="addressing"/>
+
+    <!--Configuring module , providing parameters for modules whether they refer or not-->
+    <!--<moduleConfig name="addressing">-->
+    <!--<parameter name="addressingPara">N/A</parameter>-->
+    <!--</moduleConfig>-->
+
+    <!-- ================================================= -->
+    <!--                  Clustering                       -->
+    <!-- ================================================= -->
+    <!-- Configure the following for preparing Synapse to a clustered environment -->
+    <clustering class="org.apache.axis2.clustering.tribes.TribesClusteringAgent" enable="false">
+
+        <!--
+           This parameter indicates whther the cluster has to be automatically initalized
+           when the AxisConfiguration is built. If set to "true" the initialization will not be
+           done at that stage, and some other party will have to explictly initialize the cluster.
+        -->
+        <parameter name="AvoidInitiation">false</parameter>
+
+        <!--
+           The membership scheme used in this setup. The only values supported at the moment are
+           "multicast" and "wka"
+
+           1. multicast - membership is automatically discovered using multicasting
+           2. wka - Well-Known Address based multicasting. Membership is discovered with the help
+                    of one or more nodes running at a Well-Known Address. New members joining a
+                    cluster will first connect to a well-known node, register with the well-known node
+                    and get the membership list from it. When new members join, one of the well-known
+                    nodes will notify the others in the group. When a member leaves the cluster or
+                    is deemed to have left the cluster, it will be detected by the Group Membership
+                    Service (GMS) using a TCP ping mechanism.
+        -->
+        <parameter name="membershipScheme">multicast</parameter>
+
+        <!--
+         The clustering domain/group. Nodes in the same group will belong to the same multicast
+         domain. There will not be interference between nodes in different groups.
+        -->
+        <parameter name="domain">apache.synapse.domain</parameter>
+
+        <!--
+           When a Web service request is received, and processed, before the response is sent to the
+           client, should we update the states of all members in the cluster? If the value of
+           this parameter is set to "true", the response to the client will be sent only after
+           all the members have been updated. Obviously, this can be time consuming. In some cases,
+           such this overhead may not be acceptable, in which case the value of this parameter
+           should be set to "false"
+        -->
+        <parameter name="synchronizeAll">true</parameter>
+
+        <!--
+          The maximum number of times we need to retry to send a message to a particular node
+          before giving up and considering that node to be faulty
+        -->
+        <parameter name="maxRetries">10</parameter>
+
+        <!-- The multicast address to be used -->
+        <parameter name="mcastAddress">228.0.0.4</parameter>
+
+        <!-- The multicast port to be used -->
+        <parameter name="mcastPort">45564</parameter>
+
+        <!-- The frequency of sending membership multicast messages (in ms) -->
+        <parameter name="mcastFrequency">500</parameter>
+
+        <!-- The time interval within which if a member does not respond, the member will be
+         deemed to have left the group (in ms)
+         -->
+        <parameter name="memberDropTime">3000</parameter>
+
+        <!--
+           The IP address of the network interface to which the multicasting has to be bound to.
+           Multicasting would be done using this interface.
+        -->
+        <parameter name="mcastBindAddress">127.0.0.1</parameter>
+
+        <!-- The host name or IP address of this member -->
+        <parameter name="localMemberHost">127.0.0.1</parameter>
+
+        <!--
+        The TCP port used by this member. This is the port through which other nodes will
+        contact this member
+         -->
+        <parameter name="localMemberPort">4000</parameter>
+
+        <!--
+           The list of static or well-known members. These entries will only be valid if the
+           "membershipScheme" above is set to "wka"
+        -->
+        <members>
+            <member>
+                <hostName>127.0.0.1</hostName>
+                <port>4000</port>
+            </member>
+            <member>
+                <hostName>127.0.0.1</hostName>
+                <port>4001</port>
+            </member>
+        </members>
+
+        <!--
+        Enable the groupManagement entry if you need to run this node as a cluster manager.
+        Multiple application domains with different GroupManagementAgent implementations
+        can be defined in this section.
+        -->
+        <groupManagement enable="false">
+            <applicationDomain name="apache.axis2.app.domain"
+                               description="Axis2 group"
+                               agent="org.apache.axis2.clustering.management.DefaultGroupManagementAgent"/>
+        </groupManagement>
+
+        <!--
+           This interface is responsible for handling context replication. The property changes in
+           the Axis2 context hierarchy in this node, are propagated to all other nodes in the cluster.
+
+           The "excludes" patterns can be used to specify the prefixes (e.g. local_*) or
+           suffixes (e.g. *_local) of the properties to be excluded from replication. The pattern
+           "*" indicates that all properties in a particular context should not be replicated.
+
+            The "enable" attribute indicates whether context replication has been enabled
+        -->
+        <contextManager class="org.apache.axis2.clustering.context.DefaultContextManager"
+                         enable="false">
+            <listener class="org.apache.axis2.clustering.context.DefaultContextManagerListener"/>
+            <replication>
+                <defaults>
+                    <exclude name="local_*"/>
+                    <exclude name="LOCAL_*"/>
+                </defaults>
+                <context class="org.apache.axis2.context.ConfigurationContext">
+                    <exclude name="UseAsyncOperations"/>
+                    <exclude name="SequencePropertyBeanMap"/>
+                </context>
+                <context class="org.apache.axis2.context.ServiceGroupContext">
+                    <exclude name="my.sandesha.*"/>
+                </context>
+                <context class="org.apache.axis2.context.ServiceContext">
+                    <exclude name="my.sandesha.*"/>
+                </context>
+            </replication>
+        </contextManager>
+    </clustering>
+
+    <!-- ================================================= -->
+    <!-- Phases  -->
+    <!-- ================================================= -->
+    <phaseOrder type="InFlow">
+        <!--  System pre defined phases       -->
+        <phase name="Transport">
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher">
+                <order phase="Transport"/>
+            </handler>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher">
+                <order phase="Transport"/>
+            </handler>
+        </phase>
+        <phase name="Addressing">
+             <handler name="AddressingBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
+                 <order phase="Addressing"/>
+            </handler>
+        </phase>
+        <phase name="Security"/>
+        <phase name="PreDispatch"/>
+        <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
+            <handler name="CustomURIBasedDispatcher"
+                     class="org.apache.synapse.core.axis2.CustomURIBasedDispatcher"/>
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
+            <handler name="RequestURIOperationDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
+            <handler name="SOAPMessageBodyBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
+
+            <handler name="HTTPLocationBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
+        </phase>
+        <phase name="RMPhase"/>
+        <!--  System predefined phases       -->
+        <!--   After Postdispatch phase module author or service author can add any phase he want      -->
+        <phase name="OperationInPhase"/>
+        <phase name="soapmonitorPhase"/>
+    </phaseOrder>
+    <phaseOrder type="OutFlow">
+        <!--      user can add his own phases to this area  -->
+        <phase name="soapmonitorPhase"/>
+        <phase name="OperationOutPhase"/>
+        <!--system predefined phase-->
+        <!--these phase will run irrespective of the service-->
+        <phase name="RMPhase"/>
+        <phase name="PolicyDetermination"/>
+        <phase name="MessageOut"/>
+        <phase name="Security"/>
+    </phaseOrder>
+    <phaseOrder type="InFaultFlow">
+        <phase name="Addressing">
+             <handler name="AddressingBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.AddressingBasedDispatcher">
+                 <order phase="Addressing"/>
+            </handler>
+        </phase>
+        <phase name="Security"/>
+        <phase name="PreDispatch"/>
+        <phase name="Dispatch" class="org.apache.axis2.engine.DispatchPhase">
+            <handler name="RequestURIBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIBasedDispatcher"/>
+            <handler name="SOAPActionBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPActionBasedDispatcher"/>
+            <handler name="RequestURIOperationDispatcher"
+                     class="org.apache.axis2.dispatchers.RequestURIOperationDispatcher"/>
+            <handler name="SOAPMessageBodyBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.SOAPMessageBodyBasedDispatcher"/>
+
+            <handler name="HTTPLocationBasedDispatcher"
+                     class="org.apache.axis2.dispatchers.HTTPLocationBasedDispatcher"/>
+        </phase>
+        <phase name="RMPhase"/>
+        <!--      user can add his own phases to this area  -->
+        <phase name="OperationInFaultPhase"/>
+        <phase name="soapmonitorPhase"/>
+    </phaseOrder>
+    <phaseOrder type="OutFaultFlow">
+        <!--      user can add his own phases to this area  -->
+        <phase name="soapmonitorPhase"/>
+        <phase name="OperationOutFaultPhase"/>
+        <phase name="RMPhase"/>
+        <phase name="PolicyDetermination"/>
+        <phase name="MessageOut"/>
+        <phase name="Security"/>
+    </phaseOrder>
+</axisconfig>
\ No newline at end of file
Index: java/pom.xml
===================================================================
--- java/pom.xml	(revision 1502662)
+++ java/pom.xml	(revision 1502663)
@@ -1048,7 +1048,7 @@
         <module>modules/distribution</module>
         <module>modules/packaging/package-skeleton</module>
         <module>modules/packaging/package-archetype</module>
-        <module>modules/integration</module>
+        <!--module>modules/integration</module-->
 	<module>modules/documentation</module>
     </modules>
 
-*-*-*-
Message: Adding the fixes for SYNAPSE-920. Temporarily disabled the integration tests.
-*-*-*-
When: 2013-07-12 15:25:40 -0400 
-*-*-*-
Who: hiranya
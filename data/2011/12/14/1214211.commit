Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APISerializer.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APISerializer.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APISerializer.java	(revision 1214211)
@@ -0,0 +1,63 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.config.xml.rest;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.rest.API;
+import org.apache.synapse.rest.Handler;
+import org.apache.synapse.rest.Resource;
+
+public class APISerializer {
+
+    private static final OMFactory fac = OMAbstractFactory.getOMFactory();
+
+    public static OMElement serializeAPI(API api) {
+        OMElement apiElt = fac.createOMElement("api", SynapseConstants.SYNAPSE_OMNAMESPACE);
+        apiElt.addAttribute("name", api.getName(), null);
+        apiElt.addAttribute("context", api.getContext(), null);
+        if (api.getHost() != null) {
+            apiElt.addAttribute("hostname", api.getHost(), null);
+        }
+        if (api.getPort() != -1) {
+            apiElt.addAttribute("port", String.valueOf(api.getPort()), null);
+        }
+
+        Resource[] resources = api.getResources();
+        for (Resource r : resources) {
+            OMElement resourceElt = ResourceSerializer.serializeResource(r);
+            apiElt.addChild(resourceElt);
+        }
+
+        Handler[] handlers = api.getHandlers();
+        if (handlers.length > 0) {
+            OMElement handlersElt = fac.createOMElement("handlers", SynapseConstants.SYNAPSE_OMNAMESPACE);
+            for (Handler handler : handlers) {
+                OMElement handlerElt = fac.createOMElement("handler", SynapseConstants.SYNAPSE_OMNAMESPACE);
+                handlerElt.addAttribute("class", handler.getClass().getName(), null);
+                handlersElt.addChild(handlerElt);
+            }
+            apiElt.addChild(handlersElt);
+        }
+        return apiElt;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationFactory.java	(revision 1214211)
@@ -27,6 +27,7 @@
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.config.xml.endpoints.TemplateFactory;
+import org.apache.synapse.config.xml.rest.APIFactory;
 import org.apache.synapse.endpoints.Template;
 import org.apache.synapse.mediators.template.TemplateMediator;
 import org.apache.synapse.message.processors.MessageProcessor;
@@ -43,6 +44,7 @@
 import org.apache.synapse.eventing.SynapseEventSource;
 import org.apache.synapse.registry.Registry;
 import org.apache.axis2.AxisFault;
+import org.apache.synapse.rest.API;
 
 import javax.xml.namespace.QName;
 import java.util.Iterator;
@@ -95,6 +97,8 @@
                     defineMessageProcessor(config, elt, properties);
                 } else if (StartupFinder.getInstance().isStartup(elt.getQName())) {
                     defineStartup(config, elt, properties);
+                } else if (XMLConfigConstants.API_ELT.equals(elt.getQName())) {
+                    defineAPI(config, elt);
                 } else if (XMLConfigConstants.DESCRIPTION_ELT.equals(elt.getQName())) {
                     config.setDescription(elt.getText());
                 } else {
@@ -315,6 +319,11 @@
         }
     }
 
+    public static void defineAPI(SynapseConfiguration config, OMElement elem) {
+        API api = APIFactory.createAPI(elem);
+        config.addAPI(api.getName(), api);
+    }
+
     private static void handleException(String msg) {
         log.error(msg);
         throw new SynapseException(msg);
Index: java/modules/core/src/main/java/org/apache/synapse/rest/AbstractRESTProcessor.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/AbstractRESTProcessor.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/AbstractRESTProcessor.java	(revision 1214211)
@@ -0,0 +1,66 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseException;
+
+/**
+ * Abstract representation of an entity that can process REST messages. The caller can
+ * first invoke the canProcess method of the processor to validate whether this processor
+ * can process the given request or not.
+ */
+public abstract class AbstractRESTProcessor {
+
+    protected Log log = LogFactory.getLog(getClass());
+
+    protected String name;
+
+    public AbstractRESTProcessor(String name) {
+        this.name = name;
+    }
+
+    /**
+     * Check whether this processor can handle the given request
+     *
+     * @param synCtx MessageContext of the message to be processed
+     * @return true if the processor is suitable for handling the message
+     */
+    abstract boolean canProcess(MessageContext synCtx);
+
+    /**
+     * Process the given message through this processor instance
+     *
+     * @param synCtx MessageContext of the message to be processed
+     */
+    abstract void process(MessageContext synCtx);
+
+    protected void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
+    }
+
+    protected void handleException(String msg, Exception e) {
+        log.error(msg, e);
+        throw new SynapseException(msg, e);
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/Resource.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/Resource.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/Resource.java	(revision 1214211)
@@ -0,0 +1,427 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.axiom.util.UIDGenerator;
+import org.apache.axis2.Constants;
+import org.apache.http.HttpHeaders;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.ManagedLifecycle;
+import org.apache.synapse.Mediator;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.core.SynapseEnvironment;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.core.axis2.Axis2Sender;
+import org.apache.synapse.mediators.MediatorFaultHandler;
+import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.rest.dispatch.DispatcherHelper;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+public class Resource extends AbstractRESTProcessor implements ManagedLifecycle {
+
+    /**
+     * List of HTTP methods applicable on this method. Empty list means all methods
+     * are applicable.
+     */
+    private Set<String> methods = new HashSet<String>(4);
+
+    private String contentType;
+
+    private String userAgent;
+
+    private int protocol = RESTConstants.PROTOCOL_HTTP_AND_HTTPS;
+
+    /**
+     * In-lined sequence to be executed upon receiving messages
+     */
+    private SequenceMediator inSequence;
+
+    private SequenceMediator outSequence;
+
+    private SequenceMediator faultSequence;
+
+    /**
+     * Identifier of the sequence to be executed upon receiving a message
+     */
+    private String inSequenceKey;
+
+    private String outSequenceKey;
+
+    private String faultSequenceKey;
+
+    /**
+     * DispatcherHelper instance which is  used to determine whether a particular resource
+     * should be dispatched to this resource or not
+     */
+    private DispatcherHelper dispatcherHelper;
+
+    public Resource() {
+        super(UIDGenerator.generateUID());
+    }
+
+    protected String getName() {
+        return name;
+    }
+
+    public SequenceMediator getInSequence() {
+        return inSequence;
+    }
+
+    public void setInSequence(SequenceMediator inSequence) {
+        this.inSequence = inSequence;
+    }
+
+    public SequenceMediator getOutSequence() {
+        return outSequence;
+    }
+
+    public void setOutSequence(SequenceMediator outSequence) {
+        this.outSequence = outSequence;
+    }
+
+    public String getInSequenceKey() {
+        return inSequenceKey;
+    }
+
+    public void setInSequenceKey(String inSequenceKey) {
+        this.inSequenceKey = inSequenceKey;
+    }
+
+    public String getOutSequenceKey() {
+        return outSequenceKey;
+    }
+
+    public void setOutSequenceKey(String outSequenceKey) {
+        this.outSequenceKey = outSequenceKey;
+    }
+
+    public SequenceMediator getFaultSequence() {
+        return faultSequence;
+    }
+
+    public void setFaultSequence(SequenceMediator faultSequence) {
+        this.faultSequence = faultSequence;
+    }
+
+    public String getFaultSequenceKey() {
+        return faultSequenceKey;
+    }
+
+    public void setFaultSequenceKey(String faultSequenceKey) {
+        this.faultSequenceKey = faultSequenceKey;
+    }
+
+    public boolean addMethod(String method) {
+        for (RESTConstants.METHODS allowedMethod : RESTConstants.METHODS.values()) {
+            if (allowedMethod.name().equals(method)) {
+                methods.add(method);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public String[] getMethods() {
+        return methods.toArray(new String[methods.size()]);
+    }
+
+    public DispatcherHelper getDispatcherHelper() {
+        return dispatcherHelper;
+    }
+
+    public void setDispatcherHelper(DispatcherHelper dispatcherHelper) {
+        this.dispatcherHelper = dispatcherHelper;
+    }
+
+    public String getContentType() {
+        return contentType;
+    }
+
+    public void setContentType(String contentType) {
+        if (contentType.indexOf('/') == -1 || contentType.split("/").length != 2) {
+            throw new SynapseException("Invalid content type: " + contentType);
+        }
+        this.contentType = contentType;
+    }
+
+    public String getUserAgent() {
+        return userAgent;
+    }
+
+    public void setUserAgent(String userAgent) {
+        this.userAgent = userAgent;
+    }
+
+    public int getProtocol() {
+        return protocol;
+    }
+
+    public void setProtocol(int protocol) {
+        this.protocol = protocol;
+    }
+
+    @Override
+    boolean canProcess(MessageContext synCtx) {
+        if (synCtx.isResponse()) {
+            return true;
+        }
+
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        if (protocol == RESTConstants.PROTOCOL_HTTP_ONLY &&
+                !Constants.TRANSPORT_HTTP.equals(msgCtx.getIncomingTransportName())) {
+            if (log.isDebugEnabled()) {
+                log.debug("Protocol information does not match - Expected HTTP");
+            }
+            return false;
+        }
+
+        if (protocol == RESTConstants.PROTOCOL_HTTPS_ONLY &&
+                !Constants.TRANSPORT_HTTPS.equals(msgCtx.getIncomingTransportName())) {
+            if (log.isDebugEnabled()) {
+                log.debug("Protocol information does not match - Expected HTTPS");
+            }
+            return false;
+        }
+
+        String method = (String) msgCtx.getProperty(Constants.Configuration.HTTP_METHOD);
+        synCtx.setProperty(RESTConstants.REST_METHOD, method);
+
+        if (RESTConstants.METHOD_OPTIONS.equals(method)) {
+            return true; // OPTIONS requests are always welcome
+        } else if (!methods.isEmpty()) {
+            if (!methods.contains(method)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("HTTP method does not match");
+                }
+                return false;
+            }
+        }
+
+        Map transportHeaders = (Map) msgCtx.getProperty(
+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
+        if ((contentType != null || userAgent != null) && transportHeaders == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Transport headers not available on the message");
+            }
+            return false;
+        }
+
+        boolean hasPayload = !Boolean.TRUE.equals(msgCtx.getProperty(NhttpConstants.NO_ENTITY_BODY));
+        if (contentType != null && hasPayload) {
+            String type = (String) transportHeaders.get(HTTP.CONTENT_TYPE);
+            if (!contentType.equals(type)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Content type does not match - Expected: " + contentType + ", " +
+                            "Found: " + type);
+                }
+                return false;
+            }
+        }
+
+        if (userAgent != null) {
+            String agent = (String) transportHeaders.get(HTTP.USER_AGENT);
+            if (agent == null || !agent.matches(this.userAgent)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("User agent does not match - Expected: " + userAgent + ", " +
+                            "Found: " + agent);
+                }
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    void process(MessageContext synCtx) {
+        if (log.isDebugEnabled()) {
+            log.debug("Processing message with ID: " + synCtx.getMessageID() + " through the " +
+                    "resource: " + name);
+        }
+
+        if (!synCtx.isResponse()) {
+            String method = (String) synCtx.getProperty(RESTConstants.REST_METHOD);
+            if (RESTConstants.METHOD_OPTIONS.equals(method) && sendOptions(synCtx)) {
+                return;
+            }
+
+            synCtx.setProperty(RESTConstants.SYNAPSE_RESOURCE, name);
+            String path = RESTUtils.getFullRequestPath(synCtx);
+
+            int queryIndex = path.indexOf('?');
+            if (queryIndex != -1) {
+                String query = path.substring(queryIndex + 1);
+                String[] entries = query.split("&");
+                for (String entry : entries) {
+                    int index = entry.indexOf('=');
+                    if (index != -1) {
+                        try {
+                            String name = entry.substring(0, index);
+                            String value = URLDecoder.decode(entry.substring(index + 1),
+                                    RESTConstants.DEFAULT_ENCODING);
+                            synCtx.setProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + name, value);
+                        } catch (UnsupportedEncodingException ignored) {
+
+                        }
+                    }
+                }
+            }
+        }
+
+        SequenceMediator sequence = synCtx.isResponse() ? outSequence : inSequence;
+        if (sequence != null) {
+            registerFaultHandler(synCtx);
+            sequence.mediate(synCtx);
+            return;
+        }
+
+        String sequenceKey = synCtx.isResponse() ? outSequenceKey : inSequenceKey;
+        if (sequenceKey != null) {
+            registerFaultHandler(synCtx);
+            Mediator referredSequence = synCtx.getSequence(sequenceKey);
+            if (referredSequence != null) {
+                referredSequence.mediate(synCtx);
+            } else {
+                throw new SynapseException("Specified sequence: " + sequenceKey + " cannot " +
+                        "be found");
+            }
+            return;
+        }
+
+        // Neither a sequence nor a sequence key has been specified. If this message is a
+        // response, simply send it back to the client.
+        if (synCtx.isResponse()) {
+            if (log.isDebugEnabled()) {
+                log.debug("No out-sequence configured. Sending the response back.");
+            }
+            registerFaultHandler(synCtx);
+            Axis2Sender.sendBack(synCtx);
+        } else if (log.isDebugEnabled()) {
+            log.debug("No in-sequence configured. Dropping the request.");
+        }
+    }
+
+    private void registerFaultHandler(MessageContext synCtx) {
+        if (faultSequence != null) {
+            synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));
+        } else if (faultSequenceKey != null) {
+            Mediator faultSequence = synCtx.getSequence(faultSequenceKey);
+            if (faultSequence != null) {
+                synCtx.pushFaultHandler(new MediatorFaultHandler(faultSequence));
+            } else {
+                synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));
+            }
+        } else {
+            synCtx.pushFaultHandler(new MediatorFaultHandler(synCtx.getFaultSequence()));
+        }
+    }
+
+    private boolean sendOptions(MessageContext synCtx) {
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        Map<String,String> transportHeaders = (Map<String,String>) msgCtx.getProperty(
+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
+
+        if (methods.contains(RESTConstants.METHOD_OPTIONS)) {
+            // Resource should mediate the OPTIONS request
+            String maxForwardsHeader = transportHeaders.get(HttpHeaders.MAX_FORWARDS);
+            if (maxForwardsHeader != null) {
+                int maxForwards = Integer.parseInt(maxForwardsHeader);
+                if (maxForwards == 0) {
+                    // Resource should respond to the OPTIONS request
+                    synCtx.setResponse(true);
+                    synCtx.setTo(null);
+                    transportHeaders.put(HttpHeaders.ALLOW, getSupportedMethods());
+                    Axis2Sender.sendBack(synCtx);
+                    return true;
+                } else {
+                    transportHeaders.put(HttpHeaders.MAX_FORWARDS, String.valueOf(maxForwards - 1));
+                }
+            }
+            return false;
+
+        } else {
+            // Resource should respond to the OPTIONS request
+            synCtx.setResponse(true);
+            synCtx.setTo(null);
+            transportHeaders.put(HttpHeaders.ALLOW, getSupportedMethods());
+            Axis2Sender.sendBack(synCtx);
+            return true;
+        }
+    }
+
+    private String getSupportedMethods() {
+        String value = "";
+        if (methods.isEmpty()) {
+            value = RESTConstants.REST_ALL_SUPPORTED_METHODS;
+        } else {
+            for (String method : methods) {
+                if (RESTConstants.METHOD_OPTIONS.equals(method)) {
+                    continue;
+                }
+
+                if (value.length() > 0) {
+                    value += ", ";
+                }
+                value += method;
+            }
+        }
+        return value;
+    }
+
+    public void init(SynapseEnvironment se) {
+        if (log.isDebugEnabled()) {
+            log.debug("Initializing resource with ID: " + name);
+        }
+
+        if (inSequence != null) {
+            inSequence.init(se);
+        }
+        if (outSequence != null) {
+            outSequence.init(se);
+        }
+        if (faultSequence != null) {
+            faultSequence.init(se);
+        }
+    }
+
+    public void destroy() {
+        if (log.isDebugEnabled()) {
+            log.debug("Destroying resource with ID: " + name);
+        }
+
+        if (inSequence != null && inSequence.isInitialized()) {
+            inSequence.destroy();
+        }
+        if (outSequence != null && outSequence.isInitialized()) {
+            outSequence.destroy();
+        }
+        if (faultSequence != null && faultSequence.isInitialized()) {
+            faultSequence.destroy();
+        }
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java	(revision 1214211)
@@ -45,6 +45,7 @@
 import org.apache.synapse.mediators.base.SequenceMediator;
 import org.apache.synapse.registry.Registry;
 import org.apache.axiom.om.OMNode;
+import org.apache.synapse.rest.API;
 
 import javax.xml.namespace.QName;
 import java.io.IOException;
@@ -148,6 +149,8 @@
      */
     private Map<String, Template> endpointTemplates = new ConcurrentHashMap<String, Template>();
 
+    private Map<String, API> apiTable = new ConcurrentHashMap<String, API>();
+
     /**
      * Description/documentation of the configuration
      */
@@ -299,6 +302,51 @@
         return definedTemplates;
     }
 
+    public void addAPI(String name, API api) {
+        if (!apiTable.containsKey(name)) {
+            for (API existingAPI : apiTable.values()) {
+                if (existingAPI.getContext().equals(api.getContext())) {
+                    handleException("URL context: " + api.getContext() + " is already registered" +
+                            " with the API: " + existingAPI.getName());
+                }
+            }
+            apiTable.put(name, api);
+        } else {
+            handleException("Duplicate resource definition by the name: " + name);
+        }
+    }
+
+    public void updateAPI(String name, API api) {
+        if (!apiTable.containsKey(name)) {
+            handleException("No API exists by the name: " + name);
+        } else {
+            for (API existingAPI : apiTable.values()) {
+                if (existingAPI.getContext().equals(api.getContext()) && !name.equals(api.getName())) {
+                    handleException("URL context: " + api.getContext() + " is already registered" +
+                            " with the API: " + existingAPI.getName());
+                }
+            }
+            apiTable.put(name, api);
+        }
+    }
+
+    public Collection<API> getAPIs() {
+        return Collections.unmodifiableCollection(apiTable.values());
+    }
+
+    public API getAPI(String name) {
+        return apiTable.get(name);
+    }
+
+    public void removeAPI(String name) {
+        API api = apiTable.get(name);
+        if (api != null) {
+            apiTable.remove(name);
+        } else {
+            handleException("No API exists by the name: " + name);
+        }
+    }
+
      /**
      * Return the template specified with the given key
      *
@@ -1264,8 +1312,9 @@
             mp.destroy();
         }
 
-
-
+        for (API api : apiTable.values()) {
+            api.destroy();
+        }
     }
 
     /**
@@ -1344,6 +1393,10 @@
         for(MessageProcessor messageProcessor : messageProcessors.values()) {
             messageProcessor.init(se);
         }
+
+        for (API api : apiTable.values()) {
+            api.init(se);
+        }
     }
 
     private void handleException(String msg) {
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceFactory.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceFactory.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceFactory.java	(revision 1214211)
@@ -0,0 +1,134 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.config.xml.rest;
+
+import org.apache.axiom.om.OMAttribute;
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.Constants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.config.xml.SequenceMediatorFactory;
+import org.apache.synapse.config.xml.XMLConfigConstants;
+import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.rest.RESTConstants;
+import org.apache.synapse.rest.Resource;
+import org.apache.synapse.rest.dispatch.URLMappingHelper;
+import org.apache.synapse.rest.dispatch.URITemplateHelper;
+
+import javax.xml.namespace.QName;
+import java.util.Properties;
+
+public class ResourceFactory {
+
+    private static final Log log = LogFactory.getLog(ResourceFactory.class);
+
+    public static Resource createResource(OMElement resourceElt) {
+        Resource resource = new Resource();
+        configureURLMappings(resource, resourceElt);
+        configureSequences(resource, resourceElt);
+        configureFilters(resource, resourceElt);
+        return resource;
+    }
+
+    private static void configureFilters(Resource resource, OMElement resourceElt) {
+        OMAttribute protocolAtt = resourceElt.getAttribute(new QName("protocol"));
+        if (protocolAtt != null && !"".equals(protocolAtt.getAttributeValue())) {
+            if (Constants.TRANSPORT_HTTP.equals(protocolAtt.getAttributeValue())) {
+                resource.setProtocol(RESTConstants.PROTOCOL_HTTP_ONLY);
+            } else if (Constants.TRANSPORT_HTTPS.equals(protocolAtt.getAttributeValue())) {
+                resource.setProtocol(RESTConstants.PROTOCOL_HTTPS_ONLY);
+            } else {
+                handleException("Invalid protocol name: " + protocolAtt.getAttributeValue());
+            }
+        }
+
+        OMAttribute contentTypeAtt = resourceElt.getAttribute(new QName("content-type"));
+        if (contentTypeAtt != null && !"".equals(contentTypeAtt.getAttributeValue())) {
+            resource.setContentType(contentTypeAtt.getAttributeValue());
+        }
+
+        OMAttribute userAgentAtt = resourceElt.getAttribute(new QName("user-agent"));
+        if (userAgentAtt != null && !"".equals(userAgentAtt.getAttributeValue())) {
+            resource.setUserAgent(userAgentAtt.getAttributeValue());
+        }
+
+        OMAttribute methodsAtt = resourceElt.getAttribute(new QName("methods"));
+        if (methodsAtt != null && !"".equals(methodsAtt.getAttributeValue())) {
+            String[] methods = methodsAtt.getAttributeValue().trim().split(" ");
+            for (String method : methods) {
+                boolean added = resource.addMethod(method);
+                if (!added) {
+                    handleException("Invalid or duplicate method definition for resource");
+                }
+            }
+        }
+    }
+
+    private static void configureURLMappings(Resource resource, OMElement resourceElt) {
+        OMAttribute urlMappingAtt = resourceElt.getAttribute(new QName("url-mapping"));
+        OMAttribute uriTemplateAtt = resourceElt.getAttribute(new QName("uri-template"));
+        if (urlMappingAtt != null && !"".equals(urlMappingAtt.getAttributeValue())) {
+            resource.setDispatcherHelper(new URLMappingHelper(urlMappingAtt.getAttributeValue()));
+        } else if (uriTemplateAtt != null && !"".equals(uriTemplateAtt.getAttributeValue())) {
+            resource.setDispatcherHelper(new URITemplateHelper(uriTemplateAtt.getAttributeValue()));
+        }
+    }
+
+    private static void configureSequences(Resource resource, OMElement resourceElt) {
+        OMAttribute inSequenceKeyAtt = resourceElt.getAttribute(new QName("inSequence"));
+        OMElement inSequenceElt = resourceElt.getFirstChildWithName(new QName(
+                XMLConfigConstants.SYNAPSE_NAMESPACE, "inSequence"));
+        if (inSequenceKeyAtt != null && !"".equals(inSequenceKeyAtt.getAttributeValue())) {
+            resource.setInSequenceKey(inSequenceKeyAtt.getAttributeValue());
+        } else if (inSequenceElt != null) {
+            SequenceMediatorFactory fac = new SequenceMediatorFactory();
+            SequenceMediator sequence = fac.createAnonymousSequence(inSequenceElt, new Properties());
+            resource.setInSequence(sequence);
+        }
+
+        OMAttribute outSequenceKeyAtt = resourceElt.getAttribute(new QName("outSequence"));
+        OMElement outSequenceElt = resourceElt.getFirstChildWithName(new QName(
+                XMLConfigConstants.SYNAPSE_NAMESPACE, "outSequence"));
+        if (outSequenceKeyAtt != null && !"".equals(outSequenceKeyAtt.getAttributeValue())) {
+            resource.setOutSequenceKey(outSequenceKeyAtt.getAttributeValue());
+        } else if (outSequenceElt != null) {
+            SequenceMediatorFactory fac = new SequenceMediatorFactory();
+            SequenceMediator sequence = fac.createAnonymousSequence(outSequenceElt, new Properties());
+            resource.setOutSequence(sequence);
+        }
+
+        OMAttribute faultSequenceKeyAtt = resourceElt.getAttribute(new QName("faultSequence"));
+        OMElement faultSequenceElt = resourceElt.getFirstChildWithName(new QName(
+                XMLConfigConstants.SYNAPSE_NAMESPACE, "faultSequence"));
+        if (faultSequenceKeyAtt != null && !"".equals(faultSequenceKeyAtt.getAttributeValue())) {
+            resource.setFaultSequenceKey(faultSequenceKeyAtt.getAttributeValue());
+        } else if (faultSequenceElt != null) {
+            SequenceMediatorFactory fac = new SequenceMediatorFactory();
+            SequenceMediator sequence = fac.createAnonymousSequence(faultSequenceElt, new Properties());
+            resource.setFaultSequence(sequence);
+        }
+    }
+
+    private static void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceSerializer.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceSerializer.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/ResourceSerializer.java	(revision 1214211)
@@ -0,0 +1,100 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.config.xml.rest;
+
+import org.apache.axiom.om.OMAbstractFactory;
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.OMFactory;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.config.xml.SequenceMediatorSerializer;
+import org.apache.synapse.rest.RESTConstants;
+import org.apache.synapse.rest.Resource;
+import org.apache.synapse.rest.dispatch.DispatcherHelper;
+import org.apache.synapse.rest.dispatch.URITemplateHelper;
+import org.apache.synapse.rest.dispatch.URLMappingHelper;
+
+public class ResourceSerializer {
+
+    private static final OMFactory fac = OMAbstractFactory.getOMFactory();
+
+    public static OMElement serializeResource(Resource resource) {
+        OMElement resourceElt = fac.createOMElement("resource", SynapseConstants.SYNAPSE_OMNAMESPACE);
+        String[] methods = resource.getMethods();
+        if (methods.length > 0) {
+            String value = "";
+            for (String method : methods) {
+                value += method + " ";
+            }
+            resourceElt.addAttribute("methods", value.trim(), null);
+        }
+
+        if (resource.getContentType() != null) {
+            resourceElt.addAttribute("content-type", resource.getContentType(), null);
+        }
+        if (resource.getUserAgent() != null) {
+            resourceElt.addAttribute("user-agent", resource.getUserAgent(), null);
+        }
+        if (resource.getProtocol() == RESTConstants.PROTOCOL_HTTP_ONLY) {
+            resourceElt.addAttribute("protocol", "http", null);
+        } else if (resource.getProtocol() == RESTConstants.PROTOCOL_HTTPS_ONLY) {
+            resourceElt.addAttribute("protocol", "https", null);
+        }
+
+        DispatcherHelper helper = resource.getDispatcherHelper();
+        if (helper != null) {
+            if (helper instanceof URLMappingHelper) {
+                resourceElt.addAttribute("url-mapping", helper.getString(), null);
+            } else if (helper instanceof URITemplateHelper) {
+                resourceElt.addAttribute("uri-template", helper.getString(), null);
+            }
+        }
+
+        SequenceMediatorSerializer seqSerializer = new SequenceMediatorSerializer();
+        if (resource.getInSequenceKey() != null) {
+            resourceElt.addAttribute("inSequence", resource.getInSequenceKey(), null);
+        } else if (resource.getInSequence() != null) {
+            OMElement inSeqElement = seqSerializer.serializeAnonymousSequence(
+                    null, resource.getInSequence());
+            inSeqElement.setLocalName("inSequence");
+            resourceElt.addChild(inSeqElement);
+        }
+
+        if (resource.getOutSequenceKey() != null) {
+            resourceElt.addAttribute("outSequence", resource.getOutSequenceKey(), null);
+        } else if (resource.getOutSequence() != null) {
+            OMElement outSeqElement = seqSerializer.serializeAnonymousSequence(
+                    null, resource.getOutSequence());
+            outSeqElement.setLocalName("outSequence");
+            resourceElt.addChild(outSeqElement);
+        }
+
+        if (resource.getFaultSequenceKey() != null) {
+            resourceElt.addAttribute("faultSequence", resource.getFaultSequenceKey(), null);
+        } else if (resource.getFaultSequence() != null) {
+            OMElement faultSeqElement = seqSerializer.serializeAnonymousSequence(
+                    null, resource.getFaultSequence());
+            faultSeqElement.setLocalName("faultSequence");
+            resourceElt.addChild(faultSeqElement);
+        }
+
+        return resourceElt;
+    }
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/MultiXMLConfigurationBuilder.java	(revision 1214211)
@@ -77,16 +77,17 @@
  */
 public class MultiXMLConfigurationBuilder {
 
-    public static final String PROXY_SERVICES_DIR  = "proxy-services";
-    public static final String SEQUENCES_DIR       = "sequences";
-    public static final String TEMPLATES_DIR       = "templates";
-    public static final String ENDPOINTS_DIR       = "endpoints";
-    public static final String LOCAL_ENTRY_DIR     = "local-entries";
-    public static final String TASKS_DIR           = "tasks";
-    public static final String EVENTS_DIR          = "event-sources";
-    public static final String EXECUTORS_DIR       = "priority-executors";
-    public static final String MESSAGE_STORE_DIR   = "message-stores";
-    public static final String MESSAGE_PROCESSOR_DIR   = "message-processors";
+    public static final String PROXY_SERVICES_DIR       = "proxy-services";
+    public static final String SEQUENCES_DIR            = "sequences";
+    public static final String TEMPLATES_DIR            = "templates";
+    public static final String ENDPOINTS_DIR            = "endpoints";
+    public static final String LOCAL_ENTRY_DIR          = "local-entries";
+    public static final String TASKS_DIR                = "tasks";
+    public static final String EVENTS_DIR               = "event-sources";
+    public static final String EXECUTORS_DIR            = "priority-executors";
+    public static final String MESSAGE_STORE_DIR        = "message-stores";
+    public static final String MESSAGE_PROCESSOR_DIR    = "message-processors";
+    public static final String REST_API_DIR             = "api";
 
     public static final String REGISTRY_FILE       = "registry.xml";
 
Index: java/pom.xml
===================================================================
--- java/pom.xml	(revision 1214210)
+++ java/pom.xml	(revision 1214211)
@@ -671,6 +671,12 @@
             <artifactId>commons-lang</artifactId>
             <scope>test</scope>
         </dependency>
+
+	<dependency>
+	    <groupId>org.wso2.uri.template</groupId>
+	    <artifactId>wso2-uri-templates</artifactId>
+	    <version>1.0.0</version>
+	</dependency>
         
         <!-- Caching dependencies -->
         <dependency>
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SampleConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SampleConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SampleConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ClientConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ClientConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ClientConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/DerbyConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/DerbyConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/DerbyConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SynapseServerConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SynapseServerConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/SynapseServerConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ServerConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ServerConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/Axis2ServerConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/JMSBrokerConfiguration.java
===================================================================
--- java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/JMSBrokerConfiguration.java	(revision 1214210)
+++ java/modules/integration/src/test/java/org/apache/synapse/samples/framework/config/JMSBrokerConfiguration.java	(revision 1214211)
@@ -1,20 +1,21 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
 
 package org.apache.synapse.samples.framework.config;
 
Index: java/modules/core/src/test/java/org/apache/synapse/config/xml/rest/APISerializationTest.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/config/xml/rest/APISerializationTest.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/config/xml/rest/APISerializationTest.java	(revision 1214211)
@@ -0,0 +1,81 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.config.xml.rest;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axiom.om.util.AXIOMUtil;
+import org.apache.synapse.config.xml.AbstractTestCase;
+import org.apache.synapse.rest.API;
+
+public class APISerializationTest extends AbstractTestCase {
+
+    public void testAPISerialization1() throws Exception {
+        String xml = "<api name=\"test\" context=\"/dictionary\" xmlns=\"http://ws.apache.org/ns/synapse\">" +
+                "<resource url-mapping=\"/admin/view\" inSequence=\"in\" outSequence=\"out\"/></api>";
+        OMElement om = AXIOMUtil.stringToOM(xml);
+        API api = APIFactory.createAPI(om);
+        OMElement out = APISerializer.serializeAPI(api);
+        assertXMLEqual(xml, out.toString());
+    }
+
+    public void testAPISerialization2() throws Exception {
+        String xml = "<api name=\"test\" context=\"/dictionary\" hostname=\"apache.org\" port=\"8243\"" +
+                " xmlns=\"http://ws.apache.org/ns/synapse\"><resource url-mapping=\"/admin/view\" " +
+                "inSequence=\"in\" outSequence=\"out\"/></api>";
+        OMElement om = AXIOMUtil.stringToOM(xml);
+        API api = APIFactory.createAPI(om);
+        OMElement out = APISerializer.serializeAPI(api);
+        assertXMLEqual(xml, out.toString());
+    }
+
+    public void testAPISerialization3() throws Exception {
+        String xml = "<api name=\"test\" context=\"/dictionary\" hostname=\"apache.org\" port=\"8243\"" +
+                " xmlns=\"http://ws.apache.org/ns/synapse\"><resource url-mapping=\"/admin/view\" " +
+                "inSequence=\"in\"><outSequence><log/><send/></outSequence></resource></api>";
+        OMElement om = AXIOMUtil.stringToOM(xml);
+        API api = APIFactory.createAPI(om);
+        OMElement out = APISerializer.serializeAPI(api);
+        assertXMLEqual(xml, out.toString());
+    }
+
+    public void testAPISerialization4() throws Exception {
+        String xml = "<api name=\"test\" context=\"/dictionary\" hostname=\"apache.org\" port=\"8243\"" +
+                " xmlns=\"http://ws.apache.org/ns/synapse\"><resource url-mapping=\"/admin/view\" " +
+                "outSequence=\"out\"><inSequence><log/><send/></inSequence></resource></api>";
+        OMElement om = AXIOMUtil.stringToOM(xml);
+        API api = APIFactory.createAPI(om);
+        OMElement out = APISerializer.serializeAPI(api);
+        assertXMLEqual(xml, out.toString());
+    }
+
+    public void testAPISerialization5() throws Exception {
+        String xml = "<api name=\"test\" context=\"/dictionary\" hostname=\"apache.org\" port=\"8243\"" +
+                " xmlns=\"http://ws.apache.org/ns/synapse\"><resource url-mapping=\"/admin/view/*\" " +
+                "><inSequence><log/><send/></inSequence><outSequence><log/><send/></outSequence></resource>" +
+                "<resource url-mapping=\"/admin/*\"><inSequence><log/><send/></inSequence><outSequence>" +
+                "<log/><send/></outSequence></resource><resource uri-template=\"/{char}/{word}\">" +
+                "<inSequence><send/></inSequence><faultSequence><log level=\"full\"/></faultSequence>" +
+                "</resource></api>";
+        OMElement om = AXIOMUtil.stringToOM(xml);
+        API api = APIFactory.createAPI(om);
+        OMElement out = APISerializer.serializeAPI(api);
+        assertXMLEqual(xml, out.toString());
+    }
+}
Index: java/modules/core/src/test/java/org/apache/synapse/rest/APIDispatcherTest.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/rest/APIDispatcherTest.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/rest/APIDispatcherTest.java	(revision 1214211)
@@ -0,0 +1,178 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.config.SynapseConfiguration;
+
+public class APIDispatcherTest extends RESTMediationTestCase {
+
+    private static final String TEST_API = "TestAPI";
+
+    public void testGeneralAPIDispatch() throws Exception {
+        API api = new API(TEST_API, "/");
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(TEST_API, api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        synCtx = getMessageContext(synapseConfig, false, "/", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+        synCtx = getMessageContext(synapseConfig, false, "/foo/bar?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+    }
+
+    public void testBasicAPIDispatch() throws Exception {
+        API api = new API(TEST_API, "/test");
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(TEST_API, api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        // Messages with '/test' context should ne dispatched
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+        synCtx = getMessageContext(synapseConfig, false, "/test/", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+        synCtx = getMessageContext(synapseConfig, false, "/test?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // Messages WITHOUT the '/test' context should NOT be dispatched
+        synCtx = getMessageContext(synapseConfig, false, "/foo/test/bar?a=5", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test1/bar?a=5", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+    }
+
+    public void testResponseDispatch() throws Exception {
+        API api = new API(TEST_API, "/test");
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(TEST_API, api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        // Messages with '/test' context should ne dispatched
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        synCtx.setResponse(true);
+        assertFalse(handler.process(synCtx));
+
+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, TEST_API);
+        assertTrue(handler.process(synCtx));
+    }
+
+    public void testHostBasedAPIDispatch() throws Exception {
+        API api = new API(TEST_API, "/test");
+        api.setHost("synapse.apache.org");
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(TEST_API, api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        // Messages that don't have the proper host set should not be dispatched
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // Messages with the correct host should be dispatched
+        synCtx = getMessageContext(synapseConfig, false, "/test/", "GET");
+        addHttpHeader(HTTP.TARGET_HOST, "synapse.apache.org", synCtx);
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // API should be able to infer the default HTTP port
+        api.setPort(80);
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // Messages with an incorrect port number should not be dispatched
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar?a=5", "GET");
+        addHttpHeader(HTTP.TARGET_HOST, "synapse.apache.org:8280", synCtx);
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // Messages with the correct port number should be dispatched
+        api.setPort(8280);
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        api.setPort(443);
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar?a=5", "GET");
+        addHttpHeader(HTTP.TARGET_HOST, "synapse.apache.org", synCtx);
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        // API should accurately infer the default HTTPS port
+        synCtx = getMessageContext(synapseConfig, true, "/test/foo/bar?a=5", "GET");
+        addHttpHeader(HTTP.TARGET_HOST, "synapse.apache.org", synCtx);
+        handler.process(synCtx);
+        assertEquals(TEST_API, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+    }
+
+    public void testMultipleAPIDispatch() throws Exception {
+        String apiName1 = "TestAPI1";
+        String apiName2 = "TestAPI2";
+        String apiName3 = "TestAPI3";
+
+        API api1 = new API(apiName1, "/test");
+        API api2 = new API(apiName2, "/dictionary");
+        api2.setHost("synapse.apache.org");
+        API api3 = new API(apiName3, "/foo/bar");
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(apiName1, api1);
+        synapseConfig.addAPI(apiName2, api2);
+        synapseConfig.addAPI(apiName3, api3);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertEquals(apiName1, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat", "GET");
+        addHttpHeader(HTTP.TARGET_HOST, "synapse.apache.org", synCtx);
+        handler.process(synCtx);
+        assertEquals(apiName2, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        synCtx = getMessageContext(synapseConfig, false, "/foo/bar/index.jsp?user=test", "GET");
+        handler.process(synCtx);
+        assertEquals(apiName3, synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+
+        synCtx = getMessageContext(synapseConfig, false, "/foo/index.jsp?user=test", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(RESTConstants.SYNAPSE_REST_API));
+    }
+
+}
\ No newline at end of file
Index: java/modules/core/src/test/java/org/apache/synapse/rest/URITemplateBasedDispatcherTest.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/rest/URITemplateBasedDispatcherTest.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/rest/URITemplateBasedDispatcherTest.java	(revision 1214211)
@@ -0,0 +1,165 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.config.SynapseConfiguration;
+import org.apache.synapse.rest.dispatch.URITemplateHelper;
+
+public class URITemplateBasedDispatcherTest extends RESTMediationTestCase {
+
+    private static final String PROP_NAME = "prop.name";
+    private static final String PROP_VALUE = "prop.value";
+
+    public void testBasicTemplateDispatch1() throws Exception {
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URITemplateHelper("/~{user}"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/~foo", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+        assertEquals("foo", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "user"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/~foo/bar", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testBasicTemplateDispatch2() throws Exception {
+
+        API api = new API("TestAPI", "/");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URITemplateHelper("/dictionary/{char}/{word}"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+        assertEquals("c", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "char"));
+        assertEquals("cat", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "word"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/d/dog/", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+        assertEquals("d", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "char"));
+        assertEquals("dog", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "word"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/c/cat", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat?a=5", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testDefaultDispatch() throws Exception {
+
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URITemplateHelper("/"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testMultipleResourceDispatch() throws Exception {
+
+        API api = new API("TestAPI", "/");
+        Resource resource1 = new Resource();
+        resource1.setDispatcherHelper(new URITemplateHelper("/dictionary/{char}/{word}"));
+        resource1.setInSequence(getTestSequence(PROP_NAME, "r1"));
+        api.addResource(resource1);
+
+        Resource resource2 = new Resource();
+        resource2.setDispatcherHelper(new URITemplateHelper("/dictionary/{char}"));
+        resource2.setInSequence(getTestSequence(PROP_NAME, "r2"));
+        api.addResource(resource2);
+
+        Resource resource3 = new Resource();
+        resource3.setDispatcherHelper(new URITemplateHelper("/dictionary/{char}{#ref}"));
+        resource3.setInSequence(getTestSequence(PROP_NAME, "r3"));
+        api.addResource(resource3);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat", "GET");
+        handler.process(synCtx);
+        assertEquals("r1", synCtx.getProperty(PROP_NAME));
+        assertEquals("c", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "char"));
+        assertEquals("cat", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "word"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/d", "GET");
+        handler.process(synCtx);
+        assertEquals("r2", synCtx.getProperty(PROP_NAME));
+        assertEquals("d", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "char"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/e#test", "GET");
+        handler.process(synCtx);
+        assertEquals("r3", synCtx.getProperty(PROP_NAME));
+        assertEquals("e", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "char"));
+        assertEquals("test", synCtx.getProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + "ref"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat/test", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat#ref", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/dictionary/c/cat?a=5", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+}
Index: java/modules/core/src/test/java/org/apache/synapse/rest/RESTMediationTestCase.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/rest/RESTMediationTestCase.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/rest/RESTMediationTestCase.java	(revision 1214211)
@@ -0,0 +1,72 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import junit.framework.TestCase;
+import org.apache.axis2.Constants;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.config.SynapseConfiguration;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.mediators.TestUtils;
+import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.mediators.builtin.PropertyMediator;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public abstract class RESTMediationTestCase extends TestCase {
+
+    protected MessageContext getMessageContext(SynapseConfiguration synapseConfig, boolean https,
+                                               String url, String method) throws Exception {
+        MessageContext synCtx = TestUtils.createSynapseMessageContext("<foo/>", synapseConfig);
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        if (https) {
+            msgCtx.setIncomingTransportName("https");
+        } else {
+            msgCtx.setIncomingTransportName("http");
+        }
+        msgCtx.setProperty(Constants.Configuration.HTTP_METHOD, method);
+        msgCtx.setProperty(Constants.Configuration.TRANSPORT_IN_URL, url);
+        return synCtx;
+    }
+
+    protected void addHttpHeader(String name, String value, MessageContext synCtx) {
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        Object obj = msgCtx.getProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
+        if (obj != null) {
+            ((Map) obj).put(name, value);
+        } else {
+            Map map = new HashMap();
+            map.put(name, value);
+            msgCtx.setProperty(org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS, map);
+        }
+    }
+
+    protected SequenceMediator getTestSequence(String name, String value) {
+        SequenceMediator seq = new SequenceMediator();
+        PropertyMediator prop = new PropertyMediator();
+        prop.setName(name);
+        prop.setValue(value);
+        seq.addChild(prop);
+        return seq;
+    }
+}
Index: java/modules/core/src/test/java/org/apache/synapse/rest/URLMappingBasedDispatcherTest.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/rest/URLMappingBasedDispatcherTest.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/rest/URLMappingBasedDispatcherTest.java	(revision 1214211)
@@ -0,0 +1,225 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.config.SynapseConfiguration;
+import org.apache.synapse.rest.dispatch.URLMappingHelper;
+
+public class URLMappingBasedDispatcherTest extends RESTMediationTestCase {
+
+    private static final String PROP_NAME = "prop.name";
+    private static final String PROP_VALUE = "prop.value";
+
+    public void testDefaultResourceDispatch() throws Exception {
+
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URLMappingHelper("/"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testPathBasedDispatch() throws Exception {
+
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URLMappingHelper("/foo/bar/*"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testExtensionBasedDispatch() throws Exception {
+
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URLMappingHelper("*.jsp"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/welcome.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/index.jsp?a=5&b=10", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/index.html", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testExactMatchBasedDispatch() throws Exception {
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URLMappingHelper("/foo/bar"));
+        resource.setInSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/", "GET");
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/index.html", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testMultipleResourceDispatch() throws Exception {
+        API api = new API("TestAPI", "/test");
+
+        Resource resource1 = new Resource();
+        resource1.setDispatcherHelper(new URLMappingHelper("/foo/*"));
+        resource1.setInSequence(getTestSequence(PROP_NAME, "resource1"));
+
+        Resource resource2 = new Resource();
+        resource2.setDispatcherHelper(new URLMappingHelper("/foo/bar/*"));
+        resource2.setInSequence(getTestSequence(PROP_NAME, "resource2"));
+
+        Resource resource3 = new Resource();
+        resource3.setDispatcherHelper(new URLMappingHelper("*.jsp"));
+        resource3.setInSequence(getTestSequence(PROP_NAME, "resource3"));
+
+        api.addResource(resource1);
+        api.addResource(resource2);
+        api.addResource(resource3);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/foo/", "GET");
+        handler.process(synCtx);
+        assertEquals("resource1", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/index.html?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals("resource1", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bars", "GET");
+        handler.process(synCtx);
+        assertEquals("resource1", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals("resource1", synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/", "GET");
+        handler.process(synCtx);
+        assertEquals("resource2", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/index.html?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals("resource2", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/hello", "GET");
+        handler.process(synCtx);
+        assertEquals("resource2", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals("resource2", synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals("resource3", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/hello/index.jsp?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals("resource3", synCtx.getProperty(PROP_NAME));
+        synCtx = getMessageContext(synapseConfig, false, "/test/foolish/bars/index.jsp", "GET");
+        handler.process(synCtx);
+        assertEquals("resource3", synCtx.getProperty(PROP_NAME));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/foolish/index.html", "GET");
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+    }
+
+    public void testResponseDispatch() throws Exception {
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URLMappingHelper("/foo/bar/*"));
+        resource.setOutSequence(getTestSequence(PROP_NAME, PROP_VALUE));
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/foo/bar", "GET");
+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, api.getName());
+        synCtx.setResponse(true);
+        handler.process(synCtx);
+        assertNull(synCtx.getProperty(PROP_NAME));
+
+        synCtx.setProperty(RESTConstants.SYNAPSE_RESOURCE, resource.getName());
+        handler.process(synCtx);
+        assertEquals(PROP_VALUE, synCtx.getProperty(PROP_NAME));
+    }
+}
Index: java/modules/core/src/test/java/org/apache/synapse/rest/ResourceTest.java
===================================================================
--- java/modules/core/src/test/java/org/apache/synapse/rest/ResourceTest.java	(nonexistent)
+++ java/modules/core/src/test/java/org/apache/synapse/rest/ResourceTest.java	(revision 1214211)
@@ -0,0 +1,92 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.config.SynapseConfiguration;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.core.axis2.Axis2SynapseEnvironment;
+import org.apache.synapse.core.axis2.MessageContextCreatorForAxis2;
+import org.apache.synapse.core.axis2.SynapseMessageReceiver;
+import org.apache.synapse.mediators.Value;
+import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.mediators.builtin.PropertyMediator;
+import org.apache.synapse.mediators.transform.XSLTMediator;
+import org.apache.synapse.rest.dispatch.URITemplateHelper;
+
+public class ResourceTest extends RESTMediationTestCase {
+
+    public void testQueryParams() throws Exception {
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+
+        RESTRequestHandler handler = new RESTRequestHandler();
+
+        MessageContext synCtx = getMessageContext(synapseConfig, false,
+                "/test/admin?a=5&b=10&user=bar", "GET");
+        handler.process(synCtx);
+        assertEquals("5", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "a"));
+        assertEquals("10", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "b"));
+        assertEquals("bar", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "user"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/admin?a=5", "GET");
+        handler.process(synCtx);
+        assertEquals("5", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "a"));
+
+        synCtx = getMessageContext(synapseConfig, false, "/test/admin?a=Hello%20World&b=10&c=/foo/bar", "GET");
+        handler.process(synCtx);
+        assertEquals("Hello World", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "a"));
+        assertEquals("10", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "b"));
+        assertEquals("/foo/bar", synCtx.getProperty(RESTConstants.REST_QUERY_PARAM_PREFIX + "c"));
+    }
+
+    public void testFaultSequence() throws Exception {
+        API api = new API("TestAPI", "/test");
+        Resource resource = new Resource();
+        resource.setDispatcherHelper(new URITemplateHelper("/~{user}"));
+        SequenceMediator inSequence = getTestSequence("seq.in", "seq.in.value");
+        ((PropertyMediator) inSequence.getChild(0)).setScope("axis2");
+        XSLTMediator xsltMediator = new XSLTMediator();
+        xsltMediator.setXsltKey(new Value("/bogus/key"));
+        inSequence.addChild(xsltMediator);
+        resource.setInSequence(inSequence);
+        SequenceMediator faultSequence = getTestSequence("seq.fault", "seq.fault.value");
+        ((PropertyMediator) faultSequence.getChild(0)).setScope("axis2");
+        resource.setFaultSequence(faultSequence);
+        api.addResource(resource);
+
+        SynapseConfiguration synapseConfig = new SynapseConfiguration();
+        synapseConfig.addAPI(api.getName(), api);
+        synapseConfig.addSequence("main", getTestSequence("main.in", "main.value"));
+        MessageContext synCtx = getMessageContext(synapseConfig, false, "/test/~foo", "GET");
+        MessageContextCreatorForAxis2.setSynConfig(synapseConfig);
+        MessageContextCreatorForAxis2.setSynEnv(synCtx.getEnvironment());
+
+        org.apache.axis2.context.MessageContext mc = ((Axis2MessageContext) synCtx).getAxis2MessageContext();
+        mc.setConfigurationContext(((Axis2SynapseEnvironment) synCtx.getEnvironment()).getAxis2ConfigurationContext());
+        new SynapseMessageReceiver().receive(mc);
+        assertEquals("seq.in.value", mc.getProperty("seq.in"));
+        assertEquals("seq.fault.value", mc.getProperty("seq.fault"));
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/message/processors/sampler/SamplingProcessorViewMBean.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/message/processors/sampler/SamplingProcessorViewMBean.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/message/processors/sampler/SamplingProcessorViewMBean.java	(revision 1214211)
@@ -1,20 +1,22 @@
 /*
-*  Copyright (c) 2005-2010, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
-*
-*  WSO2 Inc. licenses this file to you under the Apache License,
-*  Version 2.0 (the "License"); you may not use this file except
-*  in compliance with the License.
-*  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
 package org.apache.synapse.message.processors.sampler;
 
 /**
Index: java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java	(revision 1214211)
@@ -30,6 +30,9 @@
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.*;
 import org.apache.synapse.config.xml.XMLConfigConstants;
+import org.apache.synapse.rest.RESTConstants;
+import org.apache.synapse.rest.RESTRequestHandler;
+import org.apache.synapse.rest.Resource;
 import org.apache.synapse.task.SynapseTaskManager;
 import org.apache.synapse.aspects.statistics.StatisticsCollector;
 import org.apache.synapse.config.SynapseConfiguration;
@@ -61,6 +64,7 @@
     private ExecutorService executorService;
     private boolean initialized = false;
     private SynapseTaskManager taskManager;
+    private RESTRequestHandler restHandler;
 
     /** The StatisticsCollector object */
     private StatisticsCollector statisticsCollector = new StatisticsCollector();
@@ -104,7 +108,8 @@
             synCfg.getProperty(SynapseThreadPool.SYN_THREAD_IDPREFIX,
                 SynapseThreadPool.SYNAPSE_THREAD_ID_PREFIX));
 
-        taskManager = new SynapseTaskManager();                
+        taskManager = new SynapseTaskManager();
+        restHandler = new RESTRequestHandler();
     }
 
     public Axis2SynapseEnvironment(ConfigurationContext cfgCtx,
@@ -172,6 +177,11 @@
                     return false;
                 }
             } else {
+                boolean processed = restHandler.process(synCtx);
+                if (processed) {
+                    return true;
+                }
+
                 if (log.isDebugEnabled()) {
                     log.debug("Using Main Sequence for injected message");
                 }
Index: java/modules/core/src/main/java/org/apache/synapse/deployers/APIDeployer.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/deployers/APIDeployer.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/deployers/APIDeployer.java	(revision 1214211)
@@ -0,0 +1,172 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.deployers;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.axis2.deployment.DeploymentException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.config.xml.MultiXMLConfigurationBuilder;
+import org.apache.synapse.config.xml.rest.APIFactory;
+import org.apache.synapse.config.xml.rest.APISerializer;
+import org.apache.synapse.rest.API;
+
+import java.io.File;
+import java.util.Properties;
+
+public class APIDeployer extends AbstractSynapseArtifactDeployer {
+
+    private static Log log = LogFactory.getLog(APIDeployer.class);
+
+    @Override
+    public String deploySynapseArtifact(OMElement artifactConfig, String fileName, Properties properties) {
+        if (log.isDebugEnabled()) {
+            log.debug("API deployment from file : " + fileName + " : Started");
+        }
+
+        try {
+            API api = APIFactory.createAPI(artifactConfig);
+            if (api != null) {
+                api.setFileName((new File(fileName)).getName());
+                if (log.isDebugEnabled()) {
+                    log.debug("API named '" + api.getName()
+                            + "' has been built from the file " + fileName);
+                }
+                api.init(getSynapseEnvironment());
+                if (log.isDebugEnabled()) {
+                    log.debug("Initialized the API: " + api.getName());
+                }
+                getSynapseConfiguration().addAPI(api.getName(), api);
+                if (log.isDebugEnabled()) {
+                    log.debug("API deployment from file : " + fileName + " : Completed");
+                }
+                log.info("API named '" + api.getName() +
+                        "' has been deployed from file : " + fileName);
+                return api.getName();
+            } else {
+                handleSynapseArtifactDeploymentError("API deployment Failed. The artifact " +
+                        "described in the file " + fileName + " is not a valid API");
+            }
+        } catch (Exception e) {
+            handleSynapseArtifactDeploymentError("API deployment from the file : "
+                    + fileName + " : Failed.", e);
+        }
+
+        return null;
+    }
+
+    @Override
+    public String updateSynapseArtifact(OMElement artifactConfig, String fileName, String existingArtifactName, Properties properties) {
+        if (log.isDebugEnabled()) {
+            log.debug("API update from file : " + fileName + " has started");
+        }
+
+        try {
+            API api = APIFactory.createAPI(artifactConfig);
+            if (api == null) {
+                handleSynapseArtifactDeploymentError("API update failed. The artifact " +
+                        "defined in the file: " + fileName + " is not a valid API.");
+                return null;
+            }
+            api.setFileName(new File(fileName).getName());
+
+            if (log.isDebugEnabled()) {
+                log.debug("API: " + api.getName() + " has been built from the file: " + fileName);
+            }
+
+            api.init(getSynapseEnvironment());
+            API existingAPI = getSynapseConfiguration().getAPI(existingArtifactName);
+            if (existingArtifactName.equals(api.getName())) {
+                getSynapseConfiguration().updateAPI(existingArtifactName, api);
+            } else {
+                // The user has changed the name of the API
+                // We should add the updated API as a new API and remove the old one
+                getSynapseConfiguration().addAPI(api.getName(), api);
+                getSynapseConfiguration().removeAPI(existingArtifactName);
+                log.info("API: " + existingArtifactName + " has been undeployed");
+            }
+
+            log.info("API: " + api.getName() + " has been updated from the file: " + fileName);
+
+            waitForCompletion();
+            existingAPI.destroy();
+            return api.getName();
+
+        } catch (DeploymentException e) {
+            handleSynapseArtifactDeploymentError("Error while updating the API from the " +
+                    "file: " + fileName);
+        }
+
+        return null;
+    }
+
+    @Override
+    public void undeploySynapseArtifact(String artifactName) {
+        if (log.isDebugEnabled()) {
+            log.debug("Undeployment of the API named : "
+                    + artifactName + " : Started");
+        }
+
+        try {
+            API api = getSynapseConfiguration().getAPI(artifactName);
+            if (api != null) {
+                getSynapseConfiguration().removeAPI(artifactName);
+                if (log.isDebugEnabled()) {
+                    log.debug("Undeployment of the API named : "
+                            + artifactName + " : Completed");
+                }
+                log.info("API named '" + api.getName() + "' has been undeployed");
+            } else if (log.isDebugEnabled()) {
+                log.debug("API " + artifactName + " has already been undeployed");
+            }
+        } catch (Exception e) {
+            handleSynapseArtifactDeploymentError(
+                    "Undeployment of API named : " + artifactName + " : Failed", e);
+        }
+    }
+
+    @Override
+    public void restoreSynapseArtifact(String artifactName) {
+        if (log.isDebugEnabled()) {
+            log.debug("Restoring the API with name : " + artifactName + " : Started");
+        }
+
+        try {
+            API api = getSynapseConfiguration().getAPI(artifactName);
+            OMElement apiElement = APISerializer.serializeAPI(api);
+            if (api.getFileName() != null) {
+                String fileName = getServerConfigurationInformation().getSynapseXMLLocation()
+                        + File.separator + MultiXMLConfigurationBuilder.REST_API_DIR
+                        + File.separator + api.getFileName();
+                writeToFile(apiElement, fileName);
+                if (log.isDebugEnabled()) {
+                    log.debug("Restoring the API with name : " + artifactName + " : Completed");
+                }
+                log.info("API named '" + artifactName + "' has been restored");
+            } else {
+                handleSynapseArtifactDeploymentError("Couldn't restore the API named '"
+                        + artifactName + "', filename cannot be found");
+            }
+        } catch (Exception e) {
+            handleSynapseArtifactDeploymentError(
+                    "Restoring of the API named '" + artifactName + "' has failed", e);
+        }
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/RESTConstants.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/RESTConstants.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/RESTConstants.java	(revision 1214211)
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+public class RESTConstants {
+
+    public static enum METHODS {
+        GET, POST, PUT, DELETE, OPTIONS
+    }
+
+    public static final int PROTOCOL_HTTP_AND_HTTPS = 0;
+    public static final int PROTOCOL_HTTP_ONLY      = 1;
+    public static final int PROTOCOL_HTTPS_ONLY     = 2;
+
+    public static final String REST_FULL_REQUEST_PATH = "REST_FULL_REQUEST_PATH";
+    public static final String REST_SUB_REQUEST_PATH = "REST_SUB_REQUEST_PATH";
+    public static final String REST_METHOD = "REST_METHOD";
+    public static final String METHOD_OPTIONS = "OPTIONS";
+    public static final String REST_ALL_SUPPORTED_METHODS = "GET, POST, PUT, DELETE";
+    public static final String REST_URI_VARIABLE_PREFIX = "uri.var.";
+    public static final String REST_QUERY_PARAM_PREFIX = "query.param.";
+
+    public static final String SYNAPSE_RESOURCE = "SYNAPSE_RESOURCE";
+    public static final String SYNAPSE_REST_API = "SYNAPSE_REST_API";
+
+    public static final String REST_API_CONTEXT = "REST_API_CONTEXT";
+    public static final String REST_URL_PREFIX = "REST_URL_PREFIX";
+
+    public static final String DEFAULT_ENCODING = "UTF-8";
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/Handler.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/Handler.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/Handler.java	(revision 1214211)
@@ -0,0 +1,30 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.synapse.MessageContext;
+
+public interface Handler {
+
+    public boolean handleRequest(MessageContext messageContext);
+
+    public boolean handleResponse(MessageContext messageContext);
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/RESTUtils.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/RESTUtils.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/RESTUtils.java	(revision 1214211)
@@ -0,0 +1,105 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.axis2.Constants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.rest.dispatch.RESTDispatcher;
+import org.apache.synapse.rest.dispatch.DefaultDispatcher;
+import org.apache.synapse.rest.dispatch.URLMappingBasedDispatcher;
+import org.apache.synapse.rest.dispatch.URITemplateBasedDispatcher;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RESTUtils {
+
+    private static final Log log = LogFactory.getLog(RESTUtils.class);
+
+    private static final List<RESTDispatcher> dispatchers = new ArrayList<RESTDispatcher>();
+
+    static {
+        dispatchers.add(new URLMappingBasedDispatcher());
+        dispatchers.add(new URITemplateBasedDispatcher());
+        dispatchers.add(new DefaultDispatcher());
+    }
+
+    public static String trimSlashes(String url) {
+        if (url.startsWith("/")) {
+            url = url.substring(1);
+        }
+        if (url.startsWith("/")) {
+            url = url.substring(0, url.length() - 1);
+        }
+        return url;
+    }
+
+    public static String trimTrailingSlashes(String url) {
+        while (url.endsWith("/")) {
+            url = url.substring(0, url.length() - 1);
+        }
+        return url;
+    }
+
+    public static String getFullRequestPath(MessageContext synCtx) {
+        Object obj = synCtx.getProperty(RESTConstants.REST_FULL_REQUEST_PATH);
+        if (obj != null) {
+            return (String) obj;
+        }
+
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        String url = (String) msgCtx.getProperty(Constants.Configuration.TRANSPORT_IN_URL);
+        if (url == null) {
+            url = (String) synCtx.getProperty(NhttpConstants.SERVICE_PREFIX);
+        }
+
+        if (url.contains("://")) {
+            try {
+                url = new URL(url).getPath();
+            } catch (MalformedURLException e) {
+                handleException("Request URL: " + url + " is malformed", e);
+            }
+        }
+        synCtx.setProperty(RESTConstants.REST_FULL_REQUEST_PATH, url);
+        return url;
+    }
+
+    public static String getSubRequestPath(MessageContext synCtx) {
+        return (String) synCtx.getProperty(RESTConstants.REST_SUB_REQUEST_PATH);
+    }
+
+    public static List<RESTDispatcher> getDispatchers() {
+        return dispatchers;
+    }
+
+    private static void handleException(String msg, Throwable t) {
+        log.error(msg, t);
+        throw new SynapseException(msg, t);
+    }
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DefaultDispatcher.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DefaultDispatcher.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DefaultDispatcher.java	(revision 1214211)
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.rest.dispatch.RESTDispatcher;
+import org.apache.synapse.rest.Resource;
+
+import java.util.Collection;
+
+public class DefaultDispatcher implements RESTDispatcher {
+
+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {
+        for (Resource resource : resources) {
+            if (resource.getDispatcherHelper() == null) {
+                return resource;
+            }
+        }
+        return null;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateHelper.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateHelper.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateHelper.java	(revision 1214211)
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.synapse.SynapseException;
+import org.wso2.uri.template.URITemplate;
+import org.wso2.uri.template.URITemplateException;
+
+public class URITemplateHelper implements DispatcherHelper {
+
+    private String templateString;
+
+    private URITemplate uriTemplate;
+
+    public URITemplateHelper(String templateString) {
+        this.templateString = templateString;
+        try {
+            this.uriTemplate = new URITemplate(templateString);
+        } catch (URITemplateException e) {
+            throw new SynapseException("Error while parsing the URI template", e);
+        }
+    }
+
+    public URITemplate getUriTemplate() {
+        return uriTemplate;
+    }
+
+    public String getString() {
+        return templateString;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingHelper.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingHelper.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingHelper.java	(revision 1214211)
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.synapse.rest.RESTUtils;
+
+public class URLMappingHelper implements DispatcherHelper {
+
+    private String[] pathSegments;
+    private String extension;
+    private String exactMatch;
+
+    public URLMappingHelper(String urlMapping) {
+        if (urlMapping.startsWith("/") && urlMapping.endsWith("/*")) {
+            if (urlMapping.length() > 2) {
+                pathSegments = urlMapping.substring(1, urlMapping.length() - 2).split("/");
+            } else {
+                pathSegments = new String[] {};
+            }
+        } else if (urlMapping.startsWith("*.")) {
+            extension = urlMapping.substring(1);
+        } else {
+            exactMatch = urlMapping;
+        }
+    }
+
+    public boolean isExactMatch(String url) {
+        if (!"/".equals(url)) {
+            url = RESTUtils.trimTrailingSlashes(url);
+        }
+        return exactMatch != null && exactMatch.equals(url);
+    }
+
+    public boolean isExtensionMatch(String url) {
+        int index = url.indexOf('?');
+        if (index != -1) {
+            url = url.substring(0, index);
+        }
+        return extension != null && url.endsWith(extension);
+    }
+
+    public int getPrefixMatchingLength(String url) {
+        if (pathSegments != null) {
+            if (pathSegments.length == 0) {
+                return 1;
+            }
+
+            url = RESTUtils.trimSlashes(url);
+            String[] segments = url.split("/");
+            int matchingLength = 0;
+            for (int i = 0; i < pathSegments.length; i++) {
+                if (segments.length > i) {
+                    if (segments[i].equals(pathSegments[i])) {
+                        matchingLength++;
+                    } else {
+                        return 0;
+                    }
+                } else {
+                    return 0;
+                }
+            }
+            return matchingLength;
+        }
+        return 0;
+    }
+
+    public String getString() {
+        if (pathSegments != null) {
+            String str = "";
+            for (String segment : pathSegments) {
+                str += "/" + segment;
+            }
+            return str + "/*";
+        } else if (extension != null) {
+            return "*." + extension;
+        } else {
+            return exactMatch;
+        }
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateBasedDispatcher.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateBasedDispatcher.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URITemplateBasedDispatcher.java	(revision 1214211)
@@ -0,0 +1,50 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.rest.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public class URITemplateBasedDispatcher implements RESTDispatcher {
+
+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {
+        String url = RESTUtils.getSubRequestPath(synCtx);
+        for (Resource r : resources) {
+            DispatcherHelper helper = r.getDispatcherHelper();
+            if (helper instanceof URITemplateHelper) {
+                URITemplateHelper templateHelper = (URITemplateHelper) helper;
+                Map<String,String> variables = new HashMap<String,String>();
+                if (templateHelper.getUriTemplate().matches(url, variables)) {
+                    for (Map.Entry<String,String> entry : variables.entrySet()) {
+                        synCtx.setProperty(RESTConstants.REST_URI_VARIABLE_PREFIX + entry.getKey(),
+                                entry.getValue());
+                    }
+                    return r;
+                }
+            }
+
+        }
+        return null;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/RESTDispatcher.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/RESTDispatcher.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/RESTDispatcher.java	(revision 1214211)
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.rest.Resource;
+
+import java.util.Collection;
+
+/**
+ * Interface for finding a Resource through which a given request can be mediated.
+ * Implementations of this interface should attempt to find a Resource out of the
+ * provided collection using which the given message can br further processed.
+ */
+public interface RESTDispatcher {
+
+    /**
+     * Find a Resource instance suitable for processing the given message
+     *
+     * @param synCtx MessageContext to be processed through a Resource
+     * @param resources Collection of available Resource instances
+     * @return A matching Resource instance or null
+     */
+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources);
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingBasedDispatcher.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingBasedDispatcher.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/URLMappingBasedDispatcher.java	(revision 1214211)
@@ -0,0 +1,87 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.rest.*;
+
+import java.util.*;
+
+public class URLMappingBasedDispatcher implements RESTDispatcher {
+
+    private static final Log log = LogFactory.getLog(URLMappingBasedDispatcher.class);
+
+    public Resource findResource(MessageContext synCtx, Collection<Resource> resources) {
+        List<URLMappingHelper> mappings = new ArrayList<URLMappingHelper>();
+        List<Resource> filteredResources = new ArrayList<Resource>();
+
+        for (Resource r : resources) {
+            DispatcherHelper helper = r.getDispatcherHelper();
+            if (helper instanceof URLMappingHelper) {
+                mappings.add((URLMappingHelper) helper);
+                filteredResources.add(r);
+            }
+        }
+
+        int count = filteredResources.size();
+        if (count == 0) {
+            return null;
+        }
+
+        String url = RESTUtils.getSubRequestPath(synCtx);
+        for (int i = 0; i < count; i++) {
+            if (mappings.get(i).isExactMatch(url)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Found exact URL match for: " + url);
+                }
+                return filteredResources.get(i);
+            }
+        }
+
+        int maxLength = 0;
+        Resource matchedResource = null;
+        for (int i = 0; i < count; i++) {
+            int length = mappings.get(i).getPrefixMatchingLength(url);
+            if (length > maxLength) {
+                maxLength = length;
+                matchedResource = filteredResources.get(i);
+            }
+        }
+        if (matchedResource != null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Found path match for: " + url + " with matching length: " + maxLength);
+            }
+            return matchedResource;
+        }
+
+        for (int i = 0; i < count; i++) {
+            if (mappings.get(i).isExtensionMatch(url)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Found extension match for: " + url);
+                }
+                return filteredResources.get(i);
+            }
+        }
+
+        return null;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DispatcherHelper.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DispatcherHelper.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/dispatch/DispatcherHelper.java	(revision 1214211)
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest.dispatch;
+
+public interface DispatcherHelper {
+
+    public String getString();
+
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/RESTRequestHandler.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/RESTRequestHandler.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/RESTRequestHandler.java	(revision 1214211)
@@ -0,0 +1,89 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.axis2.Constants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+
+import java.util.*;
+
+/**
+ * This class is responsible for receiving requests from various sources and dispatching
+ * them to a suitable REST API for further processing. This is the main entry point for
+ * mediating messages through APIs and Resources.
+ */
+public class RESTRequestHandler {
+
+    private static final Log log = LogFactory.getLog(RESTRequestHandler.class);
+
+    /**
+     * Attempt to process the given message through one of the available APIs. This method
+     * will first try to locate a suitable API for the given message by running it through
+     * the API validation routines available. If a matching API is found it will dispatch
+     * the message to the located API. If a matching API cannot be found, message will be
+     * left intact so any other handlers (eg: main sequence) can pick it up later.
+     *
+     * @param synCtx MessageContext of the request to be processed
+     * @return true if the message was dispatched to an API and false otherwise
+     */
+    public boolean process(MessageContext synCtx) {
+        if (synCtx.isResponse()) {
+            return dispatchToAPI(synCtx);
+        }
+
+        org.apache.axis2.context.MessageContext msgCtx = ((Axis2MessageContext) synCtx).
+                getAxis2MessageContext();
+        String protocol = msgCtx.getIncomingTransportName();
+        if (!Constants.TRANSPORT_HTTP.equals(protocol) && !Constants.TRANSPORT_HTTPS.equals(protocol)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Invalid protocol for REST API mediation: " + protocol);
+            }
+            return false;
+        }
+
+        return dispatchToAPI(synCtx);
+    }
+
+    private boolean dispatchToAPI(MessageContext synCtx) {
+        Collection<API> apiSet = synCtx.getEnvironment().getSynapseConfiguration().getAPIs();
+        API defaultAPI = null;
+        for (API api : apiSet) {
+            if ("/".equals(api.getContext())) {
+                defaultAPI = api;
+            } else if (api.canProcess(synCtx)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Located specific API: " + api.getName() + " for processing message");
+                }
+                api.process(synCtx);
+                return true;
+            }
+        }
+
+        if (defaultAPI != null && defaultAPI.canProcess(synCtx)) {
+            defaultAPI.process(synCtx);
+            return true;
+        }
+
+        return false;
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/rest/API.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/rest/API.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/rest/API.java	(revision 1214211)
@@ -0,0 +1,311 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.rest;
+
+import org.apache.axis2.Constants;
+import org.apache.http.protocol.HTTP;
+import org.apache.synapse.ManagedLifecycle;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.core.SynapseEnvironment;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.rest.dispatch.DispatcherHelper;
+import org.apache.synapse.rest.dispatch.RESTDispatcher;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
+
+import java.util.*;
+
+public class API extends AbstractRESTProcessor implements ManagedLifecycle {
+
+    private String host;
+    private int port = -1;
+    private String context;
+    private Map<String,Resource> resources = new LinkedHashMap<String,Resource>();
+    private List<Handler> handlers = new ArrayList<Handler>();
+
+    private String fileName;
+
+    public API(String name, String context) {
+        super(name);
+        if (!context.startsWith("/")) {
+            handleException("API context must begin with '/' character");
+        }
+        this.context = RESTUtils.trimTrailingSlashes(context);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public String getContext() {
+        return context;
+    }
+
+    public String getHost() {
+        return host;
+    }
+
+    public void setHost(String host) {
+        this.host = host;
+    }
+
+    public int getPort() {
+        return port;
+    }
+
+    public void setPort(int port) {
+        this.port = port;
+    }
+
+    public String getFileName() {
+        return fileName;
+    }
+
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+
+    public void addResource(Resource resource) {
+        DispatcherHelper dispatcherHelper = resource.getDispatcherHelper();
+        if (dispatcherHelper != null) {
+            String mapping = dispatcherHelper.getString();
+            for (Resource r : resources.values()) {
+                DispatcherHelper helper = r.getDispatcherHelper();
+                if (helper != null && helper.getString().equals(mapping) &&
+                        resourceMatches(resource, r)) {
+                    handleException("Two resources cannot have the same path mapping and methods");
+                }
+            }
+        } else {
+            for (Resource r : resources.values()) {
+                DispatcherHelper helper = r.getDispatcherHelper();
+                if (helper == null) {
+                    handleException("Only one resource can be designated as default");
+                }
+            }
+        }
+        resources.put(resource.getName(), resource);
+    }
+
+    private boolean resourceMatches(Resource r1, Resource r2) {
+        String[] methods1 = r1.getMethods();
+        String[] methods2 = r2.getMethods();
+        for (String m1 : methods1) {
+            for (String m2 : methods2) {
+                if (m1.equals(m2)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public Resource[] getResources() {
+        return resources.values().toArray(new Resource[resources.size()]);
+    }
+
+    public void addHandler(Handler handler) {
+        handlers.add(handler);
+    }
+
+    public Handler[] getHandlers() {
+        return handlers.toArray(new Handler[handlers.size()]);
+    }
+
+    boolean canProcess(MessageContext synCtx) {
+        if (synCtx.isResponse()) {
+            String apiName = (String) synCtx.getProperty(RESTConstants.SYNAPSE_REST_API);
+            if (!name.equals(apiName)) {
+                return false;
+            }
+        } else {
+            String path = RESTUtils.getFullRequestPath(synCtx);
+            if (!path.startsWith(context + "/") && !path.startsWith(context + "?") &&
+                    !context.equals(path) && !"/".equals(context)) {
+                if (log.isDebugEnabled()) {
+                    log.debug("API context: " + context + " does not match request URI: " + path);
+                }
+                return false;
+            }
+
+            if (host != null || port != -1) {
+                org.apache.axis2.context.MessageContext msgCtx =
+                        ((Axis2MessageContext) synCtx).getAxis2MessageContext();
+                String hostHeader = getHostHeader(msgCtx);
+                if (hostHeader != null) {
+                    if (host != null && !host.equals(extractHostName(hostHeader))) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("API host: " + host + " does not match host information " +
+                                    "in the request: " + hostHeader);
+                        }
+                        return false;
+                    }
+
+                    if (port != -1 && port != extractPortNumber(hostHeader,
+                            msgCtx.getIncomingTransportName())) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("API port: " + port + " does not match port information " +
+                                    "in the request: " + hostHeader);
+                        }
+                        return false;
+                    }
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Host information not available on the message");
+                    }
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    void process(MessageContext synCtx) {
+        if (log.isDebugEnabled()) {
+            log.debug("Processing message with ID: " + synCtx.getMessageID() + " through the " +
+                    "API: " + name);
+        }
+
+        for (Handler handler : handlers) {
+            if (log.isDebugEnabled()) {
+                log.debug("Processing message with ID: " + synCtx.getMessageID() + " through " +
+                        "handler: " + handler.getClass().getName());
+            }
+
+            boolean proceed;
+            if (synCtx.isResponse()) {
+                proceed = handler.handleResponse(synCtx);
+            } else {
+                proceed = handler.handleRequest(synCtx);
+            }
+
+            if (!proceed) {
+                return;
+            }
+        }
+
+        if (synCtx.isResponse()) {
+            String resourceName = (String) synCtx.getProperty(RESTConstants.SYNAPSE_RESOURCE);
+            if (resourceName != null) {
+                Resource resource = resources.get(resourceName);
+                if (resource != null) {
+                    resource.process(synCtx);
+                }
+            } else if (log.isDebugEnabled()) {
+                log.debug("No resource information on the response: " + synCtx.getMessageID());
+            }
+            return;
+        }
+
+
+        synCtx.setProperty(RESTConstants.SYNAPSE_REST_API, name);
+        synCtx.setProperty(RESTConstants.REST_API_CONTEXT, context);
+        String path = RESTUtils.getFullRequestPath(synCtx);
+        String subPath = path.substring(context.length());
+        if ("".equals(subPath)) {
+            subPath = "/";
+        }
+        synCtx.setProperty(RESTConstants.REST_SUB_REQUEST_PATH, subPath);
+
+        org.apache.axis2.context.MessageContext msgCtx =
+                        ((Axis2MessageContext) synCtx).getAxis2MessageContext();
+        String hostHeader = getHostHeader(msgCtx);
+        if (hostHeader != null) {
+            synCtx.setProperty(RESTConstants.REST_URL_PREFIX,
+                    msgCtx.getIncomingTransportName() + "://" + hostHeader);
+        }
+
+        Set<Resource> acceptableResources = new HashSet<Resource>();
+        for (Resource r : resources.values()) {
+            if (r.canProcess(synCtx)) {
+                acceptableResources.add(r);
+            }
+        }
+
+        boolean processed = false;
+        if (!acceptableResources.isEmpty()) {
+            for (RESTDispatcher dispatcher : RESTUtils.getDispatchers()) {
+                Resource resource = dispatcher.findResource(synCtx, acceptableResources);
+                if (resource != null) {
+                    resource.process(synCtx);
+                    processed = true;
+                    break;
+                }
+            }
+        }
+
+        if (!processed && log.isDebugEnabled()) {
+            log.debug("No matching resource was found for the request: " + synCtx.getMessageID());
+        }
+    }
+
+    private String getHostHeader(org.apache.axis2.context.MessageContext msgCtx) {
+        Map transportHeaders = (Map) msgCtx.getProperty(
+                org.apache.axis2.context.MessageContext.TRANSPORT_HEADERS);
+        String hostHeader = null;
+        if (transportHeaders != null) {
+            hostHeader = (String) transportHeaders.get(HTTP.TARGET_HOST);
+        }
+
+        if (hostHeader == null) {
+            hostHeader = (String) msgCtx.getProperty(NhttpConstants.SERVICE_PREFIX);
+        }
+        return hostHeader;
+    }
+
+    private String extractHostName(String hostHeader) {
+        int index = hostHeader.indexOf(':');
+        if (index != -1) {
+            return hostHeader.substring(0, index);
+        } else {
+            return hostHeader;
+        }
+    }
+
+    private int extractPortNumber(String hostHeader, String transport) {
+        int index = hostHeader.indexOf(':');
+        if (index != -1) {
+            return Integer.parseInt(hostHeader.substring(index + 1));
+        } else if (Constants.TRANSPORT_HTTP.equals(transport)) {
+            return 80;
+        } else {
+            return 443;
+        }
+    }
+
+    public void init(SynapseEnvironment se) {
+        if (resources.isEmpty()) {
+            handleException("The API: " + name + " has been configured without " +
+                    "any resource definitions");
+        }
+
+        log.info("Initializing API: " + name);
+        for (Resource resource : resources.values()) {
+            resource.init(se);
+        }
+    }
+
+    public void destroy() {
+        log.info("Destroying API: " + name);
+        for (Resource resource : resources.values()) {
+            resource.destroy();
+        }
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/SynapseXMLConfigurationSerializer.java	(revision 1214211)
@@ -29,6 +29,7 @@
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.config.xml.endpoints.TemplateSerializer;
+import org.apache.synapse.config.xml.rest.APISerializer;
 import org.apache.synapse.endpoints.Template;
 import org.apache.synapse.mediators.template.TemplateMediator;
 import org.apache.synapse.message.processors.MessageProcessor;
@@ -43,6 +44,7 @@
 import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.eventing.SynapseEventSource;
 import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.rest.API;
 
 import javax.xml.namespace.QName;
 import java.util.Collection;
@@ -150,6 +152,8 @@
        //Message Processors
         serializeMessageProcessors(definitions,synCfg.getMessageProcessors());
 
+        serializeAPIs(definitions, synCfg.getAPIs());
+
         return definitions;
     }
 
@@ -223,6 +227,14 @@
         }
     }
 
+    private static void serializeAPIs(OMElement definitions,
+                                      Collection<API> apiSet) {
+        for (API api : apiSet) {
+            OMElement apiElt = APISerializer.serializeAPI(api);
+            definitions.addChild(apiElt);
+        }
+    }
+
     private static void handleException(String msg) {
         log.error(msg);
         throw new SynapseException(msg);
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APIFactory.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APIFactory.java	(nonexistent)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/rest/APIFactory.java	(revision 1214211)
@@ -0,0 +1,112 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.config.xml.rest;
+
+import org.apache.axiom.om.OMAttribute;
+import org.apache.axiom.om.OMElement;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.config.xml.XMLConfigConstants;
+import org.apache.synapse.rest.API;
+import org.apache.synapse.rest.Handler;
+
+import javax.xml.namespace.QName;
+import java.util.Iterator;
+
+public class APIFactory {
+
+    private static final Log log = LogFactory.getLog(APIFactory.class);
+
+    public static API createAPI(OMElement apiElt) {
+        OMAttribute nameAtt = apiElt.getAttribute(new QName("name"));
+        if (nameAtt == null || "".equals(nameAtt.getAttributeValue())) {
+            handleException("Attribute 'name' is required for an API definition");
+        }
+
+        OMAttribute contextAtt = apiElt.getAttribute(new QName("context"));
+        if (contextAtt == null || "".equals(contextAtt.getAttributeValue())) {
+            handleException("Attribute 'context' is required for an API definition");
+        }
+
+        API api = new API(nameAtt.getAttributeValue(), contextAtt.getAttributeValue());
+
+        OMAttribute hostAtt = apiElt.getAttribute(new QName("hostname"));
+        if (hostAtt != null && !"".equals(hostAtt.getAttributeValue())) {
+            api.setHost(hostAtt.getAttributeValue());
+        }
+
+        OMAttribute portAtt = apiElt.getAttribute(new QName("port"));
+        if (portAtt != null && !"".equals(portAtt.getAttributeValue())) {
+            api.setPort(Integer.parseInt(portAtt.getAttributeValue()));
+        }
+
+        Iterator resources = apiElt.getChildrenWithName(new QName(
+                XMLConfigConstants.SYNAPSE_NAMESPACE, "resource"));
+        boolean noResources = true;
+        while (resources.hasNext()) {
+            OMElement resourceElt = (OMElement) resources.next();
+            api.addResource(ResourceFactory.createResource(resourceElt));
+            noResources = false;
+        }
+
+        if (noResources) {
+            handleException("An API must contain at least one resource definition");
+        }
+
+        OMElement handlersElt = apiElt.getFirstChildWithName(new QName(
+                XMLConfigConstants.SYNAPSE_NAMESPACE, "handlers"));
+        if (handlersElt != null) {
+            Iterator handlers = handlersElt.getChildrenWithName(new QName(
+                    XMLConfigConstants.SYNAPSE_NAMESPACE, "handler"));
+            while (handlers.hasNext()) {
+                OMElement handlerElt = (OMElement) handlers.next();
+                defineHandler(api, handlerElt);
+            }
+        }
+
+        return api;
+    }
+
+    private static void defineHandler(API api, OMElement handlerElt) {
+        String handlerClass = handlerElt.getAttributeValue(new QName("class"));
+        if (handlerClass == null || "".equals(handlerClass)) {
+            handleException("A handler element must have a class attribute");
+        }
+
+        try {
+            Class clazz = APIFactory.class.getClassLoader().loadClass(handlerClass);
+            Handler handler = (Handler) clazz.newInstance();
+            api.addHandler(handler);
+        } catch (Exception e) {
+            handleException("Error initializing API handler: " + handlerClass, e);
+        }
+    }
+
+    private static void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
+    }
+
+    private static void handleException(String msg, Exception e) {
+        log.error(msg, e);
+        throw new SynapseException(msg, e);
+    }
+}
Index: java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java
===================================================================
--- java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java	(revision 1214210)
+++ java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java	(revision 1214211)
@@ -72,8 +72,8 @@
     public static final QName PROXY_ELT       = new QName(SYNAPSE_NAMESPACE, "proxy");
     public static final QName EVENT_SOURCE_ELT = new QName(SYNAPSE_NAMESPACE, "eventSource");
     public static final QName MESSAGE_STORE_ELT = new QName(SYNAPSE_NAMESPACE, "messageStore");
-    public static final QName MESSAGE_PROCESSOR_ELT = new QName(SYNAPSE_NAMESPACE ,
-                                                                                "messageProcessor");
+    public static final QName MESSAGE_PROCESSOR_ELT = new QName(SYNAPSE_NAMESPACE, "messageProcessor");
+    public static final QName API_ELT = new QName(SYNAPSE_NAMESPACE, "api");
 
     public static final String NULL_NAMESPACE = "";
     public static final Object QUARTZ_QNAME   =
Index: java/modules/core/pom.xml
===================================================================
--- java/modules/core/pom.xml	(revision 1214210)
+++ java/modules/core/pom.xml	(revision 1214211)
@@ -149,6 +149,7 @@
                             org.apache.synapse.message.*,
                             org.apache.synapse.metrics.*,
                             org.apache.synapse.registry.*,
+                            org.apache.synapse.rest.*,
                             org.apache.synapse.startup.*,
                             org.apache.synapse.util.*,
                         </Export-Package>
Index: java/repository/conf/axis2.xml
===================================================================
--- java/repository/conf/axis2.xml	(revision 1214210)
+++ java/repository/conf/axis2.xml	(revision 1214211)
@@ -92,6 +92,7 @@
     <deployer extension="xml" directory="conf/synapse-config/templates" class="org.apache.synapse.deployers.TemplateDeployer"/>
     <deployer extension="xml" directory="conf/synapse-config/message-stores" class="org.apache.synapse.deployers.MessageStoreDeployer"/>
     <deployer extension="xml" directory="conf/synapse-config/message-processors" class="org.apache.synapse.deployers.MessageProcessorDeployer"/>
+    <deployer extension="xml" directory="conf/synapse-config/api" class="org.apache.synapse.deployers.APIDeployer"/>
 
     <!-- Following parameter will set the host name for the epr-->
     <!--<parameter name="hostname" locked="true">myhost.com</parameter>-->
-*-*-*-
REST API support and some improvements to the integration test framework